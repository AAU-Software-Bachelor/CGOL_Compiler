/* JavaParser.java */
/* Generated By:JavaCC: Do not edit this line. JavaParser.java */
import java.io.IOException;
import syntaxtree.*;
import java.util.Vector;


public class JavaParser implements JavaParserConstants {
   public void printDebugInfo(String productionName)
   {
      Token t = this.getToken(1);
      System.err.println("Parsing " + productionName+ " at line "+ t.beginLine+ ", column "+ t.beginColumn);
   }
   public static void main(String args[])
   {
      JavaParser parser;
      if ( args.length == 0 )
      {
         System.out.println("==========================================================================================================");
         System.out.println("==========================================================================================================");
         System.out.println("Java Parser Version 1.0.2:  Reading from standard input . . .");
         parser = new JavaParser(System.in);
      }
      else
         if ( args.length == 1 )
         {
            System.out.println("==========================================================================================================");
            System.out.println("==========================================================================================================");
            System.out.println("Java Parser Version 1.0.2:  Reading from file " + args[0]+ " . . .");
            try
            {
               parser = new JavaParser(new java.io.FileInputStream(args[0]));
            }
            catch (java.io.FileNotFoundException e)
            {
               System.out.println("Java Parser Version 1.0.2:  File " + args[0]+ " not found.");
               return;
            }
         }
         else
         {
            System.out.println("Java Parser Version 1.0.2:  Usage is one of:");
            System.out.println("         java JavaParser < inputfile");
            System.out.println("OR");
            System.out.println("         java JavaParser inputfile");
            return;
         }
      try
      {
         Node root = parser.CompilationUnit();
         MyVisitor v = new MyVisitor();
         root.accept(v);
         System.out.println("Java Parser Version 1.0.2:  Java program parsed successfully.");
      }
      catch (ParseException e)
      {
         System.out.println("Java Parser Version 1.0.2:  Encountered errors during parse.");
         System.out.println(e.toString());
      }
   }

  final public CompilationUnit CompilationUnit() throws ParseException {NodeOptional n0 = new NodeOptional();
   PackageDeclaration n1;
   NodeListOptional n2 = new NodeListOptional();
   ImportDeclaration n3;
   NodeListOptional n4 = new NodeListOptional();
   TypeDeclaration n5;
   NodeToken n6;
   Token n7;

   printDebugInfo("CompilationUnit");
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PACKAGE:{
      n1 = PackageDeclaration();
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IMPORT:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      n3 = ImportDeclaration();
n2.addNode(n3);
    }
n2.nodes.trimToSize();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case CLASS:
      case FINAL:
      case INTERFACE:
      case PUBLIC:
      case SEMICOLON:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      n5 = TypeDeclaration();
n4.addNode(n5);
    }
n4.nodes.trimToSize();
    n7 = jj_consume_token(0);
n7.beginColumn++; n7.endColumn++;
      n6 = JTBToolkit.makeNodeToken(n7);
{if ("" != null) return new CompilationUnit(n0,n2,n4,n6);}
    throw new Error("Missing return statement in function");
}

  final public PackageDeclaration PackageDeclaration() throws ParseException {NodeToken n0;
   Token n1;
   Name n2;
   NodeToken n3;
   Token n4;

   printDebugInfo("PackageDeclaration");
    n1 = jj_consume_token(PACKAGE);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name();
    n4 = jj_consume_token(SEMICOLON);
n3 = JTBToolkit.makeNodeToken(n4);
{if ("" != null) return new PackageDeclaration(n0,n2,n3);}
    throw new Error("Missing return statement in function");
}

  final public ImportDeclaration ImportDeclaration() throws ParseException {NodeToken n0;
   Token n1;
   Name n2;
   NodeOptional n3 = new NodeOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;

   printDebugInfo("ImportDeclaration");
    n1 = jj_consume_token(IMPORT);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Name();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DOT:{
n4 = new NodeSequence(2);
      n6 = jj_consume_token(DOT);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n8 = jj_consume_token(STAR);
n7 = JTBToolkit.makeNodeToken(n8);
n4.addNode(n7);
n3.addNode(n4);
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    n10 = jj_consume_token(SEMICOLON);
n9 = JTBToolkit.makeNodeToken(n10);
{if ("" != null) return new ImportDeclaration(n0,n2,n3,n9);}
    throw new Error("Missing return statement in function");
}

  final public TypeDeclaration TypeDeclaration() throws ParseException {NodeChoice n0;
   ClassDeclaration n1;
   InterfaceDeclaration n2;
   NodeToken n3;
   Token n4;

   printDebugInfo("TypeDeclaration");
    if (jj_2_1(2147483647)) {
      n1 = ClassDeclaration();
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case INTERFACE:
      case PUBLIC:{
        n2 = InterfaceDeclaration();
n0 = new NodeChoice(n2, 1);
        break;
        }
      case SEMICOLON:{
        n4 = jj_consume_token(SEMICOLON);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 2);
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new TypeDeclaration(n0);}
    throw new Error("Missing return statement in function");
}

  final public ClassDeclaration ClassDeclaration() throws ParseException {NodeListOptional n0 = new NodeListOptional();
   NodeChoice n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   NodeOptional n12 = new NodeOptional();
   NodeSequence n13;
   NodeToken n14;
   Token n15;
   Name n16;
   NodeOptional n17 = new NodeOptional();
   NodeSequence n18;
   NodeToken n19;
   Token n20;
   NameList n21;
   NodeToken n22;
   Token n23;
   NodeList n24 = new NodeList();
   ClassBodyDeclaration n25;
   NodeToken n26;
   Token n27;

   printDebugInfo("ClassDeclaration");
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case PUBLIC:{
        ;
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:{
        n3 = jj_consume_token(ABSTRACT);
n2 = JTBToolkit.makeNodeToken(n3);
n1 = new NodeChoice(n2, 0);
        break;
        }
      case FINAL:{
        n5 = jj_consume_token(FINAL);
n4 = JTBToolkit.makeNodeToken(n5);
n1 = new NodeChoice(n4, 1);
        break;
        }
      case PUBLIC:{
        n7 = jj_consume_token(PUBLIC);
n6 = JTBToolkit.makeNodeToken(n7);
n1 = new NodeChoice(n6, 2);
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
    }
n0.nodes.trimToSize();
    n9 = jj_consume_token(CLASS);
n8 = JTBToolkit.makeNodeToken(n9);
    n11 = jj_consume_token(IDENTIFIER);
n10 = JTBToolkit.makeNodeToken(n11);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
n13 = new NodeSequence(2);
      n15 = jj_consume_token(EXTENDS);
n14 = JTBToolkit.makeNodeToken(n15);
n13.addNode(n14);
      n16 = Name();
n13.addNode(n16);
n12.addNode(n13);
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IMPLEMENTS:{
n18 = new NodeSequence(2);
      n20 = jj_consume_token(IMPLEMENTS);
n19 = JTBToolkit.makeNodeToken(n20);
n18.addNode(n19);
      n21 = NameList();
n18.addNode(n21);
n17.addNode(n18);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    n23 = jj_consume_token(LBRACE);
n22 = JTBToolkit.makeNodeToken(n23);
    label_4:
    while (true) {
      n25 = ClassBodyDeclaration();
n24.addNode(n25);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case NEW:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case SYNCHRONIZED:
      case VOID:
      case IDENTIFIER:
      case SEMICOLON:{
        ;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
    }
n24.nodes.trimToSize();
    n27 = jj_consume_token(RBRACE);
n26 = JTBToolkit.makeNodeToken(n27);
{if ("" != null) return new ClassDeclaration(n0,n8,n10,n12,n17,n22,n24,n26);}
    throw new Error("Missing return statement in function");
}

  final public ClassBodyDeclaration ClassBodyDeclaration() throws ParseException {NodeChoice n0;
   StaticInitializer n1;
   ConstructorDeclaration n2;
   MethodDeclaration n3;
   FieldDeclaration n4;
   EmptyStatement n5;

   printDebugInfo("ClassBodyDeclaration");
    if (jj_2_2(2)) {
      n1 = StaticInitializer();
n0 = new NodeChoice(n1, 0);
    } else if (jj_2_3(2147483647)) {
      n2 = ConstructorDeclaration();
n0 = new NodeChoice(n2, 1);
    } else if (jj_2_4(2147483647)) {
      n3 = MethodDeclaration();
n0 = new NodeChoice(n3, 2);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case IDENTIFIER:{
        n4 = FieldDeclaration();
n0 = new NodeChoice(n4, 3);
        break;
        }
      case SEMICOLON:{
        n5 = EmptyStatement();
n0 = new NodeChoice(n5, 4);
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new ClassBodyDeclaration(n0);}
    throw new Error("Missing return statement in function");
}

  final public MethodDeclarationLookahead MethodDeclarationLookahead() throws ParseException {NodeListOptional n0 = new NodeListOptional();
   NodeChoice n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   NodeToken n12;
   Token n13;
   NodeToken n14;
   Token n15;
   NodeToken n16;
   Token n17;
   ResultType n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;

   printDebugInfo("MethodDeclarationLookahead");
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case SYNCHRONIZED:{
        ;
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PUBLIC:{
        n3 = jj_consume_token(PUBLIC);
n2 = JTBToolkit.makeNodeToken(n3);
n1 = new NodeChoice(n2, 0);
        break;
        }
      case PROTECTED:{
        n5 = jj_consume_token(PROTECTED);
n4 = JTBToolkit.makeNodeToken(n5);
n1 = new NodeChoice(n4, 1);
        break;
        }
      case PRIVATE:{
        n7 = jj_consume_token(PRIVATE);
n6 = JTBToolkit.makeNodeToken(n7);
n1 = new NodeChoice(n6, 2);
        break;
        }
      case STATIC:{
        n9 = jj_consume_token(STATIC);
n8 = JTBToolkit.makeNodeToken(n9);
n1 = new NodeChoice(n8, 3);
        break;
        }
      case ABSTRACT:{
        n11 = jj_consume_token(ABSTRACT);
n10 = JTBToolkit.makeNodeToken(n11);
n1 = new NodeChoice(n10, 4);
        break;
        }
      case FINAL:{
        n13 = jj_consume_token(FINAL);
n12 = JTBToolkit.makeNodeToken(n13);
n1 = new NodeChoice(n12, 5);
        break;
        }
      case NATIVE:{
        n15 = jj_consume_token(NATIVE);
n14 = JTBToolkit.makeNodeToken(n15);
n1 = new NodeChoice(n14, 6);
        break;
        }
      case SYNCHRONIZED:{
        n17 = jj_consume_token(SYNCHRONIZED);
n16 = JTBToolkit.makeNodeToken(n17);
n1 = new NodeChoice(n16, 7);
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
    }
n0.nodes.trimToSize();
    n18 = ResultType();
    n20 = jj_consume_token(IDENTIFIER);
n19 = JTBToolkit.makeNodeToken(n20);
    n22 = jj_consume_token(LPAREN);
n21 = JTBToolkit.makeNodeToken(n22);
{if ("" != null) return new MethodDeclarationLookahead(n0,n18,n19,n21);}
    throw new Error("Missing return statement in function");
}

  final public InterfaceDeclaration InterfaceDeclaration() throws ParseException {NodeListOptional n0 = new NodeListOptional();
   NodeChoice n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeOptional n10 = new NodeOptional();
   NodeSequence n11;
   NodeToken n12;
   Token n13;
   NameList n14;
   NodeToken n15;
   Token n16;
   NodeListOptional n17 = new NodeListOptional();
   InterfaceMemberDeclaration n18;
   NodeToken n19;
   Token n20;

   printDebugInfo("InterfaceDeclaration");
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case PUBLIC:{
        ;
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:{
        n3 = jj_consume_token(ABSTRACT);
n2 = JTBToolkit.makeNodeToken(n3);
n1 = new NodeChoice(n2, 0);
        break;
        }
      case PUBLIC:{
        n5 = jj_consume_token(PUBLIC);
n4 = JTBToolkit.makeNodeToken(n5);
n1 = new NodeChoice(n4, 1);
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
    }
n0.nodes.trimToSize();
    n7 = jj_consume_token(INTERFACE);
n6 = JTBToolkit.makeNodeToken(n7);
    n9 = jj_consume_token(IDENTIFIER);
n8 = JTBToolkit.makeNodeToken(n9);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
n11 = new NodeSequence(2);
      n13 = jj_consume_token(EXTENDS);
n12 = JTBToolkit.makeNodeToken(n13);
n11.addNode(n12);
      n14 = NameList();
n11.addNode(n14);
n10.addNode(n11);
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    n16 = jj_consume_token(LBRACE);
n15 = JTBToolkit.makeNodeToken(n16);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case NEW:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case SYNCHRONIZED:
      case VOID:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
      n18 = InterfaceMemberDeclaration();
n17.addNode(n18);
    }
n17.nodes.trimToSize();
    n20 = jj_consume_token(RBRACE);
n19 = JTBToolkit.makeNodeToken(n20);
{if ("" != null) return new InterfaceDeclaration(n0,n6,n8,n10,n15,n17,n19);}
    throw new Error("Missing return statement in function");
}

  final public InterfaceMemberDeclaration InterfaceMemberDeclaration() throws ParseException {NodeChoice n0;
   MethodDeclaration n1;
   FieldDeclaration n2;

   printDebugInfo("InterfaceMemberDeclaration");
    if (jj_2_5(2147483647)) {
      n1 = MethodDeclaration();
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case IDENTIFIER:{
        n2 = FieldDeclaration();
n0 = new NodeChoice(n2, 1);
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new InterfaceMemberDeclaration(n0);}
    throw new Error("Missing return statement in function");
}

  final public FieldDeclaration FieldDeclaration() throws ParseException {NodeListOptional n0 = new NodeListOptional();
   field_modifier n1;
   Type n2;
   NodeToken n3;
   Token n4;
   field_body n5;

   printDebugInfo("FieldDeclaration");
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case NEW:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:{
        ;
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        break label_8;
      }
      n1 = field_modifier();
n0.addNode(n1);
    }
n0.nodes.trimToSize();
    n2 = Type();
    n4 = jj_consume_token(IDENTIFIER);
n3 = JTBToolkit.makeNodeToken(n4);
    n5 = field_body();
{if ("" != null) return new FieldDeclaration(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
}

  final public field_modifier field_modifier() throws ParseException {NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;

   printDebugInfo("field_modifier");
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEW:{
      n2 = jj_consume_token(NEW);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case PUBLIC:{
      n4 = jj_consume_token(PUBLIC);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1);
      break;
      }
    case PROTECTED:{
      n6 = jj_consume_token(PROTECTED);
n5 = JTBToolkit.makeNodeToken(n6);
n0 = new NodeChoice(n5, 2);
      break;
      }
    case PRIVATE:{
      n8 = jj_consume_token(PRIVATE);
n7 = JTBToolkit.makeNodeToken(n8);
n0 = new NodeChoice(n7, 3);
      break;
      }
    case STATIC:{
      n10 = jj_consume_token(STATIC);
n9 = JTBToolkit.makeNodeToken(n10);
n0 = new NodeChoice(n9, 4);
      break;
      }
    case ABSTRACT:{
      n12 = jj_consume_token(ABSTRACT);
n11 = JTBToolkit.makeNodeToken(n12);
n0 = new NodeChoice(n11, 5);
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new field_modifier(n0);}
    throw new Error("Missing return statement in function");
}

  final public field_body field_body() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeChoice n5;
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   accessor_declarations n9;
   NodeToken n10;
   Token n11;
   NodeToken n12;
   Token n13;
   NodeSequence n14;
   NodeToken n15;
   Token n16;
   accessor_declarations n17;
   NodeToken n18;
   Token n19;
   NodeToken n20;
   Token n21;

   printDebugInfo("field_body");
    if (jj_2_6(3)) {
n1 = new NodeSequence(4);
      n3 = jj_consume_token(ASSIGN);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = Expression();
n1.addNode(n4);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:{
n6 = new NodeSequence(3);
        n8 = jj_consume_token(LBRACE);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
        n9 = accessor_declarations();
n6.addNode(n9);
        n11 = jj_consume_token(RBRACE);
n10 = JTBToolkit.makeNodeToken(n11);
n6.addNode(n10);
n5 = new NodeChoice(n6, 0);
        break;
        }
      case SEMICOLON:{
        n13 = jj_consume_token(SEMICOLON);
n12 = JTBToolkit.makeNodeToken(n13);
n5 = new NodeChoice(n12, 1);
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n1.addNode(n5);
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:{
n14 = new NodeSequence(3);
        n16 = jj_consume_token(LBRACE);
n15 = JTBToolkit.makeNodeToken(n16);
n14.addNode(n15);
        n17 = accessor_declarations();
n14.addNode(n17);
        n19 = jj_consume_token(RBRACE);
n18 = JTBToolkit.makeNodeToken(n19);
n14.addNode(n18);
n0 = new NodeChoice(n14, 1);
        break;
        }
      case SEMICOLON:{
        n21 = jj_consume_token(SEMICOLON);
n20 = JTBToolkit.makeNodeToken(n21);
n0 = new NodeChoice(n20, 2);
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new field_body(n0);}
    throw new Error("Missing return statement in function");
}

  final public accessor_declarations accessor_declarations() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   accessor_get_declaration n2;
   NodeOptional n3 = new NodeOptional();
   accessor_set_declaration n4;
   NodeSequence n5;
   accessor_set_declaration n6;
   NodeOptional n7 = new NodeOptional();
   accessor_get_declaration n8;

   printDebugInfo("accessor_declarations");
    if (jj_2_9(2)) {
n1 = new NodeSequence(3);
      n2 = accessor_get_declaration();
n1.addNode(n2);
      if (jj_2_7(2)) {
        n4 = accessor_set_declaration();
n3.addNode(n4);
      } else {
        ;
      }
n1.addNode(n3);
n0 = new NodeChoice(n1, 0);
    } else if (jj_2_10(2)) {
n5 = new NodeSequence(3);
      n6 = accessor_set_declaration();
n5.addNode(n6);
      if (jj_2_8(2)) {
        n8 = accessor_get_declaration();
n7.addNode(n8);
      } else {
        ;
      }
n5.addNode(n7);
n0 = new NodeChoice(n5, 1);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new accessor_declarations(n0);}
    throw new Error("Missing return statement in function");
}

  final public accessor_get_declaration accessor_get_declaration() throws ParseException {NodeOptional n0 = new NodeOptional();
   NodeChoice n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;

   printDebugInfo("accessor_get_declaration");
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PRIVATE:
    case PUBLIC:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PRIVATE:{
        n3 = jj_consume_token(PRIVATE);
n2 = JTBToolkit.makeNodeToken(n3);
n1 = new NodeChoice(n2, 0);
        break;
        }
      case PUBLIC:{
        n5 = jj_consume_token(PUBLIC);
n4 = JTBToolkit.makeNodeToken(n5);
n1 = new NodeChoice(n4, 1);
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    n7 = jj_consume_token(GET);
n6 = JTBToolkit.makeNodeToken(n7);
    n9 = jj_consume_token(SEMICOLON);
n8 = JTBToolkit.makeNodeToken(n9);
{if ("" != null) return new accessor_get_declaration(n0,n6,n8);}
    throw new Error("Missing return statement in function");
}

  final public accessor_set_declaration accessor_set_declaration() throws ParseException {NodeOptional n0 = new NodeOptional();
   NodeChoice n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;

   printDebugInfo("accessor_set_declaration");
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PRIVATE:
    case PUBLIC:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PRIVATE:{
        n3 = jj_consume_token(PRIVATE);
n2 = JTBToolkit.makeNodeToken(n3);
n1 = new NodeChoice(n2, 0);
        break;
        }
      case PUBLIC:{
        n5 = jj_consume_token(PUBLIC);
n4 = JTBToolkit.makeNodeToken(n5);
n1 = new NodeChoice(n4, 1);
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    n7 = jj_consume_token(SET);
n6 = JTBToolkit.makeNodeToken(n7);
    n9 = jj_consume_token(SEMICOLON);
n8 = JTBToolkit.makeNodeToken(n9);
{if ("" != null) return new accessor_set_declaration(n0,n6,n8);}
    throw new Error("Missing return statement in function");
}

  final public VariableDeclarator VariableDeclarator() throws ParseException {VariableDeclaratorId n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   VariableInitializer n5;

   printDebugInfo("VariableDeclarator");
    n0 = VariableDeclaratorId();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
n2 = new NodeSequence(2);
      n4 = jj_consume_token(ASSIGN);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = VariableInitializer();
n2.addNode(n5);
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      ;
    }
{if ("" != null) return new VariableDeclarator(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public VariableDeclaratorId VariableDeclaratorId() throws ParseException {NodeToken n0;
   Token n1;
   NodeListOptional n2 = new NodeListOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;

   printDebugInfo("VariableDeclaratorId");
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        ;
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        break label_9;
      }
n3 = new NodeSequence(2);
      n5 = jj_consume_token(LBRACKET);
n4 = JTBToolkit.makeNodeToken(n5);
n3.addNode(n4);
      n7 = jj_consume_token(RBRACKET);
n6 = JTBToolkit.makeNodeToken(n7);
n3.addNode(n6);
n2.addNode(n3);
    }
n2.nodes.trimToSize();
{if ("" != null) return new VariableDeclaratorId(n0,n2);}
    throw new Error("Missing return statement in function");
}

  final public VariableInitializer VariableInitializer() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   VariableInitializer n6;
   NodeListOptional n7;
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   VariableInitializer n11;
   NodeOptional n12 = new NodeOptional();
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   Expression n17;

   printDebugInfo("VariableInit");
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACE:{
n1 = new NodeSequence(4);
      n3 = jj_consume_token(LBRACE);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FALSE:
      case NEW:
      case NULL:
      case SUPER:
      case THIS:
      case TRUE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:{
n7 = new NodeListOptional();
n5 = new NodeSequence(2);
        n6 = VariableInitializer();
n5.addNode(n6);
        label_10:
        while (true) {
          if (jj_2_11(2)) {
            ;
          } else {
            break label_10;
          }
n8 = new NodeSequence(2);
          n10 = jj_consume_token(COMMA);
n9 = JTBToolkit.makeNodeToken(n10);
n8.addNode(n9);
          n11 = VariableInitializer();
n8.addNode(n11);
n7.addNode(n8);
        }
n7.nodes.trimToSize();
n5.addNode(n7);
n4.addNode(n5);
        break;
        }
      default:
        jj_la1[28] = jj_gen;
        ;
      }
n1.addNode(n4);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        n14 = jj_consume_token(COMMA);
n13 = JTBToolkit.makeNodeToken(n14);
n12.addNode(n13);
        break;
        }
      default:
        jj_la1[29] = jj_gen;
        ;
      }
n1.addNode(n12);
      n16 = jj_consume_token(RBRACE);
n15 = JTBToolkit.makeNodeToken(n16);
n1.addNode(n15);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case FALSE:
    case NEW:
    case NULL:
    case SUPER:
    case THIS:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:{
      n17 = Expression();
n0 = new NodeChoice(n17, 1);
      break;
      }
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new VariableInitializer(n0);}
    throw new Error("Missing return statement in function");
}

  final public MethodDeclaration MethodDeclaration() throws ParseException {NodeListOptional n0 = new NodeListOptional();
   NodeChoice n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   NodeToken n12;
   Token n13;
   NodeToken n14;
   Token n15;
   NodeToken n16;
   Token n17;
   ResultType n18;
   MethodDeclarator n19;
   NodeOptional n20 = new NodeOptional();
   NodeSequence n21;
   NodeToken n22;
   Token n23;
   NameList n24;
   NodeChoice n25;
   Block n26;
   NodeToken n27;
   Token n28;

   printDebugInfo("MethodDeclaration");
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case SYNCHRONIZED:{
        ;
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PUBLIC:{
        n3 = jj_consume_token(PUBLIC);
n2 = JTBToolkit.makeNodeToken(n3);
n1 = new NodeChoice(n2, 0);
        break;
        }
      case PROTECTED:{
        n5 = jj_consume_token(PROTECTED);
n4 = JTBToolkit.makeNodeToken(n5);
n1 = new NodeChoice(n4, 1);
        break;
        }
      case PRIVATE:{
        n7 = jj_consume_token(PRIVATE);
n6 = JTBToolkit.makeNodeToken(n7);
n1 = new NodeChoice(n6, 2);
        break;
        }
      case STATIC:{
        n9 = jj_consume_token(STATIC);
n8 = JTBToolkit.makeNodeToken(n9);
n1 = new NodeChoice(n8, 3);
        break;
        }
      case ABSTRACT:{
        n11 = jj_consume_token(ABSTRACT);
n10 = JTBToolkit.makeNodeToken(n11);
n1 = new NodeChoice(n10, 4);
        break;
        }
      case FINAL:{
        n13 = jj_consume_token(FINAL);
n12 = JTBToolkit.makeNodeToken(n13);
n1 = new NodeChoice(n12, 5);
        break;
        }
      case NATIVE:{
        n15 = jj_consume_token(NATIVE);
n14 = JTBToolkit.makeNodeToken(n15);
n1 = new NodeChoice(n14, 6);
        break;
        }
      case SYNCHRONIZED:{
        n17 = jj_consume_token(SYNCHRONIZED);
n16 = JTBToolkit.makeNodeToken(n17);
n1 = new NodeChoice(n16, 7);
        break;
        }
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
    }
n0.nodes.trimToSize();
    n18 = ResultType();
    n19 = MethodDeclarator();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case THROWS:{
n21 = new NodeSequence(2);
      n23 = jj_consume_token(THROWS);
n22 = JTBToolkit.makeNodeToken(n23);
n21.addNode(n22);
      n24 = NameList();
n21.addNode(n24);
n20.addNode(n21);
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACE:{
      n26 = Block();
n25 = new NodeChoice(n26, 0);
      break;
      }
    case SEMICOLON:{
      n28 = jj_consume_token(SEMICOLON);
n27 = JTBToolkit.makeNodeToken(n28);
n25 = new NodeChoice(n27, 1);
      break;
      }
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new MethodDeclaration(n0,n18,n19,n20,n25);}
    throw new Error("Missing return statement in function");
}

  final public MethodDeclarator MethodDeclarator() throws ParseException {NodeToken n0;
   Token n1;
   FormalParameters n2;
   NodeListOptional n3 = new NodeListOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;

   printDebugInfo("MethodDeclarator");
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = FormalParameters();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        ;
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        break label_12;
      }
n4 = new NodeSequence(2);
      n6 = jj_consume_token(LBRACKET);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n8 = jj_consume_token(RBRACKET);
n7 = JTBToolkit.makeNodeToken(n8);
n4.addNode(n7);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
{if ("" != null) return new MethodDeclarator(n0,n2,n3);}
    throw new Error("Missing return statement in function");
}

  final public FormalParameters FormalParameters() throws ParseException {NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   NodeSequence n3;
   FormalParameter n4;
   NodeListOptional n5;
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   FormalParameter n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(LPAREN);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
    case HOOK:{
n5 = new NodeListOptional();
n3 = new NodeSequence(2);
      n4 = FormalParameter();
n3.addNode(n4);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[36] = jj_gen;
          break label_13;
        }
n6 = new NodeSequence(2);
        n8 = jj_consume_token(COMMA);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
        n9 = FormalParameter();
n6.addNode(n9);
n5.addNode(n6);
      }
n5.nodes.trimToSize();
n3.addNode(n5);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    n11 = jj_consume_token(RPAREN);
n10 = JTBToolkit.makeNodeToken(n11);
{if ("" != null) return new FormalParameters(n0,n2,n10);}
    throw new Error("Missing return statement in function");
}

  final public FormalParameter FormalParameter() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   Type n2;
   NodeToken n3;
   Token n4;
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   OptionalParameter n8;
    if (jj_2_12(3)) {
n1 = new NodeSequence(3);
      n2 = Type();
n1.addNode(n2);
      n4 = jj_consume_token(IDENTIFIER);
n3 = JTBToolkit.makeNodeToken(n4);
n1.addNode(n3);
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case HOOK:{
n5 = new NodeSequence(2);
        n7 = jj_consume_token(HOOK);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
        n8 = OptionalParameter();
n5.addNode(n8);
n0 = new NodeChoice(n5, 1);
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new FormalParameter(n0);}
    throw new Error("Missing return statement in function");
}

  final public OptionalParameter OptionalParameter() throws ParseException {Type n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   Expression n5;

   printDebugInfo("OptionalParameter");
    n0 = Type();
    n2 = jj_consume_token(IDENTIFIER);
n1 = JTBToolkit.makeNodeToken(n2);
    n4 = jj_consume_token(ASSIGN);
n3 = JTBToolkit.makeNodeToken(n4);
    n5 = Expression();
{if ("" != null) return new OptionalParameter(n0,n1,n3,n5);}
    throw new Error("Missing return statement in function");
}

  final public DefaultValue DefaultValue() throws ParseException {Literal n0;

   printDebugInfo("Defaultvalue");
    n0 = Literal();
{if ("" != null) return new DefaultValue(n0);}
    throw new Error("Missing return statement in function");
}

  final public ConstructorDeclaration ConstructorDeclaration() throws ParseException {NodeOptional n0 = new NodeOptional();
   NodeChoice n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   FormalParameters n10;
   NodeOptional n11 = new NodeOptional();
   NodeSequence n12;
   NodeToken n13;
   Token n14;
   NameList n15;
   NodeToken n16;
   Token n17;
   NodeOptional n18 = new NodeOptional();
   ExplicitConstructorInvocation n19;
   NodeListOptional n20 = new NodeListOptional();
   BlockStatement n21;
   NodeToken n22;
   Token n23;

   printDebugInfo("ConstructorDeclaration");
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PUBLIC:{
        n3 = jj_consume_token(PUBLIC);
n2 = JTBToolkit.makeNodeToken(n3);
n1 = new NodeChoice(n2, 0);
        break;
        }
      case PROTECTED:{
        n5 = jj_consume_token(PROTECTED);
n4 = JTBToolkit.makeNodeToken(n5);
n1 = new NodeChoice(n4, 1);
        break;
        }
      case PRIVATE:{
        n7 = jj_consume_token(PRIVATE);
n6 = JTBToolkit.makeNodeToken(n7);
n1 = new NodeChoice(n6, 2);
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n0.addNode(n1);
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    n9 = jj_consume_token(IDENTIFIER);
n8 = JTBToolkit.makeNodeToken(n9);
    n10 = FormalParameters();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case THROWS:{
n12 = new NodeSequence(2);
      n14 = jj_consume_token(THROWS);
n13 = JTBToolkit.makeNodeToken(n14);
n12.addNode(n13);
      n15 = NameList();
n12.addNode(n15);
n11.addNode(n12);
      break;
      }
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    n17 = jj_consume_token(LBRACE);
n16 = JTBToolkit.makeNodeToken(n17);
    if (jj_2_13(2)) {
      n19 = ExplicitConstructorInvocation();
n18.addNode(n19);
    } else {
      ;
    }
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:{
        ;
        break;
        }
      default:
        jj_la1[42] = jj_gen;
        break label_14;
      }
      n21 = BlockStatement();
n20.addNode(n21);
    }
n20.nodes.trimToSize();
    n23 = jj_consume_token(RBRACE);
n22 = JTBToolkit.makeNodeToken(n23);
{if ("" != null) return new ConstructorDeclaration(n0,n8,n10,n11,n16,n18,n20,n22);}
    throw new Error("Missing return statement in function");
}

  final public ExplicitConstructorInvocation ExplicitConstructorInvocation() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   Arguments n4;
   NodeToken n5;
   Token n6;
   NodeSequence n7;
   NodeToken n8;
   Token n9;
   Arguments n10;
   NodeToken n11;
   Token n12;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case THIS:{
n1 = new NodeSequence(3);
      n3 = jj_consume_token(THIS);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = Arguments();
n1.addNode(n4);
      n6 = jj_consume_token(SEMICOLON);
n5 = JTBToolkit.makeNodeToken(n6);
n1.addNode(n5);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case SUPER:{
n7 = new NodeSequence(3);
      n9 = jj_consume_token(SUPER);
n8 = JTBToolkit.makeNodeToken(n9);
n7.addNode(n8);
      n10 = Arguments();
n7.addNode(n10);
      n12 = jj_consume_token(SEMICOLON);
n11 = JTBToolkit.makeNodeToken(n12);
n7.addNode(n11);
n0 = new NodeChoice(n7, 1);
      break;
      }
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new ExplicitConstructorInvocation(n0);}
    throw new Error("Missing return statement in function");
}

  final public StaticInitializer StaticInitializer() throws ParseException {NodeToken n0;
   Token n1;
   Block n2;
    n1 = jj_consume_token(STATIC);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Block();
{if ("" != null) return new StaticInitializer(n0,n2);}
    throw new Error("Missing return statement in function");
}

  final public Type Type() throws ParseException {NodeChoice n0;
   PrimitiveType n1;
   Name n2;
   NodeListOptional n3 = new NodeListOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:{
      n1 = PrimitiveType();
n0 = new NodeChoice(n1, 0);
      break;
      }
    case IDENTIFIER:{
      n2 = Name();
n0 = new NodeChoice(n2, 1);
      break;
      }
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        ;
        break;
        }
      default:
        jj_la1[45] = jj_gen;
        break label_15;
      }
n4 = new NodeSequence(2);
      n6 = jj_consume_token(LBRACKET);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n8 = jj_consume_token(RBRACKET);
n7 = JTBToolkit.makeNodeToken(n8);
n4.addNode(n7);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
{if ("" != null) return new Type(n0,n3);}
    throw new Error("Missing return statement in function");
}

  final public PrimitiveType PrimitiveType() throws ParseException {NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:{
      n2 = jj_consume_token(BOOLEAN);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case CHAR:{
      n4 = jj_consume_token(CHAR);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1);
      break;
      }
    case BYTE:{
      n6 = jj_consume_token(BYTE);
n5 = JTBToolkit.makeNodeToken(n6);
n0 = new NodeChoice(n5, 2);
      break;
      }
    case SHORT:{
      n8 = jj_consume_token(SHORT);
n7 = JTBToolkit.makeNodeToken(n8);
n0 = new NodeChoice(n7, 3);
      break;
      }
    case INT:{
      n10 = jj_consume_token(INT);
n9 = JTBToolkit.makeNodeToken(n10);
n0 = new NodeChoice(n9, 4);
      break;
      }
    case LONG:{
      n12 = jj_consume_token(LONG);
n11 = JTBToolkit.makeNodeToken(n12);
n0 = new NodeChoice(n11, 5);
      break;
      }
    case FLOAT:{
      n14 = jj_consume_token(FLOAT);
n13 = JTBToolkit.makeNodeToken(n14);
n0 = new NodeChoice(n13, 6);
      break;
      }
    case DOUBLE:{
      n16 = jj_consume_token(DOUBLE);
n15 = JTBToolkit.makeNodeToken(n16);
n0 = new NodeChoice(n15, 7);
      break;
      }
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new PrimitiveType(n0);}
    throw new Error("Missing return statement in function");
}

  final public ResultType ResultType() throws ParseException {NodeChoice n0;
   NodeToken n1;
   Token n2;
   Type n3;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VOID:{
      n2 = jj_consume_token(VOID);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:{
      n3 = Type();
n0 = new NodeChoice(n3, 1);
      break;
      }
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new ResultType(n0);}
    throw new Error("Missing return statement in function");
}

  final public Name Name() throws ParseException {NodeToken n0;
   Token n1;
   NodeListOptional n2 = new NodeListOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    label_16:
    while (true) {
      if (jj_2_14(2)) {
        ;
      } else {
        break label_16;
      }
n3 = new NodeSequence(2);
      n5 = jj_consume_token(DOT);
n4 = JTBToolkit.makeNodeToken(n5);
n3.addNode(n4);
      n7 = jj_consume_token(IDENTIFIER);
n6 = JTBToolkit.makeNodeToken(n7);
n3.addNode(n6);
n2.addNode(n3);
    }
n2.nodes.trimToSize();
{if ("" != null) return new Name(n0,n2);}
    throw new Error("Missing return statement in function");
}

  final public NameList NameList() throws ParseException {Name n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Name n5;
    n0 = Name();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        break label_17;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = Name();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new NameList(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public Expression Expression() throws ParseException {NodeChoice n0;
   Assignment n1;
   ConditionalExpression n2;

   printDebugInfo("Expression");
    if (jj_2_15(2147483647)) {
      n1 = Assignment();
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FALSE:
      case NEW:
      case NULL:
      case SUPER:
      case THIS:
      case TRUE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:{
        n2 = ConditionalExpression();
n0 = new NodeChoice(n2, 1);
        break;
        }
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new Expression(n0);}
    throw new Error("Missing return statement in function");
}

  final public Assignment Assignment() throws ParseException {PrimaryExpression n0;
   AssignmentOperator n1;
   Expression n2;

   printDebugInfo("Assignment");
    n0 = PrimaryExpression();
    n1 = AssignmentOperator();
    n2 = Expression();
{if ("" != null) return new Assignment(n0,n1,n2);}
    throw new Error("Missing return statement in function");
}

  final public AssignmentOperator AssignmentOperator() throws ParseException {NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
   NodeToken n23;
   Token n24;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
      n2 = jj_consume_token(ASSIGN);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case STARASSIGN:{
      n4 = jj_consume_token(STARASSIGN);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1);
      break;
      }
    case SLASHASSIGN:{
      n6 = jj_consume_token(SLASHASSIGN);
n5 = JTBToolkit.makeNodeToken(n6);
n0 = new NodeChoice(n5, 2);
      break;
      }
    case REMASSIGN:{
      n8 = jj_consume_token(REMASSIGN);
n7 = JTBToolkit.makeNodeToken(n8);
n0 = new NodeChoice(n7, 3);
      break;
      }
    case PLUSASSIGN:{
      n10 = jj_consume_token(PLUSASSIGN);
n9 = JTBToolkit.makeNodeToken(n10);
n0 = new NodeChoice(n9, 4);
      break;
      }
    case MINUSASSIGN:{
      n12 = jj_consume_token(MINUSASSIGN);
n11 = JTBToolkit.makeNodeToken(n12);
n0 = new NodeChoice(n11, 5);
      break;
      }
    case LSHIFTASSIGN:{
      n14 = jj_consume_token(LSHIFTASSIGN);
n13 = JTBToolkit.makeNodeToken(n14);
n0 = new NodeChoice(n13, 6);
      break;
      }
    case RSIGNEDSHIFTASSIGN:{
      n16 = jj_consume_token(RSIGNEDSHIFTASSIGN);
n15 = JTBToolkit.makeNodeToken(n16);
n0 = new NodeChoice(n15, 7);
      break;
      }
    case RUNSIGNEDSHIFTASSIGN:{
      n18 = jj_consume_token(RUNSIGNEDSHIFTASSIGN);
n17 = JTBToolkit.makeNodeToken(n18);
n0 = new NodeChoice(n17, 8);
      break;
      }
    case ANDASSIGN:{
      n20 = jj_consume_token(ANDASSIGN);
n19 = JTBToolkit.makeNodeToken(n20);
n0 = new NodeChoice(n19, 9);
      break;
      }
    case XORASSIGN:{
      n22 = jj_consume_token(XORASSIGN);
n21 = JTBToolkit.makeNodeToken(n22);
n0 = new NodeChoice(n21, 10);
      break;
      }
    case ORASSIGN:{
      n24 = jj_consume_token(ORASSIGN);
n23 = JTBToolkit.makeNodeToken(n24);
n0 = new NodeChoice(n23, 11);
      break;
      }
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new AssignmentOperator(n0);}
    throw new Error("Missing return statement in function");
}

  final public ConditionalExpression ConditionalExpression() throws ParseException {ConditionalOrExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Expression n5;
   NodeToken n6;
   Token n7;
   ConditionalExpression n8;

   printDebugInfo("ConditionalExpression");
    n0 = ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case HOOK:{
n2 = new NodeSequence(4);
      n4 = jj_consume_token(HOOK);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = Expression();
n2.addNode(n5);
      n7 = jj_consume_token(COLON);
n6 = JTBToolkit.makeNodeToken(n7);
n2.addNode(n6);
      n8 = ConditionalExpression();
n2.addNode(n8);
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      ;
    }
{if ("" != null) return new ConditionalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public ConditionalOrExpression ConditionalOrExpression() throws ParseException {ConditionalAndExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ConditionalAndExpression n5;
    n0 = ConditionalAndExpression();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SC_OR:{
        ;
        break;
        }
      default:
        jj_la1[52] = jj_gen;
        break label_18;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(SC_OR);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = ConditionalAndExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ConditionalOrExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public ConditionalAndExpression ConditionalAndExpression() throws ParseException {InclusiveOrExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   InclusiveOrExpression n5;
    n0 = InclusiveOrExpression();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SC_AND:{
        ;
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        break label_19;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(SC_AND);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = InclusiveOrExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ConditionalAndExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public InclusiveOrExpression InclusiveOrExpression() throws ParseException {ExclusiveOrExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ExclusiveOrExpression n5;
    n0 = ExclusiveOrExpression();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_OR:{
        ;
        break;
        }
      default:
        jj_la1[54] = jj_gen;
        break label_20;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(BIT_OR);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = ExclusiveOrExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new InclusiveOrExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public ExclusiveOrExpression ExclusiveOrExpression() throws ParseException {AndExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   AndExpression n5;
    n0 = AndExpression();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case XOR:{
        ;
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        break label_21;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(XOR);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = AndExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ExclusiveOrExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public AndExpression AndExpression() throws ParseException {EqualityExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   EqualityExpression n5;
    n0 = EqualityExpression();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_AND:{
        ;
        break;
        }
      default:
        jj_la1[56] = jj_gen;
        break label_22;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(BIT_AND);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = EqualityExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new AndExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public EqualityExpression EqualityExpression() throws ParseException {InstanceOfExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   InstanceOfExpression n8;
    n0 = InstanceOfExpression();
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQ:
      case NE:{
        ;
        break;
        }
      default:
        jj_la1[57] = jj_gen;
        break label_23;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQ:{
        n5 = jj_consume_token(EQ);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0);
        break;
        }
      case NE:{
        n7 = jj_consume_token(NE);
n6 = JTBToolkit.makeNodeToken(n7);
n3 = new NodeChoice(n6, 1);
        break;
        }
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n2.addNode(n3);
      n8 = InstanceOfExpression();
n2.addNode(n8);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new EqualityExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public InstanceOfExpression InstanceOfExpression() throws ParseException {RelationalExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Type n5;
    n0 = RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INSTANCEOF:{
n2 = new NodeSequence(2);
      n4 = jj_consume_token(INSTANCEOF);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = Type();
n2.addNode(n5);
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[59] = jj_gen;
      ;
    }
{if ("" != null) return new InstanceOfExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public RelationalExpression RelationalExpression() throws ParseException {ShiftExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   ShiftExpression n12;
    n0 = ShiftExpression();
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case GT:
      case LT:
      case LE:
      case GE:{
        ;
        break;
        }
      default:
        jj_la1[60] = jj_gen;
        break label_24;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:{
        n5 = jj_consume_token(LT);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0);
        break;
        }
      case GT:{
        n7 = jj_consume_token(GT);
n6 = JTBToolkit.makeNodeToken(n7);
n3 = new NodeChoice(n6, 1);
        break;
        }
      case LE:{
        n9 = jj_consume_token(LE);
n8 = JTBToolkit.makeNodeToken(n9);
n3 = new NodeChoice(n8, 2);
        break;
        }
      case GE:{
        n11 = jj_consume_token(GE);
n10 = JTBToolkit.makeNodeToken(n11);
n3 = new NodeChoice(n10, 3);
        break;
        }
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n2.addNode(n3);
      n12 = ShiftExpression();
n2.addNode(n12);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new RelationalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public ShiftExpression ShiftExpression() throws ParseException {AdditiveExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   AdditiveExpression n10;
    n0 = AdditiveExpression();
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LSHIFT:
      case RSIGNEDSHIFT:
      case RUNSIGNEDSHIFT:{
        ;
        break;
        }
      default:
        jj_la1[62] = jj_gen;
        break label_25;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LSHIFT:{
        n5 = jj_consume_token(LSHIFT);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0);
        break;
        }
      case RSIGNEDSHIFT:{
        n7 = jj_consume_token(RSIGNEDSHIFT);
n6 = JTBToolkit.makeNodeToken(n7);
n3 = new NodeChoice(n6, 1);
        break;
        }
      case RUNSIGNEDSHIFT:{
        n9 = jj_consume_token(RUNSIGNEDSHIFT);
n8 = JTBToolkit.makeNodeToken(n9);
n3 = new NodeChoice(n8, 2);
        break;
        }
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n2.addNode(n3);
      n10 = AdditiveExpression();
n2.addNode(n10);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ShiftExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public AdditiveExpression AdditiveExpression() throws ParseException {MultiplicativeExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   MultiplicativeExpression n8;
    n0 = MultiplicativeExpression();
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        ;
        break;
        }
      default:
        jj_la1[64] = jj_gen;
        break label_26;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        n5 = jj_consume_token(PLUS);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0);
        break;
        }
      case MINUS:{
        n7 = jj_consume_token(MINUS);
n6 = JTBToolkit.makeNodeToken(n7);
n3 = new NodeChoice(n6, 1);
        break;
        }
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n2.addNode(n3);
      n8 = MultiplicativeExpression();
n2.addNode(n8);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new AdditiveExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {UnaryExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   UnaryExpression n10;
    n0 = UnaryExpression();
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STAR:
      case SLASH:
      case REM:{
        ;
        break;
        }
      default:
        jj_la1[66] = jj_gen;
        break label_27;
      }
n2 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STAR:{
        n5 = jj_consume_token(STAR);
n4 = JTBToolkit.makeNodeToken(n5);
n3 = new NodeChoice(n4, 0);
        break;
        }
      case SLASH:{
        n7 = jj_consume_token(SLASH);
n6 = JTBToolkit.makeNodeToken(n7);
n3 = new NodeChoice(n6, 1);
        break;
        }
      case REM:{
        n9 = jj_consume_token(REM);
n8 = JTBToolkit.makeNodeToken(n9);
n3 = new NodeChoice(n8, 2);
        break;
        }
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n2.addNode(n3);
      n10 = UnaryExpression();
n2.addNode(n10);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new MultiplicativeExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public UnaryExpression UnaryExpression() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeChoice n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   UnaryExpression n7;
   PreIncrementExpression n8;
   PreDecrementExpression n9;
   UnaryExpressionNotPlusMinus n10;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PLUS:
    case MINUS:{
n1 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        n4 = jj_consume_token(PLUS);
n3 = JTBToolkit.makeNodeToken(n4);
n2 = new NodeChoice(n3, 0);
        break;
        }
      case MINUS:{
        n6 = jj_consume_token(MINUS);
n5 = JTBToolkit.makeNodeToken(n6);
n2 = new NodeChoice(n5, 1);
        break;
        }
      default:
        jj_la1[68] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n1.addNode(n2);
      n7 = UnaryExpression();
n1.addNode(n7);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case INCR:{
      n8 = PreIncrementExpression();
n0 = new NodeChoice(n8, 1);
      break;
      }
    case DECR:{
      n9 = PreDecrementExpression();
n0 = new NodeChoice(n9, 2);
      break;
      }
    case FALSE:
    case NEW:
    case NULL:
    case SUPER:
    case THIS:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:{
      n10 = UnaryExpressionNotPlusMinus();
n0 = new NodeChoice(n10, 3);
      break;
      }
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new UnaryExpression(n0);}
    throw new Error("Missing return statement in function");
}

  final public PreIncrementExpression PreIncrementExpression() throws ParseException {NodeToken n0;
   Token n1;
   PrimaryExpression n2;
    n1 = jj_consume_token(INCR);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = PrimaryExpression();
{if ("" != null) return new PreIncrementExpression(n0,n2);}
    throw new Error("Missing return statement in function");
}

  final public PreDecrementExpression PreDecrementExpression() throws ParseException {NodeToken n0;
   Token n1;
   PrimaryExpression n2;
    n1 = jj_consume_token(DECR);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = PrimaryExpression();
{if ("" != null) return new PreDecrementExpression(n0,n2);}
    throw new Error("Missing return statement in function");
}

  final public UnaryExpressionNotPlusMinus UnaryExpressionNotPlusMinus() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeChoice n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   UnaryExpression n7;
   CastExpression n8;
   PostfixExpression n9;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BANG:
    case TILDE:{
n1 = new NodeSequence(2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TILDE:{
        n4 = jj_consume_token(TILDE);
n3 = JTBToolkit.makeNodeToken(n4);
n2 = new NodeChoice(n3, 0);
        break;
        }
      case BANG:{
        n6 = jj_consume_token(BANG);
n5 = JTBToolkit.makeNodeToken(n6);
n2 = new NodeChoice(n5, 1);
        break;
        }
      default:
        jj_la1[70] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n1.addNode(n2);
      n7 = UnaryExpression();
n1.addNode(n7);
n0 = new NodeChoice(n1, 0);
      break;
      }
    default:
      jj_la1[71] = jj_gen;
      if (jj_2_16(2147483647)) {
        n8 = CastExpression();
n0 = new NodeChoice(n8, 1);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FALSE:
        case NEW:
        case NULL:
        case SUPER:
        case THIS:
        case TRUE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:{
          n9 = PostfixExpression();
n0 = new NodeChoice(n9, 2);
          break;
          }
        default:
          jj_la1[72] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return new UnaryExpressionNotPlusMinus(n0);}
    throw new Error("Missing return statement in function");
}

  final public CastLookahead CastLookahead() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   PrimitiveType n4;
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   Name n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeSequence n13;
   NodeToken n14;
   Token n15;
   Name n16;
   NodeToken n17;
   Token n18;
   NodeChoice n19;
   NodeToken n20;
   Token n21;
   NodeToken n22;
   Token n23;
   NodeToken n24;
   Token n25;
   NodeToken n26;
   Token n27;
   NodeToken n28;
   Token n29;
   NodeToken n30;
   Token n31;
   NodeToken n32;
   Token n33;
   Literal n34;
    if (jj_2_17(2)) {
n1 = new NodeSequence(3);
      n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = PrimitiveType();
n1.addNode(n4);
n0 = new NodeChoice(n1, 0);
    } else if (jj_2_18(2147483647)) {
n5 = new NodeSequence(5);
      n7 = jj_consume_token(LPAREN);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
      n8 = Name();
n5.addNode(n8);
      n10 = jj_consume_token(LBRACKET);
n9 = JTBToolkit.makeNodeToken(n10);
n5.addNode(n9);
      n12 = jj_consume_token(RBRACKET);
n11 = JTBToolkit.makeNodeToken(n12);
n5.addNode(n11);
n0 = new NodeChoice(n5, 1);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
n13 = new NodeSequence(4);
        n15 = jj_consume_token(LPAREN);
n14 = JTBToolkit.makeNodeToken(n15);
n13.addNode(n14);
        n16 = Name();
n13.addNode(n16);
        n18 = jj_consume_token(RPAREN);
n17 = JTBToolkit.makeNodeToken(n18);
n13.addNode(n17);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case TILDE:{
          n21 = jj_consume_token(TILDE);
n20 = JTBToolkit.makeNodeToken(n21);
n19 = new NodeChoice(n20, 0);
          break;
          }
        case BANG:{
          n23 = jj_consume_token(BANG);
n22 = JTBToolkit.makeNodeToken(n23);
n19 = new NodeChoice(n22, 1);
          break;
          }
        case LPAREN:{
          n25 = jj_consume_token(LPAREN);
n24 = JTBToolkit.makeNodeToken(n25);
n19 = new NodeChoice(n24, 2);
          break;
          }
        case IDENTIFIER:{
          n27 = jj_consume_token(IDENTIFIER);
n26 = JTBToolkit.makeNodeToken(n27);
n19 = new NodeChoice(n26, 3);
          break;
          }
        case THIS:{
          n29 = jj_consume_token(THIS);
n28 = JTBToolkit.makeNodeToken(n29);
n19 = new NodeChoice(n28, 4);
          break;
          }
        case SUPER:{
          n31 = jj_consume_token(SUPER);
n30 = JTBToolkit.makeNodeToken(n31);
n19 = new NodeChoice(n30, 5);
          break;
          }
        case NEW:{
          n33 = jj_consume_token(NEW);
n32 = JTBToolkit.makeNodeToken(n33);
n19 = new NodeChoice(n32, 6);
          break;
          }
        case FALSE:
        case NULL:
        case TRUE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:{
          n34 = Literal();
n19 = new NodeChoice(n34, 7);
          break;
          }
        default:
          jj_la1[73] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
n13.addNode(n19);
n0 = new NodeChoice(n13, 2);
        break;
        }
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new CastLookahead(n0);}
    throw new Error("Missing return statement in function");
}

  final public PostfixExpression PostfixExpression() throws ParseException {PrimaryExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeChoice n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
    n0 = PrimaryExpression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INCR:
    case DECR:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INCR:{
        n4 = jj_consume_token(INCR);
n3 = JTBToolkit.makeNodeToken(n4);
n2 = new NodeChoice(n3, 0);
        break;
        }
      case DECR:{
        n6 = jj_consume_token(DECR);
n5 = JTBToolkit.makeNodeToken(n6);
n2 = new NodeChoice(n5, 1);
        break;
        }
      default:
        jj_la1[75] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n1.addNode(n2);
      break;
      }
    default:
      jj_la1[76] = jj_gen;
      ;
    }
{if ("" != null) return new PostfixExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public CastExpression CastExpression() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   PrimitiveType n4;
   NodeListOptional n5 = new NodeListOptional();
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   UnaryExpression n13;
   NodeSequence n14;
   NodeToken n15;
   Token n16;
   Name n17;
   NodeListOptional n18 = new NodeListOptional();
   NodeSequence n19;
   NodeToken n20;
   Token n21;
   NodeToken n22;
   Token n23;
   NodeToken n24;
   Token n25;
   UnaryExpressionNotPlusMinus n26;
    if (jj_2_19(2)) {
n1 = new NodeSequence(6);
      n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = PrimitiveType();
n1.addNode(n4);
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LBRACKET:{
          ;
          break;
          }
        default:
          jj_la1[77] = jj_gen;
          break label_28;
        }
n6 = new NodeSequence(2);
        n8 = jj_consume_token(LBRACKET);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
        n10 = jj_consume_token(RBRACKET);
n9 = JTBToolkit.makeNodeToken(n10);
n6.addNode(n9);
n5.addNode(n6);
      }
n5.nodes.trimToSize();
n1.addNode(n5);
      n12 = jj_consume_token(RPAREN);
n11 = JTBToolkit.makeNodeToken(n12);
n1.addNode(n11);
      n13 = UnaryExpression();
n1.addNode(n13);
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
n14 = new NodeSequence(5);
        n16 = jj_consume_token(LPAREN);
n15 = JTBToolkit.makeNodeToken(n16);
n14.addNode(n15);
        n17 = Name();
n14.addNode(n17);
        label_29:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACKET:{
            ;
            break;
            }
          default:
            jj_la1[78] = jj_gen;
            break label_29;
          }
n19 = new NodeSequence(2);
          n21 = jj_consume_token(LBRACKET);
n20 = JTBToolkit.makeNodeToken(n21);
n19.addNode(n20);
          n23 = jj_consume_token(RBRACKET);
n22 = JTBToolkit.makeNodeToken(n23);
n19.addNode(n22);
n18.addNode(n19);
        }
n18.nodes.trimToSize();
n14.addNode(n18);
        n25 = jj_consume_token(RPAREN);
n24 = JTBToolkit.makeNodeToken(n25);
n14.addNode(n24);
        n26 = UnaryExpressionNotPlusMinus();
n14.addNode(n26);
n0 = new NodeChoice(n14, 1);
        break;
        }
      default:
        jj_la1[79] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new CastExpression(n0);}
    throw new Error("Missing return statement in function");
}

  final public PrimaryExpression PrimaryExpression() throws ParseException {PrimaryPrefix n0;
   NodeListOptional n1 = new NodeListOptional();
   PrimarySuffix n2;
    n0 = PrimaryPrefix();
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:
      case LBRACKET:
      case DOT:{
        ;
        break;
        }
      default:
        jj_la1[80] = jj_gen;
        break label_30;
      }
      n2 = PrimarySuffix();
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new PrimaryExpression(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public PrimaryPrefix PrimaryPrefix() throws ParseException {NodeChoice n0;
   Literal n1;
   Name n2;
   NodeToken n3;
   Token n4;
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   NodeSequence n12;
   NodeToken n13;
   Token n14;
   Expression n15;
   NodeToken n16;
   Token n17;
   AllocationExpression n18;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:{
      n1 = Literal();
n0 = new NodeChoice(n1, 0);
      break;
      }
    case IDENTIFIER:{
      n2 = Name();
n0 = new NodeChoice(n2, 1);
      break;
      }
    case THIS:{
      n4 = jj_consume_token(THIS);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 2);
      break;
      }
    case SUPER:{
n5 = new NodeSequence(3);
      n7 = jj_consume_token(SUPER);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
      n9 = jj_consume_token(DOT);
n8 = JTBToolkit.makeNodeToken(n9);
n5.addNode(n8);
      n11 = jj_consume_token(IDENTIFIER);
n10 = JTBToolkit.makeNodeToken(n11);
n5.addNode(n10);
n0 = new NodeChoice(n5, 3);
      break;
      }
    case LPAREN:{
n12 = new NodeSequence(3);
      n14 = jj_consume_token(LPAREN);
n13 = JTBToolkit.makeNodeToken(n14);
n12.addNode(n13);
      n15 = Expression();
n12.addNode(n15);
      n17 = jj_consume_token(RPAREN);
n16 = JTBToolkit.makeNodeToken(n17);
n12.addNode(n16);
n0 = new NodeChoice(n12, 4);
      break;
      }
    case NEW:{
      n18 = AllocationExpression();
n0 = new NodeChoice(n18, 5);
      break;
      }
    default:
      jj_la1[81] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new PrimaryPrefix(n0);}
    throw new Error("Missing return statement in function");
}

  final public PrimarySuffix PrimarySuffix() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   NodeSequence n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   Arguments n12;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACKET:{
n1 = new NodeSequence(3);
      n3 = jj_consume_token(LBRACKET);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = Expression();
n1.addNode(n4);
      n6 = jj_consume_token(RBRACKET);
n5 = JTBToolkit.makeNodeToken(n6);
n1.addNode(n5);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case DOT:{
n7 = new NodeSequence(2);
      n9 = jj_consume_token(DOT);
n8 = JTBToolkit.makeNodeToken(n9);
n7.addNode(n8);
      n11 = jj_consume_token(IDENTIFIER);
n10 = JTBToolkit.makeNodeToken(n11);
n7.addNode(n10);
n0 = new NodeChoice(n7, 1);
      break;
      }
    case LPAREN:{
      n12 = Arguments();
n0 = new NodeChoice(n12, 2);
      break;
      }
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new PrimarySuffix(n0);}
    throw new Error("Missing return statement in function");
}

  final public Literal Literal() throws ParseException {NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   BooleanLiteral n9;
   NullLiteral n10;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:{
      n2 = jj_consume_token(INTEGER_LITERAL);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case FLOATING_POINT_LITERAL:{
      n4 = jj_consume_token(FLOATING_POINT_LITERAL);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1);
      break;
      }
    case CHARACTER_LITERAL:{
      n6 = jj_consume_token(CHARACTER_LITERAL);
n5 = JTBToolkit.makeNodeToken(n6);
n0 = new NodeChoice(n5, 2);
      break;
      }
    case STRING_LITERAL:{
      n8 = jj_consume_token(STRING_LITERAL);
n7 = JTBToolkit.makeNodeToken(n8);
n0 = new NodeChoice(n7, 3);
      break;
      }
    case FALSE:
    case TRUE:{
      n9 = BooleanLiteral();
n0 = new NodeChoice(n9, 4);
      break;
      }
    case NULL:{
      n10 = NullLiteral();
n0 = new NodeChoice(n10, 5);
      break;
      }
    default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new Literal(n0);}
    throw new Error("Missing return statement in function");
}

  final public BooleanLiteral BooleanLiteral() throws ParseException {NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:{
      n2 = jj_consume_token(TRUE);
n1 = JTBToolkit.makeNodeToken(n2);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case FALSE:{
      n4 = jj_consume_token(FALSE);
n3 = JTBToolkit.makeNodeToken(n4);
n0 = new NodeChoice(n3, 1);
      break;
      }
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new BooleanLiteral(n0);}
    throw new Error("Missing return statement in function");
}

  final public NullLiteral NullLiteral() throws ParseException {NodeToken n0;
   Token n1;
    n1 = jj_consume_token(NULL);
n0 = JTBToolkit.makeNodeToken(n1);
{if ("" != null) return new NullLiteral(n0);}
    throw new Error("Missing return statement in function");
}

  final public Arguments Arguments() throws ParseException {NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   ArgumentList n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(LPAREN);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FALSE:
    case NEW:
    case NULL:
    case SUPER:
    case THIS:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:{
      n3 = ArgumentList();
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[85] = jj_gen;
      ;
    }
    n5 = jj_consume_token(RPAREN);
n4 = JTBToolkit.makeNodeToken(n5);
{if ("" != null) return new Arguments(n0,n2,n4);}
    throw new Error("Missing return statement in function");
}

  final public ArgumentList ArgumentList() throws ParseException {Expression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Expression n5;
    n0 = Expression();
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[86] = jj_gen;
        break label_31;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = Expression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new ArgumentList(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public AllocationExpression AllocationExpression() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   PrimitiveType n4;
   ArrayDimensions n5;
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   Name n9;
   NodeChoice n10;
   Arguments n11;
   ArrayDimensions n12;
    if (jj_2_20(2)) {
n1 = new NodeSequence(4);
      n3 = jj_consume_token(NEW);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = PrimitiveType();
n1.addNode(n4);
      n5 = ArrayDimensions();
n1.addNode(n5);
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NEW:{
n6 = new NodeSequence(3);
        n8 = jj_consume_token(NEW);
n7 = JTBToolkit.makeNodeToken(n8);
n6.addNode(n7);
        n9 = Name();
n6.addNode(n9);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          n11 = Arguments();
n10 = new NodeChoice(n11, 0);
          break;
          }
        case LBRACKET:{
          n12 = ArrayDimensions();
n10 = new NodeChoice(n12, 1);
          break;
          }
        default:
          jj_la1[87] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
n6.addNode(n10);
n0 = new NodeChoice(n6, 1);
        break;
        }
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new AllocationExpression(n0);}
    throw new Error("Missing return statement in function");
}

  final public ArrayDimensions ArrayDimensions() throws ParseException {NodeList n0 = new NodeList();
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   NodeListOptional n7 = new NodeListOptional();
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
    label_32:
    while (true) {
n1 = new NodeSequence(3);
      n3 = jj_consume_token(LBRACKET);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = Expression();
n1.addNode(n4);
      n6 = jj_consume_token(RBRACKET);
n5 = JTBToolkit.makeNodeToken(n6);
n1.addNode(n5);
n0.addNode(n1);
      if (jj_2_21(2)) {
        ;
      } else {
        break label_32;
      }
    }
n0.nodes.trimToSize();
    label_33:
    while (true) {
      if (jj_2_22(2)) {
        ;
      } else {
        break label_33;
      }
n8 = new NodeSequence(2);
      n10 = jj_consume_token(LBRACKET);
n9 = JTBToolkit.makeNodeToken(n10);
n8.addNode(n9);
      n12 = jj_consume_token(RBRACKET);
n11 = JTBToolkit.makeNodeToken(n12);
n8.addNode(n11);
n7.addNode(n8);
    }
n7.nodes.trimToSize();
{if ("" != null) return new ArrayDimensions(n0,n7);}
    throw new Error("Missing return statement in function");
}

  final public Statement Statement() throws ParseException {NodeChoice n0;
   LabeledStatement n1;
   Block n2;
   EmptyStatement n3;
   NodeSequence n4;
   StatementExpression n5;
   NodeToken n6;
   Token n7;
   SwitchStatement n8;
   IfStatement n9;
   WhileStatement n10;
   DoStatement n11;
   ForStatement n12;
   BreakStatement n13;
   ContinueStatement n14;
   ReturnStatement n15;
   ThrowStatement n16;
   SynchronizedStatement n17;
   TryStatement n18;
    if (jj_2_23(2)) {
      n1 = LabeledStatement();
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:{
        n2 = Block();
n0 = new NodeChoice(n2, 1);
        break;
        }
      case SEMICOLON:{
        n3 = EmptyStatement();
n0 = new NodeChoice(n3, 2);
        break;
        }
      case FALSE:
      case NEW:
      case NULL:
      case SUPER:
      case THIS:
      case TRUE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case INCR:
      case DECR:{
n4 = new NodeSequence(2);
        n5 = StatementExpression();
n4.addNode(n5);
        n7 = jj_consume_token(SEMICOLON);
n6 = JTBToolkit.makeNodeToken(n7);
n4.addNode(n6);
n0 = new NodeChoice(n4, 3);
        break;
        }
      case SWITCH:{
        n8 = SwitchStatement();
n0 = new NodeChoice(n8, 4);
        break;
        }
      case IF:{
        n9 = IfStatement();
n0 = new NodeChoice(n9, 5);
        break;
        }
      case WHILE:{
        n10 = WhileStatement();
n0 = new NodeChoice(n10, 6);
        break;
        }
      case DO:{
        n11 = DoStatement();
n0 = new NodeChoice(n11, 7);
        break;
        }
      case FOR:{
        n12 = ForStatement();
n0 = new NodeChoice(n12, 8);
        break;
        }
      case BREAK:{
        n13 = BreakStatement();
n0 = new NodeChoice(n13, 9);
        break;
        }
      case CONTINUE:{
        n14 = ContinueStatement();
n0 = new NodeChoice(n14, 10);
        break;
        }
      case RETURN:{
        n15 = ReturnStatement();
n0 = new NodeChoice(n15, 11);
        break;
        }
      case THROW:{
        n16 = ThrowStatement();
n0 = new NodeChoice(n16, 12);
        break;
        }
      case SYNCHRONIZED:{
        n17 = SynchronizedStatement();
n0 = new NodeChoice(n17, 13);
        break;
        }
      case TRY:{
        n18 = TryStatement();
n0 = new NodeChoice(n18, 14);
        break;
        }
      default:
        jj_la1[89] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new Statement(n0);}
    throw new Error("Missing return statement in function");
}

  final public LabeledStatement LabeledStatement() throws ParseException {NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Statement n4;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(COLON);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Statement();
{if ("" != null) return new LabeledStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
}

  final public Block Block() throws ParseException {NodeToken n0;
   Token n1;
   NodeListOptional n2 = new NodeListOptional();
   BlockStatement n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(LBRACE);
n0 = JTBToolkit.makeNodeToken(n1);
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:{
        ;
        break;
        }
      default:
        jj_la1[90] = jj_gen;
        break label_34;
      }
      n3 = BlockStatement();
n2.addNode(n3);
    }
n2.nodes.trimToSize();
    n5 = jj_consume_token(RBRACE);
n4 = JTBToolkit.makeNodeToken(n5);
{if ("" != null) return new Block(n0,n2,n4);}
    throw new Error("Missing return statement in function");
}

  final public BlockStatement BlockStatement() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   LocalVariableDeclaration n2;
   NodeToken n3;
   Token n4;
   Statement n5;
    if (jj_2_24(2147483647)) {
n1 = new NodeSequence(3);
      n2 = LocalVariableDeclaration();
n1.addNode(n2);
      n4 = jj_consume_token(SEMICOLON);
n3 = JTBToolkit.makeNodeToken(n4);
n1.addNode(n3);
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BREAK:
      case CONTINUE:
      case DO:
      case FALSE:
      case FOR:
      case IF:
      case NEW:
      case NULL:
      case RETURN:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:{
        n5 = Statement();
n0 = new NodeChoice(n5, 1);
        break;
        }
      default:
        jj_la1[91] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new BlockStatement(n0);}
    throw new Error("Missing return statement in function");
}

  final public LocalVariableDeclaration LocalVariableDeclaration() throws ParseException {Type n0;
   VariableDeclarator n1;
   NodeListOptional n2 = new NodeListOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   VariableDeclarator n6;
    n0 = Type();
    n1 = VariableDeclarator();
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[92] = jj_gen;
        break label_35;
      }
n3 = new NodeSequence(2);
      n5 = jj_consume_token(COMMA);
n4 = JTBToolkit.makeNodeToken(n5);
n3.addNode(n4);
      n6 = VariableDeclarator();
n3.addNode(n6);
n2.addNode(n3);
    }
n2.nodes.trimToSize();
{if ("" != null) return new LocalVariableDeclaration(n0,n1,n2);}
    throw new Error("Missing return statement in function");
}

  final public EmptyStatement EmptyStatement() throws ParseException {NodeToken n0;
   Token n1;
    n1 = jj_consume_token(SEMICOLON);
n0 = JTBToolkit.makeNodeToken(n1);
{if ("" != null) return new EmptyStatement(n0);}
    throw new Error("Missing return statement in function");
}

  final public StatementExpression StatementExpression() throws ParseException {NodeChoice n0;
   PreIncrementExpression n1;
   PreDecrementExpression n2;
   Assignment n3;
   PostfixExpression n4;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INCR:{
      n1 = PreIncrementExpression();
n0 = new NodeChoice(n1, 0);
      break;
      }
    case DECR:{
      n2 = PreDecrementExpression();
n0 = new NodeChoice(n2, 1);
      break;
      }
    default:
      jj_la1[93] = jj_gen;
      if (jj_2_25(2147483647)) {
        n3 = Assignment();
n0 = new NodeChoice(n3, 2);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FALSE:
        case NEW:
        case NULL:
        case SUPER:
        case THIS:
        case TRUE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:{
          n4 = PostfixExpression();
n0 = new NodeChoice(n4, 3);
          break;
          }
        default:
          jj_la1[94] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return new StatementExpression(n0);}
    throw new Error("Missing return statement in function");
}

  final public SwitchStatement SwitchStatement() throws ParseException {NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeListOptional n9 = new NodeListOptional();
   NodeSequence n10;
   SwitchLabel n11;
   NodeListOptional n12;
   BlockStatement n13;
   NodeToken n14;
   Token n15;
    n1 = jj_consume_token(SWITCH);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(LBRACE);
n7 = JTBToolkit.makeNodeToken(n8);
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CASE:
      case _DEFAULT:{
        ;
        break;
        }
      default:
        jj_la1[95] = jj_gen;
        break label_36;
      }
n12 = new NodeListOptional();
n10 = new NodeSequence(2);
      n11 = SwitchLabel();
n10.addNode(n11);
      label_37:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case FOR:
        case IF:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case THROW:
        case TRUE:
        case TRY:
        case WHILE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case SEMICOLON:
        case INCR:
        case DECR:{
          ;
          break;
          }
        default:
          jj_la1[96] = jj_gen;
          break label_37;
        }
        n13 = BlockStatement();
n12.addNode(n13);
      }
n12.nodes.trimToSize();
n10.addNode(n12);
n9.addNode(n10);
    }
n9.nodes.trimToSize();
    n15 = jj_consume_token(RBRACE);
n14 = JTBToolkit.makeNodeToken(n15);
{if ("" != null) return new SwitchStatement(n0,n2,n4,n5,n7,n9,n14);}
    throw new Error("Missing return statement in function");
}

  final public SwitchLabel SwitchLabel() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   NodeSequence n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CASE:{
n1 = new NodeSequence(3);
      n3 = jj_consume_token(CASE);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      n4 = Expression();
n1.addNode(n4);
      n6 = jj_consume_token(COLON);
n5 = JTBToolkit.makeNodeToken(n6);
n1.addNode(n5);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case _DEFAULT:{
n7 = new NodeSequence(2);
      n9 = jj_consume_token(_DEFAULT);
n8 = JTBToolkit.makeNodeToken(n9);
n7.addNode(n8);
      n11 = jj_consume_token(COLON);
n10 = JTBToolkit.makeNodeToken(n11);
n7.addNode(n10);
n0 = new NodeChoice(n7, 1);
      break;
      }
    default:
      jj_la1[97] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new SwitchLabel(n0);}
    throw new Error("Missing return statement in function");
}

  final public IfStatement IfStatement() throws ParseException {NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
   NodeOptional n8 = new NodeOptional();
   NodeSequence n9;
   NodeToken n10;
   Token n11;
   Statement n12;
    n1 = jj_consume_token(IF);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ELSE:{
n9 = new NodeSequence(2);
      n11 = jj_consume_token(ELSE);
n10 = JTBToolkit.makeNodeToken(n11);
n9.addNode(n10);
      n12 = Statement();
n9.addNode(n12);
n8.addNode(n9);
      break;
      }
    default:
      jj_la1[98] = jj_gen;
      ;
    }
{if ("" != null) return new IfStatement(n0,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
}

  final public WhileStatement WhileStatement() throws ParseException {NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
    n1 = jj_consume_token(WHILE);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
{if ("" != null) return new WhileStatement(n0,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
}

  final public DoStatement DoStatement() throws ParseException {NodeToken n0;
   Token n1;
   Statement n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   Expression n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(DO);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Statement();
    n4 = jj_consume_token(WHILE);
n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(LPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Expression();
    n9 = jj_consume_token(RPAREN);
n8 = JTBToolkit.makeNodeToken(n9);
    n11 = jj_consume_token(SEMICOLON);
n10 = JTBToolkit.makeNodeToken(n11);
{if ("" != null) return new DoStatement(n0,n2,n3,n5,n7,n8,n10);}
    throw new Error("Missing return statement in function");
}

  final public ForStatement ForStatement() throws ParseException {NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   ForInit n5;
   NodeToken n6;
   Token n7;
   NodeOptional n8 = new NodeOptional();
   Expression n9;
   NodeToken n10;
   Token n11;
   NodeOptional n12 = new NodeOptional();
   ForUpdate n13;
   NodeToken n14;
   Token n15;
   Statement n16;
    n1 = jj_consume_token(FOR);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case INCR:
    case DECR:{
      n5 = ForInit();
n4.addNode(n5);
      break;
      }
    default:
      jj_la1[99] = jj_gen;
      ;
    }
    n7 = jj_consume_token(SEMICOLON);
n6 = JTBToolkit.makeNodeToken(n7);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FALSE:
    case NEW:
    case NULL:
    case SUPER:
    case THIS:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:{
      n9 = Expression();
n8.addNode(n9);
      break;
      }
    default:
      jj_la1[100] = jj_gen;
      ;
    }
    n11 = jj_consume_token(SEMICOLON);
n10 = JTBToolkit.makeNodeToken(n11);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FALSE:
    case NEW:
    case NULL:
    case SUPER:
    case THIS:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case INCR:
    case DECR:{
      n13 = ForUpdate();
n12.addNode(n13);
      break;
      }
    default:
      jj_la1[101] = jj_gen;
      ;
    }
    n15 = jj_consume_token(RPAREN);
n14 = JTBToolkit.makeNodeToken(n15);
    n16 = Statement();
{if ("" != null) return new ForStatement(n0,n2,n4,n6,n8,n10,n12,n14,n16);}
    throw new Error("Missing return statement in function");
}

  final public ForInit ForInit() throws ParseException {NodeChoice n0;
   LocalVariableDeclaration n1;
   StatementExpressionList n2;
    if (jj_2_26(2147483647)) {
      n1 = LocalVariableDeclaration();
n0 = new NodeChoice(n1, 0);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FALSE:
      case NEW:
      case NULL:
      case SUPER:
      case THIS:
      case TRUE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case INCR:
      case DECR:{
        n2 = StatementExpressionList();
n0 = new NodeChoice(n2, 1);
        break;
        }
      default:
        jj_la1[102] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new ForInit(n0);}
    throw new Error("Missing return statement in function");
}

  final public StatementExpressionList StatementExpressionList() throws ParseException {StatementExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   StatementExpression n5;
    n0 = StatementExpression();
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[103] = jj_gen;
        break label_38;
      }
n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      n5 = StatementExpression();
n2.addNode(n5);
n1.addNode(n2);
    }
n1.nodes.trimToSize();
{if ("" != null) return new StatementExpressionList(n0,n1);}
    throw new Error("Missing return statement in function");
}

  final public ForUpdate ForUpdate() throws ParseException {StatementExpressionList n0;
    n0 = StatementExpressionList();
{if ("" != null) return new ForUpdate(n0);}
    throw new Error("Missing return statement in function");
}

  final public BreakStatement BreakStatement() throws ParseException {NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(BREAK);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      n4 = jj_consume_token(IDENTIFIER);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[104] = jj_gen;
      ;
    }
    n6 = jj_consume_token(SEMICOLON);
n5 = JTBToolkit.makeNodeToken(n6);
{if ("" != null) return new BreakStatement(n0,n2,n5);}
    throw new Error("Missing return statement in function");
}

  final public ContinueStatement ContinueStatement() throws ParseException {NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(CONTINUE);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      n4 = jj_consume_token(IDENTIFIER);
n3 = JTBToolkit.makeNodeToken(n4);
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[105] = jj_gen;
      ;
    }
    n6 = jj_consume_token(SEMICOLON);
n5 = JTBToolkit.makeNodeToken(n6);
{if ("" != null) return new ContinueStatement(n0,n2,n5);}
    throw new Error("Missing return statement in function");
}

  final public ReturnStatement ReturnStatement() throws ParseException {NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   Expression n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(RETURN);
n0 = JTBToolkit.makeNodeToken(n1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FALSE:
    case NEW:
    case NULL:
    case SUPER:
    case THIS:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:{
      n3 = Expression();
n2.addNode(n3);
      break;
      }
    default:
      jj_la1[106] = jj_gen;
      ;
    }
    n5 = jj_consume_token(SEMICOLON);
n4 = JTBToolkit.makeNodeToken(n5);
{if ("" != null) return new ReturnStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
}

  final public ThrowStatement ThrowStatement() throws ParseException {NodeToken n0;
   Token n1;
   Expression n2;
   NodeToken n3;
   Token n4;
    n1 = jj_consume_token(THROW);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Expression();
    n4 = jj_consume_token(SEMICOLON);
n3 = JTBToolkit.makeNodeToken(n4);
{if ("" != null) return new ThrowStatement(n0,n2,n3);}
    throw new Error("Missing return statement in function");
}

  final public SynchronizedStatement SynchronizedStatement() throws ParseException {NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Block n7;
    n1 = jj_consume_token(SYNCHRONIZED);
n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(LPAREN);
n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RPAREN);
n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Block();
{if ("" != null) return new SynchronizedStatement(n0,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
}

  final public TryStatement TryStatement() throws ParseException {NodeToken n0;
   Token n1;
   Block n2;
   NodeListOptional n3 = new NodeListOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   FormalParameter n9;
   NodeToken n10;
   Token n11;
   Block n12;
   NodeOptional n13 = new NodeOptional();
   NodeSequence n14;
   NodeToken n15;
   Token n16;
   Block n17;
    n1 = jj_consume_token(TRY);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Block();
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CATCH:{
        ;
        break;
        }
      default:
        jj_la1[107] = jj_gen;
        break label_39;
      }
n4 = new NodeSequence(5);
      n6 = jj_consume_token(CATCH);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n8 = jj_consume_token(LPAREN);
n7 = JTBToolkit.makeNodeToken(n8);
n4.addNode(n7);
      n9 = FormalParameter();
n4.addNode(n9);
      n11 = jj_consume_token(RPAREN);
n10 = JTBToolkit.makeNodeToken(n11);
n4.addNode(n10);
      n12 = Block();
n4.addNode(n12);
n3.addNode(n4);
    }
n3.nodes.trimToSize();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FINALLY:{
n14 = new NodeSequence(2);
      n16 = jj_consume_token(FINALLY);
n15 = JTBToolkit.makeNodeToken(n16);
n14.addNode(n15);
      n17 = Block();
n14.addNode(n17);
n13.addNode(n14);
      break;
      }
    default:
      jj_la1[108] = jj_gen;
      ;
    }
{if ("" != null) return new TryStatement(n0,n2,n3,n13);}
    throw new Error("Missing return statement in function");
}

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_3()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_4()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_5()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_6()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_7()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_8()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_9()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_10()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_11()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_12()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_13()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_14()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_15()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_16()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_17()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_18()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_19()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_20()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_21()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_22()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_23()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_24()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_25()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_26()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_3_10()
 {
    if (jj_3R_accessor_set_declaration_822_4_48()) return true;
    return false;
  }

  private boolean jj_3R_CastExpression_2287_7_204()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_Name_1431_4_43()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_CastExpression_2293_10_209()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_UnaryExpressionNotPlusMinus_2071_4_196()) return true;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_accessor_set_declaration_822_4_48()) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_3R_accessor_get_declaration_790_4_49()) return true;
    return false;
  }

  private boolean jj_3_12()
 {
    if (jj_3R_Type_1321_4_51()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_CastExpression_2272_10_208()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_ShiftExpression_1882_13_180()
 {
    if (jj_scan_token(RUNSIGNEDSHIFT)) return true;
    return false;
  }

  private boolean jj_3R_ShiftExpression_1879_13_179()
 {
    if (jj_scan_token(RSIGNEDSHIFT)) return true;
    return false;
  }

  private boolean jj_3R_ShiftExpression_1876_13_178()
 {
    if (jj_scan_token(LSHIFT)) return true;
    return false;
  }

  private boolean jj_3R_Assignment_1502_4_106()
 {
    if (jj_3R_PrimaryExpression_2321_4_53()) return true;
    if (jj_3R_AssignmentOperator_1540_4_54()) return true;
    if (jj_3R_Expression_1481_4_45()) return true;
    return false;
  }

  private boolean jj_3_19()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_PrimitiveType_1367_4_56()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_CastExpression_2272_10_208()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_UnaryExpression_1995_4_181()) return true;
    return false;
  }

  private boolean jj_3R_CastExpression_2264_4_202()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3R_CastExpression_2287_7_204()) return true;
    }
    return false;
  }

  private boolean jj_3_15()
 {
    if (jj_3R_PrimaryExpression_2321_4_53()) return true;
    if (jj_3R_AssignmentOperator_1540_4_54()) return true;
    return false;
  }

  private boolean jj_3_22()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_ShiftExpression_1873_7_171()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ShiftExpression_1876_13_178()) {
    jj_scanpos = xsp;
    if (jj_3R_ShiftExpression_1879_13_179()) {
    jj_scanpos = xsp;
    if (jj_3R_ShiftExpression_1882_13_180()) return true;
    }
    }
    if (jj_3R_AdditiveExpression_1912_4_170()) return true;
    return false;
  }

  private boolean jj_3R_Expression_1486_7_62()
 {
    if (jj_3R_ConditionalExpression_1596_4_107()) return true;
    return false;
  }

  private boolean jj_3R_ShiftExpression_1871_4_168()
 {
    if (jj_3R_AdditiveExpression_1912_4_170()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_ShiftExpression_1873_7_171()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_null_323_19_40()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(9)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) return true;
    }
    }
    return false;
  }

  private boolean jj_3_1()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_null_323_19_40()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_Expression_1482_7_61()
 {
    if (jj_3R_Assignment_1502_4_106()) return true;
    return false;
  }

  private boolean jj_3_21()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_Expression_1481_4_45()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_field_body_706_13_47()
 {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_Expression_1481_4_45()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Expression_1482_7_61()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_1486_7_62()) return true;
    }
    return false;
  }

  private boolean jj_3R_ArrayDimensions_2628_4_148()
 {
    Token xsp;
    if (jj_3_21()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_21()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_22()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_field_body_697_13_46()
 {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3R_RelationalExpression_1839_13_175()
 {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_2222_10_207()
 {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_RelationalExpression_1836_13_174()
 {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_2219_10_206()
 {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_RelationalExpression_1833_13_173()
 {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_Expression_1481_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_field_body_697_13_46()) {
    jj_scanpos = xsp;
    if (jj_3R_field_body_706_13_47()) return true;
    }
    return false;
  }

  private boolean jj_3R_AllocationExpression_2597_13_150()
 {
    if (jj_3R_ArrayDimensions_2628_4_148()) return true;
    return false;
  }

  private boolean jj_3R_RelationalExpression_1830_13_172()
 {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_2218_7_205()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_PostfixExpression_2219_10_206()) {
    jj_scanpos = xsp;
    if (jj_3R_PostfixExpression_2222_10_207()) return true;
    }
    return false;
  }

  private boolean jj_3R_AllocationExpression_2594_13_149()
 {
    if (jj_3R_Arguments_2521_4_112()) return true;
    return false;
  }

  private boolean jj_3R_PostfixExpression_2216_4_203()
 {
    if (jj_3R_PrimaryExpression_2321_4_53()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_PostfixExpression_2218_7_205()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_RelationalExpression_1827_7_169()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_RelationalExpression_1830_13_172()) {
    jj_scanpos = xsp;
    if (jj_3R_RelationalExpression_1833_13_173()) {
    jj_scanpos = xsp;
    if (jj_3R_RelationalExpression_1836_13_174()) {
    jj_scanpos = xsp;
    if (jj_3R_RelationalExpression_1839_13_175()) return true;
    }
    }
    }
    if (jj_3R_ShiftExpression_1871_4_168()) return true;
    return false;
  }

  private boolean jj_3R_RelationalExpression_1825_4_164()
 {
    if (jj_3R_ShiftExpression_1871_4_168()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_RelationalExpression_1827_7_169()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_AllocationExpression_2587_7_143()
 {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_Name_1431_4_43()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_AllocationExpression_2594_13_149()) {
    jj_scanpos = xsp;
    if (jj_3R_AllocationExpression_2597_13_150()) return true;
    }
    return false;
  }

  private boolean jj_3_14()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_CastLookahead_2191_13_127()
 {
    if (jj_3R_Literal_2451_4_130()) return true;
    return false;
  }

  private boolean jj_3R_Name_1431_4_43()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_14()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_CastLookahead_2188_13_126()
 {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  private boolean jj_3_20()
 {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_PrimitiveType_1367_4_56()) return true;
    if (jj_3R_ArrayDimensions_2628_4_148()) return true;
    return false;
  }

  private boolean jj_3R_CastLookahead_2185_13_125()
 {
    if (jj_scan_token(SUPER)) return true;
    return false;
  }

  private boolean jj_3R_AllocationExpression_2576_4_131()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3R_AllocationExpression_2587_7_143()) return true;
    }
    return false;
  }

  private boolean jj_3R_CastLookahead_2182_13_124()
 {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_CastLookahead_2179_13_123()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_CastLookahead_2176_13_122()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_CastLookahead_2173_13_121()
 {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_InstanceOfExpression_1795_7_165()
 {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_Type_1321_4_51()) return true;
    return false;
  }

  private boolean jj_3R_ResultType_1410_7_105()
 {
    if (jj_3R_Type_1321_4_51()) return true;
    return false;
  }

  private boolean jj_3R_CastLookahead_2170_13_120()
 {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_InstanceOfExpression_1793_4_162()
 {
    if (jj_3R_RelationalExpression_1825_4_164()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_InstanceOfExpression_1795_7_165()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_ResultType_1407_7_104()
 {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_ResultType_1406_4_60()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ResultType_1407_7_104()) {
    jj_scanpos = xsp;
    if (jj_3R_ResultType_1410_7_105()) return true;
    }
    return false;
  }

  private boolean jj_3R_ArgumentList_2545_7_159()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_Expression_1481_4_45()) return true;
    return false;
  }

  private boolean jj_3R_CastLookahead_2161_7_87()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_Name_1431_4_43()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_CastLookahead_2170_13_120()) {
    jj_scanpos = xsp;
    if (jj_3R_CastLookahead_2173_13_121()) {
    jj_scanpos = xsp;
    if (jj_3R_CastLookahead_2176_13_122()) {
    jj_scanpos = xsp;
    if (jj_3R_CastLookahead_2179_13_123()) {
    jj_scanpos = xsp;
    if (jj_3R_CastLookahead_2182_13_124()) {
    jj_scanpos = xsp;
    if (jj_3R_CastLookahead_2185_13_125()) {
    jj_scanpos = xsp;
    if (jj_3R_CastLookahead_2188_13_126()) {
    jj_scanpos = xsp;
    if (jj_3R_CastLookahead_2191_13_127()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_Name_1431_4_43()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_ArgumentList_2543_4_156()
 {
    if (jj_3R_Expression_1481_4_45()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_ArgumentList_2545_7_159()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_EqualityExpression_1766_13_167()
 {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_PrimitiveType_1389_7_95()
 {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_EqualityExpression_1763_13_166()
 {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_PrimitiveType_1386_7_94()
 {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_PrimitiveType_1383_7_93()
 {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3R_CastLookahead_2149_7_86()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_Name_1431_4_43()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_PrimitiveType_1380_7_92()
 {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_EqualityExpression_1760_7_163()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_EqualityExpression_1763_13_166()) {
    jj_scanpos = xsp;
    if (jj_3R_EqualityExpression_1766_13_167()) return true;
    }
    if (jj_3R_InstanceOfExpression_1793_4_162()) return true;
    return false;
  }

  private boolean jj_3R_PrimitiveType_1377_7_91()
 {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_PrimitiveType_1367_4_56()) return true;
    return false;
  }

  private boolean jj_3R_PrimitiveType_1374_7_90()
 {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }

  private boolean jj_3R_Arguments_2523_7_151()
 {
    if (jj_3R_ArgumentList_2543_4_156()) return true;
    return false;
  }

  private boolean jj_3R_EqualityExpression_1758_4_160()
 {
    if (jj_3R_InstanceOfExpression_1793_4_162()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_EqualityExpression_1760_7_163()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_PrimitiveType_1371_7_89()
 {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3R_CastLookahead_2140_4_55()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3R_CastLookahead_2149_7_86()) {
    jj_scanpos = xsp;
    if (jj_3R_CastLookahead_2161_7_87()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_Arguments_2521_4_112()
 {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Arguments_2523_7_151()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_PrimitiveType_1368_7_88()
 {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3R_PrimitiveType_1367_4_56()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_PrimitiveType_1368_7_88()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimitiveType_1371_7_89()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimitiveType_1374_7_90()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimitiveType_1377_7_91()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimitiveType_1380_7_92()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimitiveType_1383_7_93()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimitiveType_1386_7_94()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimitiveType_1389_7_95()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_MethodDeclarationLookahead_478_4_44()) return true;
    return false;
  }

  private boolean jj_3R_NullLiteral_2504_4_147()
 {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_AndExpression_1731_7_161()
 {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_EqualityExpression_1758_4_160()) return true;
    return false;
  }

  private boolean jj_3R_AndExpression_1729_4_157()
 {
    if (jj_3R_EqualityExpression_1758_4_160()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_AndExpression_1731_7_161()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_BooleanLiteral_2489_7_155()
 {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3_25()
 {
    if (jj_3R_PrimaryExpression_2321_4_53()) return true;
    if (jj_3R_AssignmentOperator_1540_4_54()) return true;
    return false;
  }

  private boolean jj_3R_BooleanLiteral_2486_7_154()
 {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_BooleanLiteral_2485_4_146()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_BooleanLiteral_2486_7_154()) {
    jj_scanpos = xsp;
    if (jj_3R_BooleanLiteral_2489_7_155()) return true;
    }
    return false;
  }

  private boolean jj_3R_Type_1332_7_69()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_16()
 {
    if (jj_3R_CastLookahead_2140_4_55()) return true;
    return false;
  }

  private boolean jj_3R_VariableInitializer_947_7_66()
 {
    if (jj_3R_Expression_1481_4_45()) return true;
    return false;
  }

  private boolean jj_3R_Type_1326_10_68()
 {
    if (jj_3R_Name_1431_4_43()) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpressionNotPlusMinus_2092_7_199()
 {
    if (jj_3R_PostfixExpression_2216_4_203()) return true;
    return false;
  }

  private boolean jj_3R_Type_1323_10_67()
 {
    if (jj_3R_PrimitiveType_1367_4_56()) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpressionNotPlusMinus_2088_7_198()
 {
    if (jj_3R_CastExpression_2264_4_202()) return true;
    return false;
  }

  private boolean jj_3R_ExclusiveOrExpression_1705_7_158()
 {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_AndExpression_1729_4_157()) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpressionNotPlusMinus_2078_13_201()
 {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_Type_1321_4_51()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Type_1323_10_67()) {
    jj_scanpos = xsp;
    if (jj_3R_Type_1326_10_68()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_Type_1332_7_69()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_Literal_2467_7_142()
 {
    if (jj_3R_NullLiteral_2504_4_147()) return true;
    return false;
  }

  private boolean jj_3R_ExclusiveOrExpression_1703_4_152()
 {
    if (jj_3R_AndExpression_1729_4_157()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_ExclusiveOrExpression_1705_7_158()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_UnaryExpressionNotPlusMinus_2075_13_200()
 {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_Literal_2464_7_141()
 {
    if (jj_3R_BooleanLiteral_2485_4_146()) return true;
    return false;
  }

  private boolean jj_3_11()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_VariableInitializer_915_4_50()) return true;
    return false;
  }

  private boolean jj_3R_Literal_2461_7_140()
 {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_Literal_2458_7_139()
 {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpressionNotPlusMinus_2072_7_197()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_UnaryExpressionNotPlusMinus_2075_13_200()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpressionNotPlusMinus_2078_13_201()) return true;
    }
    if (jj_3R_UnaryExpression_1995_4_181()) return true;
    return false;
  }

  private boolean jj_3R_Literal_2455_7_138()
 {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_Literal_2452_7_137()
 {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpressionNotPlusMinus_2071_4_196()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_UnaryExpressionNotPlusMinus_2072_7_197()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpressionNotPlusMinus_2088_7_198()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpressionNotPlusMinus_2092_7_199()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_VariableInitializer_916_7_65()
 {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3R_Literal_2451_4_130()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Literal_2452_7_137()) {
    jj_scanpos = xsp;
    if (jj_3R_Literal_2455_7_138()) {
    jj_scanpos = xsp;
    if (jj_3R_Literal_2458_7_139()) {
    jj_scanpos = xsp;
    if (jj_3R_Literal_2461_7_140()) {
    jj_scanpos = xsp;
    if (jj_3R_Literal_2464_7_141()) {
    jj_scanpos = xsp;
    if (jj_3R_Literal_2467_7_142()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_StaticInitializer_1300_4_41()
 {
    if (jj_scan_token(STATIC)) return true;
    if (jj_3R_Block_2764_4_58()) return true;
    return false;
  }

  private boolean jj_3R_InclusiveOrExpression_1679_7_153()
 {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_ExclusiveOrExpression_1703_4_152()) return true;
    return false;
  }

  private boolean jj_3R_VariableInitializer_915_4_50()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_VariableInitializer_916_7_65()) {
    jj_scanpos = xsp;
    if (jj_3R_VariableInitializer_947_7_66()) return true;
    }
    return false;
  }

  private boolean jj_3R_InclusiveOrExpression_1677_4_144()
 {
    if (jj_3R_ExclusiveOrExpression_1703_4_152()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_InclusiveOrExpression_1679_7_153()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_PreDecrementExpression_2049_4_195()
 {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_PrimaryExpression_2321_4_53()) return true;
    return false;
  }

  private boolean jj_3R_ExplicitConstructorInvocation_1278_7_71()
 {
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_Arguments_2521_4_112()) return true;
    return false;
  }

  private boolean jj_3R_PrimarySuffix_2427_7_134()
 {
    if (jj_3R_Arguments_2521_4_112()) return true;
    return false;
  }

  private boolean jj_3R_PrimarySuffix_2420_7_133()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_501_10_103()
 {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    return false;
  }

  private boolean jj_3R_ConditionalAndExpression_1653_7_145()
 {
    if (jj_scan_token(SC_AND)) return true;
    if (jj_3R_InclusiveOrExpression_1677_4_144()) return true;
    return false;
  }

  private boolean jj_3R_ExplicitConstructorInvocation_1269_7_70()
 {
    if (jj_scan_token(THIS)) return true;
    if (jj_3R_Arguments_2521_4_112()) return true;
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_498_10_102()
 {
    if (jj_scan_token(NATIVE)) return true;
    return false;
  }

  private boolean jj_3_24()
 {
    if (jj_3R_Type_1321_4_51()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_PreIncrementExpression_2034_4_194()
 {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_PrimaryExpression_2321_4_53()) return true;
    return false;
  }

  private boolean jj_3R_ExplicitConstructorInvocation_1268_4_52()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ExplicitConstructorInvocation_1269_7_70()) {
    jj_scanpos = xsp;
    if (jj_3R_ExplicitConstructorInvocation_1278_7_71()) return true;
    }
    return false;
  }

  private boolean jj_3R_ConditionalAndExpression_1651_4_135()
 {
    if (jj_3R_InclusiveOrExpression_1677_4_144()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_ConditionalAndExpression_1653_7_145()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_495_10_101()
 {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3R_PrimarySuffix_2411_7_132()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_Expression_1481_4_45()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_492_10_100()
 {
    if (jj_scan_token(ABSTRACT)) return true;
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_489_10_99()
 {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_PrimarySuffix_2410_4_119()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_PrimarySuffix_2411_7_132()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimarySuffix_2420_7_133()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimarySuffix_2427_7_134()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_486_10_98()
 {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_2018_7_188()
 {
    if (jj_3R_UnaryExpressionNotPlusMinus_2071_4_196()) return true;
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_483_10_97()
 {
    if (jj_scan_token(PROTECTED)) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_2015_7_187()
 {
    if (jj_3R_PreDecrementExpression_2049_4_195()) return true;
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_480_10_96()
 {
    if (jj_scan_token(PUBLIC)) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_2012_7_186()
 {
    if (jj_3R_PreIncrementExpression_2034_4_194()) return true;
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_479_7_59()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_MethodDeclarationLookahead_480_10_96()) {
    jj_scanpos = xsp;
    if (jj_3R_MethodDeclarationLookahead_483_10_97()) {
    jj_scanpos = xsp;
    if (jj_3R_MethodDeclarationLookahead_486_10_98()) {
    jj_scanpos = xsp;
    if (jj_3R_MethodDeclarationLookahead_489_10_99()) {
    jj_scanpos = xsp;
    if (jj_3R_MethodDeclarationLookahead_492_10_100()) {
    jj_scanpos = xsp;
    if (jj_3R_MethodDeclarationLookahead_495_10_101()) {
    jj_scanpos = xsp;
    if (jj_3R_MethodDeclarationLookahead_498_10_102()) {
    jj_scanpos = xsp;
    if (jj_3R_MethodDeclarationLookahead_501_10_103()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_ConditionalOrExpression_1627_7_136()
 {
    if (jj_scan_token(SC_OR)) return true;
    if (jj_3R_ConditionalAndExpression_1651_4_135()) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_2002_13_193()
 {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_MethodDeclarationLookahead_478_4_44()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_MethodDeclarationLookahead_479_7_59()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_ResultType_1406_4_60()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_1999_13_192()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_ConditionalOrExpression_1625_4_128()
 {
    if (jj_3R_ConditionalAndExpression_1651_4_135()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_ConditionalOrExpression_1627_7_136()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_13()
 {
    if (jj_3R_ExplicitConstructorInvocation_1268_4_52()) return true;
    return false;
  }

  private boolean jj_3R_PrimaryPrefix_2384_7_118()
 {
    if (jj_3R_AllocationExpression_2576_4_131()) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_1996_7_185()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_UnaryExpression_1999_13_192()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpression_2002_13_193()) return true;
    }
    if (jj_3R_UnaryExpression_1995_4_181()) return true;
    return false;
  }

  private boolean jj_3R_Block_2764_4_58()
 {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3R_UnaryExpression_1995_4_181()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_UnaryExpression_1996_7_185()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpression_2012_7_186()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpression_2015_7_187()) {
    jj_scanpos = xsp;
    if (jj_3R_UnaryExpression_2018_7_188()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_PrimaryPrefix_2375_7_117()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_Expression_1481_4_45()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_PrimaryPrefix_2366_7_116()
 {
    if (jj_scan_token(SUPER)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_ConditionalExpression_1598_7_129()
 {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_Expression_1481_4_45()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_ConditionalExpression_1596_4_107()) return true;
    return false;
  }

  private boolean jj_3R_PrimaryPrefix_2363_7_115()
 {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_accessor_set_declaration_827_10_109()
 {
    if (jj_scan_token(PUBLIC)) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_MethodDeclarationLookahead_478_4_44()) return true;
    return false;
  }

  private boolean jj_3R_PrimaryPrefix_2360_7_114()
 {
    if (jj_3R_Name_1431_4_43()) return true;
    return false;
  }

  private boolean jj_3R_accessor_set_declaration_824_10_108()
 {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  private boolean jj_3R_ConditionalExpression_1596_4_107()
 {
    if (jj_3R_ConditionalOrExpression_1625_4_128()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_ConditionalExpression_1598_7_129()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_LabeledStatement_2745_4_57()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_null_431_19_42()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_PrimaryPrefix_2357_7_113()
 {
    if (jj_3R_Literal_2451_4_130()) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_null_431_19_42()) jj_scanpos = xsp;
    if (jj_3R_Name_1431_4_43()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_accessor_set_declaration_823_7_63()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_accessor_set_declaration_824_10_108()) {
    jj_scanpos = xsp;
    if (jj_3R_accessor_set_declaration_827_10_109()) return true;
    }
    return false;
  }

  private boolean jj_3R_PrimaryPrefix_2356_4_72()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_PrimaryPrefix_2357_7_113()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimaryPrefix_2360_7_114()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimaryPrefix_2363_7_115()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimaryPrefix_2366_7_116()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimaryPrefix_2375_7_117()) {
    jj_scanpos = xsp;
    if (jj_3R_PrimaryPrefix_2384_7_118()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_MultiplicativeExpression_1963_13_191()
 {
    if (jj_scan_token(REM)) return true;
    return false;
  }

  private boolean jj_3R_accessor_set_declaration_822_4_48()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_accessor_set_declaration_823_7_63()) jj_scanpos = xsp;
    if (jj_scan_token(SET)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_MultiplicativeExpression_1960_13_190()
 {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  private boolean jj_3R_MultiplicativeExpression_1957_13_189()
 {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3_26()
 {
    if (jj_3R_Type_1321_4_51()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_3R_StaticInitializer_1300_4_41()) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1574_7_85()
 {
    if (jj_scan_token(ORASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_MultiplicativeExpression_1954_7_182()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_MultiplicativeExpression_1957_13_189()) {
    jj_scanpos = xsp;
    if (jj_3R_MultiplicativeExpression_1960_13_190()) {
    jj_scanpos = xsp;
    if (jj_3R_MultiplicativeExpression_1963_13_191()) return true;
    }
    }
    if (jj_3R_UnaryExpression_1995_4_181()) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1571_7_84()
 {
    if (jj_scan_token(XORASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1568_7_83()
 {
    if (jj_scan_token(ANDASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_MultiplicativeExpression_1952_4_176()
 {
    if (jj_3R_UnaryExpression_1995_4_181()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_MultiplicativeExpression_1954_7_182()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1565_7_82()
 {
    if (jj_scan_token(RUNSIGNEDSHIFTASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_accessor_get_declaration_795_10_111()
 {
    if (jj_scan_token(PUBLIC)) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1562_7_81()
 {
    if (jj_scan_token(RSIGNEDSHIFTASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_accessor_get_declaration_792_10_110()
 {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1559_7_80()
 {
    if (jj_scan_token(LSHIFTASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_accessor_get_declaration_791_7_64()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_accessor_get_declaration_792_10_110()) {
    jj_scanpos = xsp;
    if (jj_3R_accessor_get_declaration_795_10_111()) return true;
    }
    return false;
  }

  private boolean jj_3R_PrimaryExpression_2323_7_73()
 {
    if (jj_3R_PrimarySuffix_2410_4_119()) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1556_7_79()
 {
    if (jj_scan_token(MINUSASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_accessor_get_declaration_790_4_49()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_accessor_get_declaration_791_7_64()) jj_scanpos = xsp;
    if (jj_scan_token(GET)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1553_7_78()
 {
    if (jj_scan_token(PLUSASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_PrimaryExpression_2321_4_53()
 {
    if (jj_3R_PrimaryPrefix_2356_4_72()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_PrimaryExpression_2323_7_73()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1550_7_77()
 {
    if (jj_scan_token(REMASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1547_7_76()
 {
    if (jj_scan_token(SLASHASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1544_7_75()
 {
    if (jj_scan_token(STARASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_AdditiveExpression_1920_13_184()
 {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1541_7_74()
 {
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_AdditiveExpression_1917_13_183()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_AssignmentOperator_1540_4_54()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_AssignmentOperator_1541_7_74()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1544_7_75()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1547_7_76()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1550_7_77()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1553_7_78()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1556_7_79()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1559_7_80()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1562_7_81()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1565_7_82()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1568_7_83()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1571_7_84()) {
    jj_scanpos = xsp;
    if (jj_3R_AssignmentOperator_1574_7_85()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_accessor_get_declaration_790_4_49()) return true;
    return false;
  }

  private boolean jj_3R_AdditiveExpression_1914_7_177()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_AdditiveExpression_1917_13_183()) {
    jj_scanpos = xsp;
    if (jj_3R_AdditiveExpression_1920_13_184()) return true;
    }
    if (jj_3R_MultiplicativeExpression_1952_4_176()) return true;
    return false;
  }

  private boolean jj_3_23()
 {
    if (jj_3R_LabeledStatement_2745_4_57()) return true;
    return false;
  }

  private boolean jj_3R_CastExpression_2293_10_209()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_AdditiveExpression_1912_4_170()
 {
    if (jj_3R_MultiplicativeExpression_1952_4_176()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_AdditiveExpression_1914_7_177()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  /** Generated Token Manager. */
  public JavaParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[109];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	   jj_la1_init_3();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x0,0x0,0x2010200,0x0,0x200,0x2000200,0x2000200,0x800000,0x80000000,0xa209600,0x8209600,0x2000200,0x2000200,0x200,0x200,0x800000,0xa209600,0x8209600,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x1000000,0x2000200,0x2000200,0x0,0x0,0x0,0x0,0x8209400,0x0,0x0,0x0,0x0,0x59349c00,0x0,0x8209400,0x0,0x8209400,0x8209400,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x1000000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x1000000,0x1000000,0x1000000,0x0,0x0,0x0,0x51140800,0x59349c00,0x51140800,0x0,0x0,0x1000000,0x82000,0x59349c00,0x82000,0x400000,0x9209400,0x1000000,0x1000000,0x1000000,0x0,0x0,0x0,0x1000000,0x4000,0x4000000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x100,0x1,0x808,0x0,0x808,0x800,0x800,0x0,0x0,0x1026e74,0x6e54,0x24e20,0x24e20,0x800,0x800,0x0,0x1026e74,0x6e54,0x4e40,0x4e40,0x0,0x0,0xa00,0xa00,0xa00,0xa00,0x0,0x0,0x204480c0,0x0,0x204480c0,0x24e20,0x24e20,0x100000,0x0,0x0,0x0,0x2014,0x0,0xe00,0xe00,0x100000,0x24cfb0d4,0x48000,0x2014,0x0,0x2014,0x1002014,0x0,0x204480c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x204480c0,0x0,0x0,0x204480c0,0x204480c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x204480c0,0x0,0x20400080,0x400000,0x204480c0,0x0,0x0,0x40,0x24cf90c0,0x24cfb0d4,0x24cf90c0,0x0,0x0,0x204480c0,0x0,0x24cfb0d4,0x0,0x0,0x2044a0d4,0x204480c0,0x204480c0,0x204480c0,0x0,0x0,0x0,0x204480c0,0x0,0x0,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x0,0x0,0x4000,0x10000,0x4000,0x0,0x0,0x0,0x0,0x4020,0x4020,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x4400,0x4400,0x0,0x0,0x0,0x0,0x20000,0x1000,0xc030053a,0x8000,0xc030053a,0x0,0x0,0x0,0x4400,0x1000,0x8000,0x400020,0x400000,0x0,0x0,0x0,0xc000453a,0x0,0x20,0x1000,0x0,0x20,0x8000,0xc030013a,0x20000,0x400000,0x10000000,0x20000000,0x0,0x0,0x0,0x9000000,0x9000000,0x0,0x60c0000,0x60c0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc030013a,0x300000,0x300000,0x13a,0x30013a,0x100,0xc0000000,0xc0000000,0x1000,0x1000,0x100,0x11100,0x13a,0x11100,0x1a,0x0,0xc030013a,0x8000,0x1100,0x0,0xc000453a,0xc000453a,0xc000453a,0x8000,0xc0000000,0x13a,0x0,0xc000453a,0x0,0x0,0xc000013a,0xc030013a,0xc000013a,0xc000013a,0x8000,0x20,0x20,0xc030013a,0x0,0x0,};
	}
	private static void jj_la1_init_3() {
	   jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3ff800,0x0,0x0,0x0,0x20,0x40,0x10,0x0,0x0,0x0,0x0,0x0,0x700,0x700,0x3,0x3,0x8c,0x8c,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,};
	}
  final private JJCalls[] jj_2_rtns = new JJCalls[26];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public JavaParser(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public JavaParser(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new JavaParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 109; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 109; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public JavaParser(java.io.Reader stream) {
	 jj_input_stream = new JavaCharStream(stream, 1, 1);
	 token_source = new JavaParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 109; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new JavaCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new JavaParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 109; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public JavaParser(JavaParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 109; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(JavaParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 109; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[118];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 109; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		   if ((jj_la1_3[i] & (1<<j)) != 0) {
			 la1tokens[96+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 118; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 26; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			   case 2: jj_3_3(); break;
			   case 3: jj_3_4(); break;
			   case 4: jj_3_5(); break;
			   case 5: jj_3_6(); break;
			   case 6: jj_3_7(); break;
			   case 7: jj_3_8(); break;
			   case 8: jj_3_9(); break;
			   case 9: jj_3_10(); break;
			   case 10: jj_3_11(); break;
			   case 11: jj_3_12(); break;
			   case 12: jj_3_13(); break;
			   case 13: jj_3_14(); break;
			   case 14: jj_3_15(); break;
			   case 15: jj_3_16(); break;
			   case 16: jj_3_17(); break;
			   case 17: jj_3_18(); break;
			   case 18: jj_3_19(); break;
			   case 19: jj_3_20(); break;
			   case 20: jj_3_21(); break;
			   case 21: jj_3_22(); break;
			   case 22: jj_3_23(); break;
			   case 23: jj_3_24(); break;
			   case 24: jj_3_25(); break;
			   case 25: jj_3_26(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
   }
}
