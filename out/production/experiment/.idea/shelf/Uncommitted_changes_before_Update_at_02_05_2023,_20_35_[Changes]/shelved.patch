Index: syntaxtree/ClassBodyDeclaration.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage syntaxtree;\n\n/**\n * Grammar production:\n * f0 -> FieldDeclaration()\n */\npublic class ClassBodyDeclaration implements Node {\n   public FieldDeclaration f0;\n\n   public ClassBodyDeclaration(FieldDeclaration n0) {\n      f0 = n0;\n   }\n\n   public void accept(visitor.Visitor v) {\n      v.visit(this);\n   }\n   public <R,A> R accept(visitor.GJVisitor<R,A> v, A argu) {\n      return v.visit(this,argu);\n   }\n   public <R> R accept(visitor.GJNoArguVisitor<R> v) {\n      return v.visit(this);\n   }\n   public <A> void accept(visitor.GJVoidVisitor<A> v, A argu) {\n      v.visit(this,argu);\n   }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/syntaxtree/ClassBodyDeclaration.java b/syntaxtree/ClassBodyDeclaration.java
--- a/syntaxtree/ClassBodyDeclaration.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/syntaxtree/ClassBodyDeclaration.java	(date 1683052205939)
@@ -6,12 +6,12 @@
 
 /**
  * Grammar production:
- * f0 -> FieldDeclaration()
+ * f0 -> ( FieldDeclaration() )*
  */
 public class ClassBodyDeclaration implements Node {
-   public FieldDeclaration f0;
+   public NodeListOptional f0;
 
-   public ClassBodyDeclaration(FieldDeclaration n0) {
+   public ClassBodyDeclaration(NodeListOptional n0) {
       f0 = n0;
    }
 
Index: CGOL3.jj
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2006, Sun Microsystems, Inc.\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *     * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the Sun Microsystems, Inc. nor the names of its\n *       contributors may be used to endorse or promote products derived from\n *       this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n options {\n    JAVA_UNICODE_ESCAPE = true;\n  }\n  \n  PARSER_BEGIN(JavaParser)\n\nimport java.io.IOException;\n\n  public class JavaParser {\n  static void printDebugInfo(String productionName) {\n//      Token t = getToken(1);\n//      System.err.println(\"Parsing \" + productionName + \" at line \" + t.beginLine + \", column \" + t.beginColumn);\n\n    }\n    public static void main(String args[]) {\n      JavaParser parser;\n      if (args.length == 0) {\n        System.out.println(\"==========================================================================================================\");\n        System.out.println(\"==========================================================================================================\");\n        System.out.println(\"Java Parser Version 1.0.2:  Reading from standard input . . .\");\n        parser = new JavaParser(System.in);\n      } else if (args.length == 1) {\n        System.out.println(\"==========================================================================================================\");\n        System.out.println(\"==========================================================================================================\");\n\n        System.out.println(\"Java Parser Version 1.0.2:  Reading from file \" + args[0] + \" . . .\");\n        try {\n          parser = new JavaParser(new java.io.FileInputStream(args[0]));\n        } catch (java.io.FileNotFoundException e) {\n          System.out.println(\"Java Parser Version 1.0.2:  File \" + args[0] + \" not found.\");\n          return;\n        }\n      } else {\n        System.out.println(\"Java Parser Version 1.0.2:  Usage is one of:\");\n        System.out.println(\"         java JavaParser < inputfile\");\n        System.out.println(\"OR\");\n        System.out.println(\"         java JavaParser inputfile\");\n        return;\n      }\n      try {\n          Node root = parser.CompilationUnit();\n          MyVisitor v = new MyVisitor();\n          root.accept(v);\n          v.writeOutputToFile();\n        System.out.println(\"Java Parser Version 1.0.2:  Java program parsed successfully.\");\n      } catch (ParseException e) {\n        System.out.println(\"Java Parser Version 1.0.2:  Encountered errors during parse.\");\n        System.out.println(e.toString());\n      } catch (IOException e) {\n         throw new RuntimeException(e);\n     }\n    }\n  }\n  \n  PARSER_END(JavaParser)\n  \n  \n  SKIP : /* WHITE SPACE */\n  {\n    \" \"\n  | \"\\t\"\n  | \"\\n\"\n  | \"\\r\"\n  | \"\\f\"\n  }\n  \n  SPECIAL_TOKEN : /* COMMENTS */\n  {\n    <SINGLE_LINE_COMMENT: \"//\" (~[\"\\n\",\"\\r\"])* (\"\\n\"|\"\\r\"|\"\\r\\n\")>\n  | <FORMAL_COMMENT: \"/**\" (~[\"*\"])* \"*\" (\"*\" | (~[\"*\",\"/\"] (~[\"*\"])* \"*\"))* \"/\">\n  | <MULTI_LINE_COMMENT: \"/*\" (~[\"*\"])* \"*\" (\"*\" | (~[\"*\",\"/\"] (~[\"*\"])* \"*\"))* \"/\">\n  }\n  \n  TOKEN : /* RESERVED WORDS AND LITERALS */\n  {\n    < ABSTRACT: \"abstract\" >\n  | < BOOLEAN: \"boolean\" >\n  | < BREAK: \"break\" >\n  | < BYTE: \"byte\" >\n  | < CASE: \"case\" >\n  | < CATCH: \"catch\" >\n  | < CHAR: \"char\" >\n  | < CLASS: \"class\" >\n  | < CONST: \"const\" >\n  | < CONTINUE: \"continue\" >\n  | < _DEFAULT: \"default\" >\n  | < DO: \"do\" >\n  | < DOUBLE: \"double\" >\n  | < ELSE: \"else\" >\n  | < EXTENDS: \"extends\" >\n  | < FALSE: \"false\" >\n  | < FINAL: \"final\" >\n  | < FINALLY: \"finally\" >\n  | < FLOAT: \"float\" >\n  | < FOR: \"for\" >\n  | < GOTO: \"goto\" >\n  | < IF: \"if\" >\n  | < IMPLEMENTS: \"implements\" >\n  | < IMPORT: \"import\" >\n  | < INSTANCEOF: \"instanceof\" >\n  | < INT: \"int\" >\n  | < INTERFACE: \"interface\" >\n  | < LONG: \"long\" >\n  | < NATIVE: \"native\" >\n  | < NEW: \"new\" >\n  | < NULL: \"null\" >\n  | < PACKAGE: \"package\">\n  | < PRIVATE: \"private\" >\n  | < PROTECTED: \"protected\" >\n  | < PUBLIC: \"public\" >\n  | < RETURN: \"return\" >\n  | < SHORT: \"short\" >\n  | < STATIC: \"static\" >\n  | < SUPER: \"super\" >\n  | < SWITCH: \"switch\" >\n  | < SYNCHRONIZED: \"synchronized\" >\n  | < THIS: \"this\" >\n  | < THROW: \"throw\" >\n  | < THROWS: \"throws\" >\n  | < TRANSIENT: \"transient\" >\n  | < TRUE: \"true\" >\n  | < TRY: \"try\" >\n  | < VOID: \"void\" >\n  | < VOLATILE: \"volatile\" >\n  | < WHILE: \"while\" >\n  | < GET: \"get\" >\n  | < SET: \"set\" >\n  }\n  \n  TOKEN : /* LITERALS */\n  {\n    < INTEGER_LITERAL:\n          <DECIMAL_LITERAL> ([\"l\",\"L\"])?\n        | <HEX_LITERAL> ([\"l\",\"L\"])?\n        | <OCTAL_LITERAL> ([\"l\",\"L\"])?\n    >\n  |\n    < #DECIMAL_LITERAL: [\"1\"-\"9\"] ([\"0\"-\"9\"])* >\n  |\n    < #HEX_LITERAL: \"0\" [\"x\",\"X\"] ([\"0\"-\"9\",\"a\"-\"f\",\"A\"-\"F\"])+ >\n  |\n    < #OCTAL_LITERAL: \"0\" ([\"0\"-\"7\"])* >\n  |\n    < FLOATING_POINT_LITERAL:\n          ([\"0\"-\"9\"])+ \".\" ([\"0\"-\"9\"])* (<EXPONENT>)? ([\"f\",\"F\",\"d\",\"D\"])?\n        | \".\" ([\"0\"-\"9\"])+ (<EXPONENT>)? ([\"f\",\"F\",\"d\",\"D\"])?\n        | ([\"0\"-\"9\"])+ <EXPONENT> ([\"f\",\"F\",\"d\",\"D\"])?\n        | ([\"0\"-\"9\"])+ (<EXPONENT>)? [\"f\",\"F\",\"d\",\"D\"]\n    >\n  |\n    < #EXPONENT: [\"e\",\"E\"] ([\"+\",\"-\"])? ([\"0\"-\"9\"])+ >\n  |\n    < CHARACTER_LITERAL:\n        \"'\"\n        (   (~[\"'\",\"\\\\\",\"\\n\",\"\\r\"])\n          | (\"\\\\\"\n              ( [\"n\",\"t\",\"b\",\"r\",\"f\",\"\\\\\",\"'\",\"\\\"\"]\n              | [\"0\"-\"7\"] ( [\"0\"-\"7\"] )?\n              | [\"0\"-\"3\"] [\"0\"-\"7\"] [\"0\"-\"7\"]\n              )\n            )\n        )\n        \"'\"\n    >\n  |\n    < STRING_LITERAL:\n        \"\\\"\"\n        (   (~[\"\\\"\",\"\\\\\",\"\\n\",\"\\r\"])\n          | (\"\\\\\"\n              ( [\"n\",\"t\",\"b\",\"r\",\"f\",\"\\\\\",\"'\",\"\\\"\"]\n              | [\"0\"-\"7\"] ( [\"0\"-\"7\"] )?\n              | [\"0\"-\"3\"] [\"0\"-\"7\"] [\"0\"-\"7\"]\n              )\n            )\n        )*\n        \"\\\"\"\n    >\n  }\n  \n  TOKEN : /* IDENTIFIERS */\n  {\n    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >\n  |\n    < #LETTER:\n        [\n         \"\\u0024\",\n         \"\\u0041\"-\"\\u005a\",\n         \"\\u005f\",\n         \"\\u0061\"-\"\\u007a\",\n         \"\\u00c0\"-\"\\u00d6\",\n         \"\\u00d8\"-\"\\u00f6\",\n         \"\\u00f8\"-\"\\u00ff\",\n         \"\\u0100\"-\"\\u1fff\",\n         \"\\u3040\"-\"\\u318f\",\n         \"\\u3300\"-\"\\u337f\",\n         \"\\u3400\"-\"\\u3d2d\",\n         \"\\u4e00\"-\"\\u9fff\",\n         \"\\uf900\"-\"\\ufaff\"\n        ]\n    >\n  |\n    < #DIGIT:\n        [\n         \"\\u0030\"-\"\\u0039\",\n         \"\\u0660\"-\"\\u0669\",\n         \"\\u06f0\"-\"\\u06f9\",\n         \"\\u0966\"-\"\\u096f\",\n         \"\\u09e6\"-\"\\u09ef\",\n         \"\\u0a66\"-\"\\u0a6f\",\n         \"\\u0ae6\"-\"\\u0aef\",\n         \"\\u0b66\"-\"\\u0b6f\",\n         \"\\u0be7\"-\"\\u0bef\",\n         \"\\u0c66\"-\"\\u0c6f\",\n         \"\\u0ce6\"-\"\\u0cef\",\n         \"\\u0d66\"-\"\\u0d6f\",\n         \"\\u0e50\"-\"\\u0e59\",\n         \"\\u0ed0\"-\"\\u0ed9\",\n         \"\\u1040\"-\"\\u1049\"\n        ]\n    >\n  }\n  \n  TOKEN : /* SEPARATORS */\n  {\n    < LPAREN: \"(\" >\n  | < RPAREN: \")\" >\n  | < LBRACE: \"{\" >\n  | < RBRACE: \"}\" >\n  | < LBRACKET: \"[\" >\n  | < RBRACKET: \"]\" >\n  | < SEMICOLON: \";\" >\n  | < COMMA: \",\" >\n  | < DOT: \".\" >\n  }\n  \n  TOKEN : /* OPERATORS */\n  {\n    < ASSIGN: \"=\" >\n  | < GT: \">\" >\n  | < LT: \"<\" >\n  | < BANG: \"!\" >\n  | < TILDE: \"~\" >\n  | < HOOK: \"?\" >\n  | < COLON: \":\" >\n  | < EQ: \"==\" >\n  | < LE: \"<=\" >\n  | < GE: \">=\" >\n  | < NE: \"!=\" >\n  | < SC_OR: \"||\" >\n  | < SC_AND: \"&&\" >\n  | < INCR: \"++\" >\n  | < DECR: \"--\" >\n  | < PLUS: \"+\" >\n  | < MINUS: \"-\" >\n  | < STAR: \"*\" >\n  | < SLASH: \"/\" >\n  | < BIT_AND: \"&\" >\n  | < BIT_OR: \"|\" >\n  | < XOR: \"^\" >\n  | < REM: \"%\" >\n  | < LSHIFT: \"<<\" >\n  | < RSIGNEDSHIFT: \">>\" >\n  | < RUNSIGNEDSHIFT: \">>>\" >\n  | < PLUSASSIGN: \"+=\" >\n  | < MINUSASSIGN: \"-=\" >\n  | < STARASSIGN: \"*=\" >\n  | < SLASHASSIGN: \"/=\" >\n  | < ANDASSIGN: \"&=\" >\n  | < ORASSIGN: \"|=\" >\n  | < XORASSIGN: \"^=\" >\n  | < REMASSIGN: \"%=\" >\n  | < LSHIFTASSIGN: \"<<=\" >\n  | < RSIGNEDSHIFTASSIGN: \">>=\" >\n  | < RUNSIGNEDSHIFTASSIGN: \">>>=\" >\n  }\n  \n  \n  /*****************************************\n   * THE JAVA LANGUAGE GRAMMAR STARTS HERE *\n   *****************************************/\n  \n  /*\n   * Program structuring syntax follows.\n   */\n  \n  void CompilationUnit() :\n  {printDebugInfo(\"CompilationUnit\");}\n  {\n    ( TypeDeclaration() )*\n    <EOF>\n  }\n  \n  \n  void TypeDeclaration() :\n  {printDebugInfo(\"TypeDeclaration\");}\n  {\n    LOOKAHEAD( ( \"abstract\" | \"final\" | \"public\" )* \"class\" )\n    ClassDeclaration()\n  |\n    \";\"\n  }\n  \n  \n  /*\n   * Declaration syntax follows.\n   */\n  \n  void ClassDeclaration() :\n  {printDebugInfo(\"ClassDeclaration\");}\n  {\n    ( \"abstract\" | \"final\" | \"public\" )*\n    \"class\" <IDENTIFIER> [ \"extends\" Name() ] [ \"implements\" NameList() ]\n    \"{\" ( ClassBodyDeclaration() )* \"}\"\n  }\n  \n  void ClassBodyDeclaration() :\n  {printDebugInfo(\"ClassBodyDeclaration\");}\n  {\n    FieldDeclaration()\n  }\n  \n\nvoid FieldDeclaration() :\n{printDebugInfo(\"FieldDeclaration\");}\n{\n    (field_modifier())* Type() <IDENTIFIER> field_body()\n}\n\nvoid field_modifier() :\n{printDebugInfo(\"field_modifier\");}\n{\n    \"new\"\n  | \"public\"\n  | \"protected\"\n  | \"private\"\n  | \"static\"\n  | \"abstract\"\n}\n\nvoid field_body() :\n{printDebugInfo(\"field_body\");}\n{\n    (\n      LOOKAHEAD(3) \"=\" Expression() (\"{\" accessor_declarations() \"}\" | \";\")\n    |\n      \"{\" accessor_declarations() \"}\"\n    |\n      \";\"\n    )\n}\n\nvoid accessor_declarations() :\n  {\n    printDebugInfo(\"accessor_declarations\");\n  }\n{\n  (\n    LOOKAHEAD(2) accessor_get_declaration() (LOOKAHEAD(2) accessor_set_declaration())?\n  |\n    LOOKAHEAD(2) accessor_set_declaration() (LOOKAHEAD(2) accessor_get_declaration())?\n  )\n}\n\nvoid accessor_get_declaration() :\n{printDebugInfo(\"accessor_get_declaration\");}\n{\n  ( \"private\" | \"public\" )? <GET> \";\"\n}\n\nvoid accessor_set_declaration() :\n{printDebugInfo(\"accessor_set_declaration\");}\n{\n    ( \"private\" | \"public\" )? <SET> \";\"\n}\n  \n  void VariableDeclarator() :\n  {printDebugInfo(\"VariableDeclarator\");}\n  {\n    VariableDeclaratorId() [ \"=\" VariableInitializer() ]\n  }\n  \n  void VariableDeclaratorId() :\n  {printDebugInfo(\"VariableDeclaratorId\");}\n  {\n    <IDENTIFIER> ( \"[\" \"]\" )*\n  }\n  \n  void VariableInitializer() :\n  {printDebugInfo(\"VariableInit\");}\n  {\n    \"{\" [ VariableInitializer() ( LOOKAHEAD(2) \",\" VariableInitializer() )* ] [ \",\" ] \"}\"\n  |\n    Expression()\n  }\n\n  /*\n   * Type, name and expression syntax follows.\n   */\n  \n  void Type() :\n  {}\n  {\n    ( PrimitiveType() | Name() ) ( \"[\" \"]\" )*\n  }\n  \n  void PrimitiveType() :\n  {}\n  {\n    \"boolean\"\n  |\n    \"char\"\n  |\n    \"byte\"\n  |\n    \"short\"\n  |\n    \"int\"\n  |\n    \"long\"\n  |\n    \"float\"\n  |\n    \"double\"\n  }\n  \n  void Name() :\n  /*\n   * A lookahead of 2 is required below since \"Name\" can be followed\n   * by a \".*\" when used in the context of an \"ImportDeclaration\".\n   */\n  {}\n  {\n    <IDENTIFIER>\n    ( LOOKAHEAD(2) \".\" <IDENTIFIER>\n    )*\n  }\n  \n  void NameList() :\n  {}\n  {\n    Name()\n    ( \",\" Name()\n    )*\n  }\n  \n  \n  /*\n   * Expression syntax follows.\n   */\n  \n  void Expression() :\n  {printDebugInfo(\"Expression\");}\n  {\n    LOOKAHEAD( PrimaryExpression() AssignmentOperator() )\n    Assignment()\n  }\n  \n  void Assignment() :\n  {printDebugInfo(\"Assignment\");}\n  {\n    PrimaryExpression() AssignmentOperator() Expression()\n  }\n  \n  void AssignmentOperator() :\n  {}\n  {\n    \"=\" | \"*=\" | \"/=\" | \"%=\" | \"+=\" | \"-=\" | \"<<=\" | \">>=\" | \">>>=\" | \"&=\" | \"^=\" | \"|=\"\n  }\n\n\n  void PrimaryExpression() :\n  {}\n  {\n    PrimaryPrefix() ( PrimarySuffix() )*\n  }\n  \n  void PrimaryPrefix() :\n  {}\n  {\n    Literal()\n  |\n    Name()\n  |\n    \"this\"\n  |\n    \"super\" \".\" <IDENTIFIER>\n  |\n    \"(\" Expression() \")\"\n  |\n    AllocationExpression()\n  }\n  \n  void PrimarySuffix() :\n  {}\n  {\n    \"[\" Expression() \"]\"\n  |\n    \".\" <IDENTIFIER>\n  |\n    Arguments()\n  }\n  \n  void Literal() :\n  {}\n  {\n    <INTEGER_LITERAL>\n  |\n    <FLOATING_POINT_LITERAL>\n  |\n    <CHARACTER_LITERAL>\n  |\n    <STRING_LITERAL>\n  |\n    BooleanLiteral()\n  |\n    NullLiteral()\n  }\n  \n  void BooleanLiteral() :\n  {}\n  {\n    \"true\"\n  |\n    \"false\"\n  }\n  \n  void NullLiteral() :\n  {}\n  {\n    \"null\"\n  }\n  \n  void Arguments() :\n  {}\n  {\n    \"(\" [ ArgumentList() ] \")\"\n  }\n  \n  void ArgumentList() :\n  {}\n  {\n    Expression() ( \",\" Expression() )*\n  }\n  \n  void AllocationExpression() :\n  {}\n  {\n    LOOKAHEAD(2)\n    \"new\" PrimitiveType() ArrayDimensions()\n  |\n    \"new\" Name() ( Arguments() | ArrayDimensions() )\n  }\n  \n  /*\n   * The second LOOKAHEAD specification below is to parse to PrimarySuffix\n   * if there is an expression between the \"[...]\".\n   */\n  void ArrayDimensions() :\n  {}\n  {\n    ( LOOKAHEAD(2) \"[\" Expression() \"]\" )+ ( LOOKAHEAD(2) \"[\" \"]\" )*\n  }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CGOL3.jj b/CGOL3.jj
--- a/CGOL3.jj	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/CGOL3.jj	(date 1683051228656)
@@ -339,13 +339,13 @@
   {
     ( "abstract" | "final" | "public" )*
     "class" <IDENTIFIER> [ "extends" Name() ] [ "implements" NameList() ]
-    "{" ( ClassBodyDeclaration() )* "}"
+    "{" ClassBodyDeclaration()  "}"
   }
   
   void ClassBodyDeclaration() :
   {printDebugInfo("ClassBodyDeclaration");}
   {
-    FieldDeclaration()
+    (FieldDeclaration())*
   }
   
 
Index: syntaxtree/ClassDeclaration.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage syntaxtree;\n\n/**\n * Grammar production:\n * f0 -> ( \"abstract\" | \"final\" | \"public\" )*\n * f1 -> \"class\"\n * f2 -> <IDENTIFIER>\n * f3 -> [ \"extends\" Name() ]\n * f4 -> [ \"implements\" NameList() ]\n * f5 -> \"{\"\n * f6 -> ( ClassBodyDeclaration() )*\n * f7 -> \"}\"\n */\npublic class ClassDeclaration implements Node {\n   public NodeListOptional f0;\n   public NodeToken f1;\n   public NodeToken f2;\n   public NodeOptional f3;\n   public NodeOptional f4;\n   public NodeToken f5;\n   public NodeListOptional f6;\n   public NodeToken f7;\n\n   public ClassDeclaration(NodeListOptional n0, NodeToken n1, NodeToken n2, NodeOptional n3, NodeOptional n4, NodeToken n5, NodeListOptional n6, NodeToken n7) {\n      f0 = n0;\n      f1 = n1;\n      f2 = n2;\n      f3 = n3;\n      f4 = n4;\n      f5 = n5;\n      f6 = n6;\n      f7 = n7;\n   }\n\n   public ClassDeclaration(NodeListOptional n0, NodeToken n1, NodeOptional n2, NodeOptional n3, NodeListOptional n4) {\n      f0 = n0;\n      f1 = new NodeToken(\"class\");\n      f2 = n1;\n      f3 = n2;\n      f4 = n3;\n      f5 = new NodeToken(\"{\");\n      f6 = n4;\n      f7 = new NodeToken(\"}\");\n   }\n\n   public void accept(visitor.Visitor v) {\n      v.visit(this);\n   }\n   public <R,A> R accept(visitor.GJVisitor<R,A> v, A argu) {\n      return v.visit(this,argu);\n   }\n   public <R> R accept(visitor.GJNoArguVisitor<R> v) {\n      return v.visit(this);\n   }\n   public <A> void accept(visitor.GJVoidVisitor<A> v, A argu) {\n      v.visit(this,argu);\n   }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/syntaxtree/ClassDeclaration.java b/syntaxtree/ClassDeclaration.java
--- a/syntaxtree/ClassDeclaration.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/syntaxtree/ClassDeclaration.java	(date 1683052205939)
@@ -12,7 +12,7 @@
  * f3 -> [ "extends" Name() ]
  * f4 -> [ "implements" NameList() ]
  * f5 -> "{"
- * f6 -> ( ClassBodyDeclaration() )*
+ * f6 -> ClassBodyDeclaration()
  * f7 -> "}"
  */
 public class ClassDeclaration implements Node {
@@ -22,10 +22,10 @@
    public NodeOptional f3;
    public NodeOptional f4;
    public NodeToken f5;
-   public NodeListOptional f6;
+   public ClassBodyDeclaration f6;
    public NodeToken f7;
 
-   public ClassDeclaration(NodeListOptional n0, NodeToken n1, NodeToken n2, NodeOptional n3, NodeOptional n4, NodeToken n5, NodeListOptional n6, NodeToken n7) {
+   public ClassDeclaration(NodeListOptional n0, NodeToken n1, NodeToken n2, NodeOptional n3, NodeOptional n4, NodeToken n5, ClassBodyDeclaration n6, NodeToken n7) {
       f0 = n0;
       f1 = n1;
       f2 = n2;
@@ -36,7 +36,7 @@
       f7 = n7;
    }
 
-   public ClassDeclaration(NodeListOptional n0, NodeToken n1, NodeOptional n2, NodeOptional n3, NodeListOptional n4) {
+   public ClassDeclaration(NodeListOptional n0, NodeToken n1, NodeOptional n2, NodeOptional n3, ClassBodyDeclaration n4) {
       f0 = n0;
       f1 = new NodeToken("class");
       f2 = n1;
Index: MyVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Generated by JTB 1.3.2\n// modified in cooporation with ChatGPT\n\n\n\nimport syntaxtree.*;\nimport visitor.DepthFirstVisitor;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class MyVisitor extends DepthFirstVisitor {\n   private String output;\n   private String classBodyOutput = \"\";\n   private String fileName;\n\n   public MyVisitor() {\n      output = \"\";\n   }\n\n   private String capitalizeFirstLetter(String input) {\n      return input.substring(0, 1).toUpperCase() + input.substring(1);\n   }\n\n   public void visit(ClassDeclaration n) {\n      fileName = n.f2.toString() + \".java\";\n\n      output += \"package outputs;\\n\\n\";\n      output += ((NodeChoice) n.f0.nodes.get(0)).choice.toString() + \" \";\n      output += n.f1.toString() + \" \";\n      output += n.f2.toString() + \" \";\n      output += n.f5.toString() + \"\\n\";\n\n      n.f6.accept(this);\n      output += n.f7.toString();\n\n      try {\n         writeOutputToFile();\n      } catch (IOException e) {\n         e.printStackTrace();\n      }\n   }\n\n   public void visit(FieldDeclaration n) {\n      classBodyOutput = \"\";\n      classBodyOutput += ((field_modifier) n.f0.nodes.get(0)).f0.choice + \" \";\n      classBodyOutput += ((Name) n.f1.f0.choice).f0 + \" \";\n      classBodyOutput += n.f2.toString() + \" \";\n      n.f3.accept(this);\n      output += classBodyOutput;\n   }\n\n   public void visit(field_body n) {\n      if (n.f0.which == 0 || n.f0.which == 1) {\n         NodeSequence seq = (NodeSequence) n.f0.choice;\n         accessor_declarations accDeclarations = (accessor_declarations) seq.elementAt(1);\n         accDeclarations.accept(this);\n      } else {\n         classBodyOutput += \";\\n\";\n      }\n   }\n\n   public void visit(accessor_declarations n) {\n      String getter = \"\";\n      String setter = \"\";\n\n      NodeChoice choice = n.f0;\n      switch (choice.which) {\n         case 0:\n            accessor_get_declaration getDecl = (accessor_get_declaration) ((NodeSequence) choice.choice).elementAt(0);\n            getter = \"public \" + classBodyOutput.trim().split(\" \")[1] + \" get\" + capitalizeFirstLetter(getDecl.f1.toString()) + \"() { return \" + getDecl.f1.toString() + \"; }\\n\";\n            break;\n         case 1:\n            accessor_set_declaration setDecl = (accessor_set_declaration) ((NodeSequence) choice.choice).elementAt(0);\n            setter = \"public void set\" + capitalizeFirstLetter(setDecl.f1.toString()) + \"(\" + classBodyOutput.trim().split(\" \")[1] + \" value) { this.\" + setDecl.f1.toString() + \" = value; }\\n\";\n            break;\n      }\n\n      classBodyOutput += \"{\\n\" + getter + setter + \"}\\n\";\n   }\n\n   public void writeOutputToFile() throws IOException {\n      Files.write(Paths.get(\"outputs/\" + fileName), output.getBytes());\n   }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/MyVisitor.java b/MyVisitor.java
--- a/MyVisitor.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/MyVisitor.java	(date 1683052205666)
@@ -1,8 +1,8 @@
-// Generated by JTB 1.3.2
-// modified in cooporation with ChatGPT
-
-
-
+import syntaxtree.*;
+import visitor.DepthFirstVisitor;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
 import syntaxtree.*;
 import visitor.DepthFirstVisitor;
 import java.io.IOException;
@@ -41,13 +41,19 @@
       }
    }
 
+   public void visit(ClassBodyDeclaration n) {
+      for (Node node : n.f0.nodes) {
+         node.accept(this);
+      }
+   }
+
    public void visit(FieldDeclaration n) {
-      classBodyOutput = "";
-      classBodyOutput += ((field_modifier) n.f0.nodes.get(0)).f0.choice + " ";
-      classBodyOutput += ((Name) n.f1.f0.choice).f0 + " ";
-      classBodyOutput += n.f2.toString() + " ";
+      String fieldoutput = "";
+      fieldoutput += ((field_modifier) n.f0.nodes.get(0)).f0.choice + " ";
+      fieldoutput += ((Name) n.f1.f0.choice).f0 + " ";
+      fieldoutput +=  n.f2.toString() + " ";
       n.f3.accept(this);
-      output += classBodyOutput;
+      output += fieldoutput;
    }
 
    public void visit(field_body n) {
@@ -68,7 +74,7 @@
       switch (choice.which) {
          case 0:
             accessor_get_declaration getDecl = (accessor_get_declaration) ((NodeSequence) choice.choice).elementAt(0);
-            getter = "public " + classBodyOutput.trim().split(" ")[1] + " get" + capitalizeFirstLetter(getDecl.f1.toString()) + "() { return " + getDecl.f1.toString() + "; }\n";
+            getter = "public " + classBodyOutput.trim().split(" ") + " get" + capitalizeFirstLetter(getDecl.f1.toString()) + "() { return " + getDecl.f1.toString() + "; }\n";
             break;
          case 1:
             accessor_set_declaration setDecl = (accessor_set_declaration) ((NodeSequence) choice.choice).elementAt(0);
Index: visitor/GJNoArguDepthFirst.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage visitor;\nimport syntaxtree.*;\nimport java.util.*;\n\n/**\n * Provides default methods which visit each node in the tree in depth-first\n * order.  Your visitors may extend this class.\n */\npublic class GJNoArguDepthFirst<R> implements GJNoArguVisitor<R> {\n   //\n   // Auto class visitors--probably don't need to be overridden.\n   //\n   public R visit(NodeList n) {\n      R _ret=null;\n      int _count=0;\n      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {\n         e.nextElement().accept(this);\n         _count++;\n      }\n      return _ret;\n   }\n\n   public R visit(NodeListOptional n) {\n      if ( n.present() ) {\n         R _ret=null;\n         int _count=0;\n         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {\n            e.nextElement().accept(this);\n            _count++;\n         }\n         return _ret;\n      }\n      else\n         return null;\n   }\n\n   public R visit(NodeOptional n) {\n      if ( n.present() )\n         return n.node.accept(this);\n      else\n         return null;\n   }\n\n   public R visit(NodeSequence n) {\n      R _ret=null;\n      int _count=0;\n      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {\n         e.nextElement().accept(this);\n         _count++;\n      }\n      return _ret;\n   }\n\n   public R visit(NodeToken n) { return null; }\n\n   //\n   // User-generated visitor methods below\n   //\n\n   /**\n    * f0 -> ( TypeDeclaration() )*\n    * f1 -> <EOF>\n    */\n   public R visit(CompilationUnit n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ClassDeclaration()\n    *       | \";\"\n    */\n   public R visit(TypeDeclaration n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"abstract\" | \"final\" | \"public\" )*\n    * f1 -> \"class\"\n    * f2 -> <IDENTIFIER>\n    * f3 -> [ \"extends\" Name() ]\n    * f4 -> [ \"implements\" NameList() ]\n    * f5 -> \"{\"\n    * f6 -> ( ClassBodyDeclaration() )*\n    * f7 -> \"}\"\n    */\n   public R visit(ClassDeclaration n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      n.f3.accept(this);\n      n.f4.accept(this);\n      n.f5.accept(this);\n      n.f6.accept(this);\n      n.f7.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> FieldDeclaration()\n    */\n   public R visit(ClassBodyDeclaration n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( field_modifier() )*\n    * f1 -> Type()\n    * f2 -> <IDENTIFIER>\n    * f3 -> field_body()\n    */\n   public R visit(FieldDeclaration n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      n.f3.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"new\"\n    *       | \"public\"\n    *       | \"protected\"\n    *       | \"private\"\n    *       | \"static\"\n    *       | \"abstract\"\n    */\n   public R visit(field_modifier n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"=\" Expression() ( \"{\" accessor_declarations() \"}\" | \";\" ) | \"{\" accessor_declarations() \"}\" | \";\" )\n    */\n   public R visit(field_body n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( accessor_get_declaration() ( accessor_set_declaration() )? | accessor_set_declaration() ( accessor_get_declaration() )? )\n    */\n   public R visit(accessor_declarations n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <GET>\n    * f2 -> \";\"\n    */\n   public R visit(accessor_get_declaration n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <SET>\n    * f2 -> \";\"\n    */\n   public R visit(accessor_set_declaration n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> VariableDeclaratorId()\n    * f1 -> [ \"=\" VariableInitializer() ]\n    */\n   public R visit(VariableDeclarator n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(VariableDeclaratorId n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"{\" [ VariableInitializer() ( \",\" VariableInitializer() )* ] [ \",\" ] \"}\"\n    *       | Expression()\n    */\n   public R visit(VariableInitializer n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( PrimitiveType() | Name() )\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(Type n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"boolean\"\n    *       | \"char\"\n    *       | \"byte\"\n    *       | \"short\"\n    *       | \"int\"\n    *       | \"long\"\n    *       | \"float\"\n    *       | \"double\"\n    */\n   public R visit(PrimitiveType n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \".\" <IDENTIFIER> )*\n    */\n   public R visit(Name n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> Name()\n    * f1 -> ( \",\" Name() )*\n    */\n   public R visit(NameList n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      return _ret;\n   }\n\n   /**\nAssignment()\n    */\n   public R visit(Expression n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> PrimaryExpression()\n    * f1 -> AssignmentOperator()\n    * f2 -> Expression()\n    */\n   public R visit(Assignment n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"=\"\n    *       | \"*=\"\n    *       | \"/=\"\n    *       | \"%=\"\n    *       | \"+=\"\n    *       | \"-=\"\n    *       | \"<<=\"\n    *       | \">>=\"\n    *       | \">>>=\"\n    *       | \"&=\"\n    *       | \"^=\"\n    *       | \"|=\"\n    */\n   public R visit(AssignmentOperator n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> PrimaryPrefix()\n    * f1 -> ( PrimarySuffix() )*\n    */\n   public R visit(PrimaryExpression n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> Literal()\n    *       | Name()\n    *       | \"this\"\n    *       | \"super\" \".\" <IDENTIFIER>\n    *       | \"(\" Expression() \")\"\n    *       | AllocationExpression()\n    */\n   public R visit(PrimaryPrefix n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"[\" Expression() \"]\"\n    *       | \".\" <IDENTIFIER>\n    *       | Arguments()\n    */\n   public R visit(PrimarySuffix n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> <INTEGER_LITERAL>\n    *       | <FLOATING_POINT_LITERAL>\n    *       | <CHARACTER_LITERAL>\n    *       | <STRING_LITERAL>\n    *       | BooleanLiteral()\n    *       | NullLiteral()\n    */\n   public R visit(Literal n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"true\"\n    *       | \"false\"\n    */\n   public R visit(BooleanLiteral n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"null\"\n    */\n   public R visit(NullLiteral n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"(\"\n    * f1 -> [ ArgumentList() ]\n    * f2 -> \")\"\n    */\n   public R visit(Arguments n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> Expression()\n    * f1 -> ( \",\" Expression() )*\n    */\n   public R visit(ArgumentList n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"new\" PrimitiveType() ArrayDimensions()\n    *       | \"new\" Name() ( Arguments() | ArrayDimensions() )\n    */\n   public R visit(AllocationExpression n) {\n      R _ret=null;\n      n.f0.accept(this);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"[\" Expression() \"]\" )+\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(ArrayDimensions n) {\n      R _ret=null;\n      n.f0.accept(this);\n      n.f1.accept(this);\n      return _ret;\n   }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/visitor/GJNoArguDepthFirst.java b/visitor/GJNoArguDepthFirst.java
--- a/visitor/GJNoArguDepthFirst.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/visitor/GJNoArguDepthFirst.java	(date 1683052205969)
@@ -89,7 +89,7 @@
     * f3 -> [ "extends" Name() ]
     * f4 -> [ "implements" NameList() ]
     * f5 -> "{"
-    * f6 -> ( ClassBodyDeclaration() )*
+    * f6 -> ClassBodyDeclaration()
     * f7 -> "}"
     */
    public R visit(ClassDeclaration n) {
@@ -106,7 +106,7 @@
    }
 
    /**
-    * f0 -> FieldDeclaration()
+    * f0 -> ( FieldDeclaration() )*
     */
    public R visit(ClassBodyDeclaration n) {
       R _ret=null;
Index: visitor/GJVoidVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage visitor;\nimport syntaxtree.*;\nimport java.util.*;\n\n/**\n * All GJ void visitors must implement this interface.\n */\n\npublic interface GJVoidVisitor<A> {\n\n   //\n   // GJ void Auto class visitors\n   //\n\n   public void visit(NodeList n, A argu);\n   public void visit(NodeListOptional n, A argu);\n   public void visit(NodeOptional n, A argu);\n   public void visit(NodeSequence n, A argu);\n   public void visit(NodeToken n, A argu);\n\n   //\n   // User-generated visitor methods below\n   //\n\n   /**\n    * f0 -> ( TypeDeclaration() )*\n    * f1 -> <EOF>\n    */\n   public void visit(CompilationUnit n, A argu);\n\n   /**\n    * f0 -> ClassDeclaration()\n    *       | \";\"\n    */\n   public void visit(TypeDeclaration n, A argu);\n\n   /**\n    * f0 -> ( \"abstract\" | \"final\" | \"public\" )*\n    * f1 -> \"class\"\n    * f2 -> <IDENTIFIER>\n    * f3 -> [ \"extends\" Name() ]\n    * f4 -> [ \"implements\" NameList() ]\n    * f5 -> \"{\"\n    * f6 -> ( ClassBodyDeclaration() )*\n    * f7 -> \"}\"\n    */\n   public void visit(ClassDeclaration n, A argu);\n\n   /**\n    * f0 -> FieldDeclaration()\n    */\n   public void visit(ClassBodyDeclaration n, A argu);\n\n   /**\n    * f0 -> ( field_modifier() )*\n    * f1 -> Type()\n    * f2 -> <IDENTIFIER>\n    * f3 -> field_body()\n    */\n   public void visit(FieldDeclaration n, A argu);\n\n   /**\n    * f0 -> \"new\"\n    *       | \"public\"\n    *       | \"protected\"\n    *       | \"private\"\n    *       | \"static\"\n    *       | \"abstract\"\n    */\n   public void visit(field_modifier n, A argu);\n\n   /**\n    * f0 -> ( \"=\" Expression() ( \"{\" accessor_declarations() \"}\" | \";\" ) | \"{\" accessor_declarations() \"}\" | \";\" )\n    */\n   public void visit(field_body n, A argu);\n\n   /**\n    * f0 -> ( accessor_get_declaration() ( accessor_set_declaration() )? | accessor_set_declaration() ( accessor_get_declaration() )? )\n    */\n   public void visit(accessor_declarations n, A argu);\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <GET>\n    * f2 -> \";\"\n    */\n   public void visit(accessor_get_declaration n, A argu);\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <SET>\n    * f2 -> \";\"\n    */\n   public void visit(accessor_set_declaration n, A argu);\n\n   /**\n    * f0 -> VariableDeclaratorId()\n    * f1 -> [ \"=\" VariableInitializer() ]\n    */\n   public void visit(VariableDeclarator n, A argu);\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(VariableDeclaratorId n, A argu);\n\n   /**\n    * f0 -> \"{\" [ VariableInitializer() ( \",\" VariableInitializer() )* ] [ \",\" ] \"}\"\n    *       | Expression()\n    */\n   public void visit(VariableInitializer n, A argu);\n\n   /**\n    * f0 -> ( PrimitiveType() | Name() )\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(Type n, A argu);\n\n   /**\n    * f0 -> \"boolean\"\n    *       | \"char\"\n    *       | \"byte\"\n    *       | \"short\"\n    *       | \"int\"\n    *       | \"long\"\n    *       | \"float\"\n    *       | \"double\"\n    */\n   public void visit(PrimitiveType n, A argu);\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \".\" <IDENTIFIER> )*\n    */\n   public void visit(Name n, A argu);\n\n   /**\n    * f0 -> Name()\n    * f1 -> ( \",\" Name() )*\n    */\n   public void visit(NameList n, A argu);\n\n   /**\nAssignment()\n    */\n   public void visit(Expression n, A argu);\n\n   /**\n    * f0 -> PrimaryExpression()\n    * f1 -> AssignmentOperator()\n    * f2 -> Expression()\n    */\n   public void visit(Assignment n, A argu);\n\n   /**\n    * f0 -> \"=\"\n    *       | \"*=\"\n    *       | \"/=\"\n    *       | \"%=\"\n    *       | \"+=\"\n    *       | \"-=\"\n    *       | \"<<=\"\n    *       | \">>=\"\n    *       | \">>>=\"\n    *       | \"&=\"\n    *       | \"^=\"\n    *       | \"|=\"\n    */\n   public void visit(AssignmentOperator n, A argu);\n\n   /**\n    * f0 -> PrimaryPrefix()\n    * f1 -> ( PrimarySuffix() )*\n    */\n   public void visit(PrimaryExpression n, A argu);\n\n   /**\n    * f0 -> Literal()\n    *       | Name()\n    *       | \"this\"\n    *       | \"super\" \".\" <IDENTIFIER>\n    *       | \"(\" Expression() \")\"\n    *       | AllocationExpression()\n    */\n   public void visit(PrimaryPrefix n, A argu);\n\n   /**\n    * f0 -> \"[\" Expression() \"]\"\n    *       | \".\" <IDENTIFIER>\n    *       | Arguments()\n    */\n   public void visit(PrimarySuffix n, A argu);\n\n   /**\n    * f0 -> <INTEGER_LITERAL>\n    *       | <FLOATING_POINT_LITERAL>\n    *       | <CHARACTER_LITERAL>\n    *       | <STRING_LITERAL>\n    *       | BooleanLiteral()\n    *       | NullLiteral()\n    */\n   public void visit(Literal n, A argu);\n\n   /**\n    * f0 -> \"true\"\n    *       | \"false\"\n    */\n   public void visit(BooleanLiteral n, A argu);\n\n   /**\n    * f0 -> \"null\"\n    */\n   public void visit(NullLiteral n, A argu);\n\n   /**\n    * f0 -> \"(\"\n    * f1 -> [ ArgumentList() ]\n    * f2 -> \")\"\n    */\n   public void visit(Arguments n, A argu);\n\n   /**\n    * f0 -> Expression()\n    * f1 -> ( \",\" Expression() )*\n    */\n   public void visit(ArgumentList n, A argu);\n\n   /**\n    * f0 -> \"new\" PrimitiveType() ArrayDimensions()\n    *       | \"new\" Name() ( Arguments() | ArrayDimensions() )\n    */\n   public void visit(AllocationExpression n, A argu);\n\n   /**\n    * f0 -> ( \"[\" Expression() \"]\" )+\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(ArrayDimensions n, A argu);\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/visitor/GJVoidVisitor.java b/visitor/GJVoidVisitor.java
--- a/visitor/GJVoidVisitor.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/visitor/GJVoidVisitor.java	(date 1683052205959)
@@ -45,13 +45,13 @@
     * f3 -> [ "extends" Name() ]
     * f4 -> [ "implements" NameList() ]
     * f5 -> "{"
-    * f6 -> ( ClassBodyDeclaration() )*
+    * f6 -> ClassBodyDeclaration()
     * f7 -> "}"
     */
    public void visit(ClassDeclaration n, A argu);
 
    /**
-    * f0 -> FieldDeclaration()
+    * f0 -> ( FieldDeclaration() )*
     */
    public void visit(ClassBodyDeclaration n, A argu);
 
Index: visitor/GJDepthFirst.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage visitor;\nimport syntaxtree.*;\nimport java.util.*;\n\n/**\n * Provides default methods which visit each node in the tree in depth-first\n * order.  Your visitors may extend this class.\n */\npublic class GJDepthFirst<R,A> implements GJVisitor<R,A> {\n   //\n   // Auto class visitors--probably don't need to be overridden.\n   //\n   public R visit(NodeList n, A argu) {\n      R _ret=null;\n      int _count=0;\n      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {\n         e.nextElement().accept(this,argu);\n         _count++;\n      }\n      return _ret;\n   }\n\n   public R visit(NodeListOptional n, A argu) {\n      if ( n.present() ) {\n         R _ret=null;\n         int _count=0;\n         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {\n            e.nextElement().accept(this,argu);\n            _count++;\n         }\n         return _ret;\n      }\n      else\n         return null;\n   }\n\n   public R visit(NodeOptional n, A argu) {\n      if ( n.present() )\n         return n.node.accept(this,argu);\n      else\n         return null;\n   }\n\n   public R visit(NodeSequence n, A argu) {\n      R _ret=null;\n      int _count=0;\n      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {\n         e.nextElement().accept(this,argu);\n         _count++;\n      }\n      return _ret;\n   }\n\n   public R visit(NodeToken n, A argu) { return null; }\n\n   //\n   // User-generated visitor methods below\n   //\n\n   /**\n    * f0 -> ( TypeDeclaration() )*\n    * f1 -> <EOF>\n    */\n   public R visit(CompilationUnit n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ClassDeclaration()\n    *       | \";\"\n    */\n   public R visit(TypeDeclaration n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"abstract\" | \"final\" | \"public\" )*\n    * f1 -> \"class\"\n    * f2 -> <IDENTIFIER>\n    * f3 -> [ \"extends\" Name() ]\n    * f4 -> [ \"implements\" NameList() ]\n    * f5 -> \"{\"\n    * f6 -> ( ClassBodyDeclaration() )*\n    * f7 -> \"}\"\n    */\n   public R visit(ClassDeclaration n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n      n.f3.accept(this, argu);\n      n.f4.accept(this, argu);\n      n.f5.accept(this, argu);\n      n.f6.accept(this, argu);\n      n.f7.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> FieldDeclaration()\n    */\n   public R visit(ClassBodyDeclaration n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( field_modifier() )*\n    * f1 -> Type()\n    * f2 -> <IDENTIFIER>\n    * f3 -> field_body()\n    */\n   public R visit(FieldDeclaration n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n      n.f3.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"new\"\n    *       | \"public\"\n    *       | \"protected\"\n    *       | \"private\"\n    *       | \"static\"\n    *       | \"abstract\"\n    */\n   public R visit(field_modifier n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"=\" Expression() ( \"{\" accessor_declarations() \"}\" | \";\" ) | \"{\" accessor_declarations() \"}\" | \";\" )\n    */\n   public R visit(field_body n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( accessor_get_declaration() ( accessor_set_declaration() )? | accessor_set_declaration() ( accessor_get_declaration() )? )\n    */\n   public R visit(accessor_declarations n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <GET>\n    * f2 -> \";\"\n    */\n   public R visit(accessor_get_declaration n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <SET>\n    * f2 -> \";\"\n    */\n   public R visit(accessor_set_declaration n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> VariableDeclaratorId()\n    * f1 -> [ \"=\" VariableInitializer() ]\n    */\n   public R visit(VariableDeclarator n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(VariableDeclaratorId n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"{\" [ VariableInitializer() ( \",\" VariableInitializer() )* ] [ \",\" ] \"}\"\n    *       | Expression()\n    */\n   public R visit(VariableInitializer n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( PrimitiveType() | Name() )\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(Type n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"boolean\"\n    *       | \"char\"\n    *       | \"byte\"\n    *       | \"short\"\n    *       | \"int\"\n    *       | \"long\"\n    *       | \"float\"\n    *       | \"double\"\n    */\n   public R visit(PrimitiveType n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \".\" <IDENTIFIER> )*\n    */\n   public R visit(Name n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> Name()\n    * f1 -> ( \",\" Name() )*\n    */\n   public R visit(NameList n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      return _ret;\n   }\n\n   /**\nAssignment()\n    */\n   public R visit(Expression n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> PrimaryExpression()\n    * f1 -> AssignmentOperator()\n    * f2 -> Expression()\n    */\n   public R visit(Assignment n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"=\"\n    *       | \"*=\"\n    *       | \"/=\"\n    *       | \"%=\"\n    *       | \"+=\"\n    *       | \"-=\"\n    *       | \"<<=\"\n    *       | \">>=\"\n    *       | \">>>=\"\n    *       | \"&=\"\n    *       | \"^=\"\n    *       | \"|=\"\n    */\n   public R visit(AssignmentOperator n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> PrimaryPrefix()\n    * f1 -> ( PrimarySuffix() )*\n    */\n   public R visit(PrimaryExpression n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> Literal()\n    *       | Name()\n    *       | \"this\"\n    *       | \"super\" \".\" <IDENTIFIER>\n    *       | \"(\" Expression() \")\"\n    *       | AllocationExpression()\n    */\n   public R visit(PrimaryPrefix n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"[\" Expression() \"]\"\n    *       | \".\" <IDENTIFIER>\n    *       | Arguments()\n    */\n   public R visit(PrimarySuffix n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> <INTEGER_LITERAL>\n    *       | <FLOATING_POINT_LITERAL>\n    *       | <CHARACTER_LITERAL>\n    *       | <STRING_LITERAL>\n    *       | BooleanLiteral()\n    *       | NullLiteral()\n    */\n   public R visit(Literal n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"true\"\n    *       | \"false\"\n    */\n   public R visit(BooleanLiteral n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"null\"\n    */\n   public R visit(NullLiteral n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"(\"\n    * f1 -> [ ArgumentList() ]\n    * f2 -> \")\"\n    */\n   public R visit(Arguments n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> Expression()\n    * f1 -> ( \",\" Expression() )*\n    */\n   public R visit(ArgumentList n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> \"new\" PrimitiveType() ArrayDimensions()\n    *       | \"new\" Name() ( Arguments() | ArrayDimensions() )\n    */\n   public R visit(AllocationExpression n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      return _ret;\n   }\n\n   /**\n    * f0 -> ( \"[\" Expression() \"]\" )+\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(ArrayDimensions n, A argu) {\n      R _ret=null;\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      return _ret;\n   }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/visitor/GJDepthFirst.java b/visitor/GJDepthFirst.java
--- a/visitor/GJDepthFirst.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/visitor/GJDepthFirst.java	(date 1683052205966)
@@ -89,7 +89,7 @@
     * f3 -> [ "extends" Name() ]
     * f4 -> [ "implements" NameList() ]
     * f5 -> "{"
-    * f6 -> ( ClassBodyDeclaration() )*
+    * f6 -> ClassBodyDeclaration()
     * f7 -> "}"
     */
    public R visit(ClassDeclaration n, A argu) {
@@ -106,7 +106,7 @@
    }
 
    /**
-    * f0 -> FieldDeclaration()
+    * f0 -> ( FieldDeclaration() )*
     */
    public R visit(ClassBodyDeclaration n, A argu) {
       R _ret=null;
Index: visitor/GJVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage visitor;\nimport syntaxtree.*;\nimport java.util.*;\n\n/**\n * All GJ visitors must implement this interface.\n */\n\npublic interface GJVisitor<R,A> {\n\n   //\n   // GJ Auto class visitors\n   //\n\n   public R visit(NodeList n, A argu);\n   public R visit(NodeListOptional n, A argu);\n   public R visit(NodeOptional n, A argu);\n   public R visit(NodeSequence n, A argu);\n   public R visit(NodeToken n, A argu);\n\n   //\n   // User-generated visitor methods below\n   //\n\n   /**\n    * f0 -> ( TypeDeclaration() )*\n    * f1 -> <EOF>\n    */\n   public R visit(CompilationUnit n, A argu);\n\n   /**\n    * f0 -> ClassDeclaration()\n    *       | \";\"\n    */\n   public R visit(TypeDeclaration n, A argu);\n\n   /**\n    * f0 -> ( \"abstract\" | \"final\" | \"public\" )*\n    * f1 -> \"class\"\n    * f2 -> <IDENTIFIER>\n    * f3 -> [ \"extends\" Name() ]\n    * f4 -> [ \"implements\" NameList() ]\n    * f5 -> \"{\"\n    * f6 -> ( ClassBodyDeclaration() )*\n    * f7 -> \"}\"\n    */\n   public R visit(ClassDeclaration n, A argu);\n\n   /**\n    * f0 -> FieldDeclaration()\n    */\n   public R visit(ClassBodyDeclaration n, A argu);\n\n   /**\n    * f0 -> ( field_modifier() )*\n    * f1 -> Type()\n    * f2 -> <IDENTIFIER>\n    * f3 -> field_body()\n    */\n   public R visit(FieldDeclaration n, A argu);\n\n   /**\n    * f0 -> \"new\"\n    *       | \"public\"\n    *       | \"protected\"\n    *       | \"private\"\n    *       | \"static\"\n    *       | \"abstract\"\n    */\n   public R visit(field_modifier n, A argu);\n\n   /**\n    * f0 -> ( \"=\" Expression() ( \"{\" accessor_declarations() \"}\" | \";\" ) | \"{\" accessor_declarations() \"}\" | \";\" )\n    */\n   public R visit(field_body n, A argu);\n\n   /**\n    * f0 -> ( accessor_get_declaration() ( accessor_set_declaration() )? | accessor_set_declaration() ( accessor_get_declaration() )? )\n    */\n   public R visit(accessor_declarations n, A argu);\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <GET>\n    * f2 -> \";\"\n    */\n   public R visit(accessor_get_declaration n, A argu);\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <SET>\n    * f2 -> \";\"\n    */\n   public R visit(accessor_set_declaration n, A argu);\n\n   /**\n    * f0 -> VariableDeclaratorId()\n    * f1 -> [ \"=\" VariableInitializer() ]\n    */\n   public R visit(VariableDeclarator n, A argu);\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(VariableDeclaratorId n, A argu);\n\n   /**\n    * f0 -> \"{\" [ VariableInitializer() ( \",\" VariableInitializer() )* ] [ \",\" ] \"}\"\n    *       | Expression()\n    */\n   public R visit(VariableInitializer n, A argu);\n\n   /**\n    * f0 -> ( PrimitiveType() | Name() )\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(Type n, A argu);\n\n   /**\n    * f0 -> \"boolean\"\n    *       | \"char\"\n    *       | \"byte\"\n    *       | \"short\"\n    *       | \"int\"\n    *       | \"long\"\n    *       | \"float\"\n    *       | \"double\"\n    */\n   public R visit(PrimitiveType n, A argu);\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \".\" <IDENTIFIER> )*\n    */\n   public R visit(Name n, A argu);\n\n   /**\n    * f0 -> Name()\n    * f1 -> ( \",\" Name() )*\n    */\n   public R visit(NameList n, A argu);\n\n   /**\nAssignment()\n    */\n   public R visit(Expression n, A argu);\n\n   /**\n    * f0 -> PrimaryExpression()\n    * f1 -> AssignmentOperator()\n    * f2 -> Expression()\n    */\n   public R visit(Assignment n, A argu);\n\n   /**\n    * f0 -> \"=\"\n    *       | \"*=\"\n    *       | \"/=\"\n    *       | \"%=\"\n    *       | \"+=\"\n    *       | \"-=\"\n    *       | \"<<=\"\n    *       | \">>=\"\n    *       | \">>>=\"\n    *       | \"&=\"\n    *       | \"^=\"\n    *       | \"|=\"\n    */\n   public R visit(AssignmentOperator n, A argu);\n\n   /**\n    * f0 -> PrimaryPrefix()\n    * f1 -> ( PrimarySuffix() )*\n    */\n   public R visit(PrimaryExpression n, A argu);\n\n   /**\n    * f0 -> Literal()\n    *       | Name()\n    *       | \"this\"\n    *       | \"super\" \".\" <IDENTIFIER>\n    *       | \"(\" Expression() \")\"\n    *       | AllocationExpression()\n    */\n   public R visit(PrimaryPrefix n, A argu);\n\n   /**\n    * f0 -> \"[\" Expression() \"]\"\n    *       | \".\" <IDENTIFIER>\n    *       | Arguments()\n    */\n   public R visit(PrimarySuffix n, A argu);\n\n   /**\n    * f0 -> <INTEGER_LITERAL>\n    *       | <FLOATING_POINT_LITERAL>\n    *       | <CHARACTER_LITERAL>\n    *       | <STRING_LITERAL>\n    *       | BooleanLiteral()\n    *       | NullLiteral()\n    */\n   public R visit(Literal n, A argu);\n\n   /**\n    * f0 -> \"true\"\n    *       | \"false\"\n    */\n   public R visit(BooleanLiteral n, A argu);\n\n   /**\n    * f0 -> \"null\"\n    */\n   public R visit(NullLiteral n, A argu);\n\n   /**\n    * f0 -> \"(\"\n    * f1 -> [ ArgumentList() ]\n    * f2 -> \")\"\n    */\n   public R visit(Arguments n, A argu);\n\n   /**\n    * f0 -> Expression()\n    * f1 -> ( \",\" Expression() )*\n    */\n   public R visit(ArgumentList n, A argu);\n\n   /**\n    * f0 -> \"new\" PrimitiveType() ArrayDimensions()\n    *       | \"new\" Name() ( Arguments() | ArrayDimensions() )\n    */\n   public R visit(AllocationExpression n, A argu);\n\n   /**\n    * f0 -> ( \"[\" Expression() \"]\" )+\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(ArrayDimensions n, A argu);\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/visitor/GJVisitor.java b/visitor/GJVisitor.java
--- a/visitor/GJVisitor.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/visitor/GJVisitor.java	(date 1683052205949)
@@ -45,13 +45,13 @@
     * f3 -> [ "extends" Name() ]
     * f4 -> [ "implements" NameList() ]
     * f5 -> "{"
-    * f6 -> ( ClassBodyDeclaration() )*
+    * f6 -> ClassBodyDeclaration()
     * f7 -> "}"
     */
    public R visit(ClassDeclaration n, A argu);
 
    /**
-    * f0 -> FieldDeclaration()
+    * f0 -> ( FieldDeclaration() )*
     */
    public R visit(ClassBodyDeclaration n, A argu);
 
Index: visitor/Visitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage visitor;\nimport syntaxtree.*;\nimport java.util.*;\n\n/**\n * All void visitors must implement this interface.\n */\n\npublic interface Visitor {\n\n   //\n   // void Auto class visitors\n   //\n\n   public void visit(NodeList n);\n   public void visit(NodeListOptional n);\n   public void visit(NodeOptional n);\n   public void visit(NodeSequence n);\n   public void visit(NodeToken n);\n\n   //\n   // User-generated visitor methods below\n   //\n\n   /**\n    * f0 -> ( TypeDeclaration() )*\n    * f1 -> <EOF>\n    */\n   public void visit(CompilationUnit n);\n\n   /**\n    * f0 -> ClassDeclaration()\n    *       | \";\"\n    */\n   public void visit(TypeDeclaration n);\n\n   /**\n    * f0 -> ( \"abstract\" | \"final\" | \"public\" )*\n    * f1 -> \"class\"\n    * f2 -> <IDENTIFIER>\n    * f3 -> [ \"extends\" Name() ]\n    * f4 -> [ \"implements\" NameList() ]\n    * f5 -> \"{\"\n    * f6 -> ( ClassBodyDeclaration() )*\n    * f7 -> \"}\"\n    */\n   public void visit(ClassDeclaration n);\n\n   /**\n    * f0 -> FieldDeclaration()\n    */\n   public void visit(ClassBodyDeclaration n);\n\n   /**\n    * f0 -> ( field_modifier() )*\n    * f1 -> Type()\n    * f2 -> <IDENTIFIER>\n    * f3 -> field_body()\n    */\n   public void visit(FieldDeclaration n);\n\n   /**\n    * f0 -> \"new\"\n    *       | \"public\"\n    *       | \"protected\"\n    *       | \"private\"\n    *       | \"static\"\n    *       | \"abstract\"\n    */\n   public void visit(field_modifier n);\n\n   /**\n    * f0 -> ( \"=\" Expression() ( \"{\" accessor_declarations() \"}\" | \";\" ) | \"{\" accessor_declarations() \"}\" | \";\" )\n    */\n   public void visit(field_body n);\n\n   /**\n    * f0 -> ( accessor_get_declaration() ( accessor_set_declaration() )? | accessor_set_declaration() ( accessor_get_declaration() )? )\n    */\n   public void visit(accessor_declarations n);\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <GET>\n    * f2 -> \";\"\n    */\n   public void visit(accessor_get_declaration n);\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <SET>\n    * f2 -> \";\"\n    */\n   public void visit(accessor_set_declaration n);\n\n   /**\n    * f0 -> VariableDeclaratorId()\n    * f1 -> [ \"=\" VariableInitializer() ]\n    */\n   public void visit(VariableDeclarator n);\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(VariableDeclaratorId n);\n\n   /**\n    * f0 -> \"{\" [ VariableInitializer() ( \",\" VariableInitializer() )* ] [ \",\" ] \"}\"\n    *       | Expression()\n    */\n   public void visit(VariableInitializer n);\n\n   /**\n    * f0 -> ( PrimitiveType() | Name() )\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(Type n);\n\n   /**\n    * f0 -> \"boolean\"\n    *       | \"char\"\n    *       | \"byte\"\n    *       | \"short\"\n    *       | \"int\"\n    *       | \"long\"\n    *       | \"float\"\n    *       | \"double\"\n    */\n   public void visit(PrimitiveType n);\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \".\" <IDENTIFIER> )*\n    */\n   public void visit(Name n);\n\n   /**\n    * f0 -> Name()\n    * f1 -> ( \",\" Name() )*\n    */\n   public void visit(NameList n);\n\n   /**\nAssignment()\n    */\n   public void visit(Expression n);\n\n   /**\n    * f0 -> PrimaryExpression()\n    * f1 -> AssignmentOperator()\n    * f2 -> Expression()\n    */\n   public void visit(Assignment n);\n\n   /**\n    * f0 -> \"=\"\n    *       | \"*=\"\n    *       | \"/=\"\n    *       | \"%=\"\n    *       | \"+=\"\n    *       | \"-=\"\n    *       | \"<<=\"\n    *       | \">>=\"\n    *       | \">>>=\"\n    *       | \"&=\"\n    *       | \"^=\"\n    *       | \"|=\"\n    */\n   public void visit(AssignmentOperator n);\n\n   /**\n    * f0 -> PrimaryPrefix()\n    * f1 -> ( PrimarySuffix() )*\n    */\n   public void visit(PrimaryExpression n);\n\n   /**\n    * f0 -> Literal()\n    *       | Name()\n    *       | \"this\"\n    *       | \"super\" \".\" <IDENTIFIER>\n    *       | \"(\" Expression() \")\"\n    *       | AllocationExpression()\n    */\n   public void visit(PrimaryPrefix n);\n\n   /**\n    * f0 -> \"[\" Expression() \"]\"\n    *       | \".\" <IDENTIFIER>\n    *       | Arguments()\n    */\n   public void visit(PrimarySuffix n);\n\n   /**\n    * f0 -> <INTEGER_LITERAL>\n    *       | <FLOATING_POINT_LITERAL>\n    *       | <CHARACTER_LITERAL>\n    *       | <STRING_LITERAL>\n    *       | BooleanLiteral()\n    *       | NullLiteral()\n    */\n   public void visit(Literal n);\n\n   /**\n    * f0 -> \"true\"\n    *       | \"false\"\n    */\n   public void visit(BooleanLiteral n);\n\n   /**\n    * f0 -> \"null\"\n    */\n   public void visit(NullLiteral n);\n\n   /**\n    * f0 -> \"(\"\n    * f1 -> [ ArgumentList() ]\n    * f2 -> \")\"\n    */\n   public void visit(Arguments n);\n\n   /**\n    * f0 -> Expression()\n    * f1 -> ( \",\" Expression() )*\n    */\n   public void visit(ArgumentList n);\n\n   /**\n    * f0 -> \"new\" PrimitiveType() ArrayDimensions()\n    *       | \"new\" Name() ( Arguments() | ArrayDimensions() )\n    */\n   public void visit(AllocationExpression n);\n\n   /**\n    * f0 -> ( \"[\" Expression() \"]\" )+\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(ArrayDimensions n);\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/visitor/Visitor.java b/visitor/Visitor.java
--- a/visitor/Visitor.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/visitor/Visitor.java	(date 1683052205952)
@@ -45,13 +45,13 @@
     * f3 -> [ "extends" Name() ]
     * f4 -> [ "implements" NameList() ]
     * f5 -> "{"
-    * f6 -> ( ClassBodyDeclaration() )*
+    * f6 -> ClassBodyDeclaration()
     * f7 -> "}"
     */
    public void visit(ClassDeclaration n);
 
    /**
-    * f0 -> FieldDeclaration()
+    * f0 -> ( FieldDeclaration() )*
     */
    public void visit(ClassBodyDeclaration n);
 
Index: visitor/GJNoArguVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage visitor;\nimport syntaxtree.*;\nimport java.util.*;\n\n/**\n * All GJ visitors with no argument must implement this interface.\n */\n\npublic interface GJNoArguVisitor<R> {\n\n   //\n   // GJ Auto class visitors with no argument\n   //\n\n   public R visit(NodeList n);\n   public R visit(NodeListOptional n);\n   public R visit(NodeOptional n);\n   public R visit(NodeSequence n);\n   public R visit(NodeToken n);\n\n   //\n   // User-generated visitor methods below\n   //\n\n   /**\n    * f0 -> ( TypeDeclaration() )*\n    * f1 -> <EOF>\n    */\n   public R visit(CompilationUnit n);\n\n   /**\n    * f0 -> ClassDeclaration()\n    *       | \";\"\n    */\n   public R visit(TypeDeclaration n);\n\n   /**\n    * f0 -> ( \"abstract\" | \"final\" | \"public\" )*\n    * f1 -> \"class\"\n    * f2 -> <IDENTIFIER>\n    * f3 -> [ \"extends\" Name() ]\n    * f4 -> [ \"implements\" NameList() ]\n    * f5 -> \"{\"\n    * f6 -> ( ClassBodyDeclaration() )*\n    * f7 -> \"}\"\n    */\n   public R visit(ClassDeclaration n);\n\n   /**\n    * f0 -> FieldDeclaration()\n    */\n   public R visit(ClassBodyDeclaration n);\n\n   /**\n    * f0 -> ( field_modifier() )*\n    * f1 -> Type()\n    * f2 -> <IDENTIFIER>\n    * f3 -> field_body()\n    */\n   public R visit(FieldDeclaration n);\n\n   /**\n    * f0 -> \"new\"\n    *       | \"public\"\n    *       | \"protected\"\n    *       | \"private\"\n    *       | \"static\"\n    *       | \"abstract\"\n    */\n   public R visit(field_modifier n);\n\n   /**\n    * f0 -> ( \"=\" Expression() ( \"{\" accessor_declarations() \"}\" | \";\" ) | \"{\" accessor_declarations() \"}\" | \";\" )\n    */\n   public R visit(field_body n);\n\n   /**\n    * f0 -> ( accessor_get_declaration() ( accessor_set_declaration() )? | accessor_set_declaration() ( accessor_get_declaration() )? )\n    */\n   public R visit(accessor_declarations n);\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <GET>\n    * f2 -> \";\"\n    */\n   public R visit(accessor_get_declaration n);\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <SET>\n    * f2 -> \";\"\n    */\n   public R visit(accessor_set_declaration n);\n\n   /**\n    * f0 -> VariableDeclaratorId()\n    * f1 -> [ \"=\" VariableInitializer() ]\n    */\n   public R visit(VariableDeclarator n);\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(VariableDeclaratorId n);\n\n   /**\n    * f0 -> \"{\" [ VariableInitializer() ( \",\" VariableInitializer() )* ] [ \",\" ] \"}\"\n    *       | Expression()\n    */\n   public R visit(VariableInitializer n);\n\n   /**\n    * f0 -> ( PrimitiveType() | Name() )\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(Type n);\n\n   /**\n    * f0 -> \"boolean\"\n    *       | \"char\"\n    *       | \"byte\"\n    *       | \"short\"\n    *       | \"int\"\n    *       | \"long\"\n    *       | \"float\"\n    *       | \"double\"\n    */\n   public R visit(PrimitiveType n);\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \".\" <IDENTIFIER> )*\n    */\n   public R visit(Name n);\n\n   /**\n    * f0 -> Name()\n    * f1 -> ( \",\" Name() )*\n    */\n   public R visit(NameList n);\n\n   /**\nAssignment()\n    */\n   public R visit(Expression n);\n\n   /**\n    * f0 -> PrimaryExpression()\n    * f1 -> AssignmentOperator()\n    * f2 -> Expression()\n    */\n   public R visit(Assignment n);\n\n   /**\n    * f0 -> \"=\"\n    *       | \"*=\"\n    *       | \"/=\"\n    *       | \"%=\"\n    *       | \"+=\"\n    *       | \"-=\"\n    *       | \"<<=\"\n    *       | \">>=\"\n    *       | \">>>=\"\n    *       | \"&=\"\n    *       | \"^=\"\n    *       | \"|=\"\n    */\n   public R visit(AssignmentOperator n);\n\n   /**\n    * f0 -> PrimaryPrefix()\n    * f1 -> ( PrimarySuffix() )*\n    */\n   public R visit(PrimaryExpression n);\n\n   /**\n    * f0 -> Literal()\n    *       | Name()\n    *       | \"this\"\n    *       | \"super\" \".\" <IDENTIFIER>\n    *       | \"(\" Expression() \")\"\n    *       | AllocationExpression()\n    */\n   public R visit(PrimaryPrefix n);\n\n   /**\n    * f0 -> \"[\" Expression() \"]\"\n    *       | \".\" <IDENTIFIER>\n    *       | Arguments()\n    */\n   public R visit(PrimarySuffix n);\n\n   /**\n    * f0 -> <INTEGER_LITERAL>\n    *       | <FLOATING_POINT_LITERAL>\n    *       | <CHARACTER_LITERAL>\n    *       | <STRING_LITERAL>\n    *       | BooleanLiteral()\n    *       | NullLiteral()\n    */\n   public R visit(Literal n);\n\n   /**\n    * f0 -> \"true\"\n    *       | \"false\"\n    */\n   public R visit(BooleanLiteral n);\n\n   /**\n    * f0 -> \"null\"\n    */\n   public R visit(NullLiteral n);\n\n   /**\n    * f0 -> \"(\"\n    * f1 -> [ ArgumentList() ]\n    * f2 -> \")\"\n    */\n   public R visit(Arguments n);\n\n   /**\n    * f0 -> Expression()\n    * f1 -> ( \",\" Expression() )*\n    */\n   public R visit(ArgumentList n);\n\n   /**\n    * f0 -> \"new\" PrimitiveType() ArrayDimensions()\n    *       | \"new\" Name() ( Arguments() | ArrayDimensions() )\n    */\n   public R visit(AllocationExpression n);\n\n   /**\n    * f0 -> ( \"[\" Expression() \"]\" )+\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public R visit(ArrayDimensions n);\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/visitor/GJNoArguVisitor.java b/visitor/GJNoArguVisitor.java
--- a/visitor/GJNoArguVisitor.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/visitor/GJNoArguVisitor.java	(date 1683052205956)
@@ -45,13 +45,13 @@
     * f3 -> [ "extends" Name() ]
     * f4 -> [ "implements" NameList() ]
     * f5 -> "{"
-    * f6 -> ( ClassBodyDeclaration() )*
+    * f6 -> ClassBodyDeclaration()
     * f7 -> "}"
     */
    public R visit(ClassDeclaration n);
 
    /**
-    * f0 -> FieldDeclaration()
+    * f0 -> ( FieldDeclaration() )*
     */
    public R visit(ClassBodyDeclaration n);
 
Index: visitor/GJVoidDepthFirst.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage visitor;\nimport syntaxtree.*;\nimport java.util.*;\n\n/**\n * Provides default methods which visit each node in the tree in depth-first\n * order.  Your visitors may extend this class.\n */\npublic class GJVoidDepthFirst<A> implements GJVoidVisitor<A> {\n   //\n   // Auto class visitors--probably don't need to be overridden.\n   //\n   public void visit(NodeList n, A argu) {\n      int _count=0;\n      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {\n         e.nextElement().accept(this,argu);\n         _count++;\n      }\n   }\n\n   public void visit(NodeListOptional n, A argu) {\n      if ( n.present() ) {\n         int _count=0;\n         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {\n            e.nextElement().accept(this,argu);\n            _count++;\n         }\n      }\n   }\n\n   public void visit(NodeOptional n, A argu) {\n      if ( n.present() )\n         n.node.accept(this,argu);\n   }\n\n   public void visit(NodeSequence n, A argu) {\n      int _count=0;\n      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {\n         e.nextElement().accept(this,argu);\n         _count++;\n      }\n   }\n\n   public void visit(NodeToken n, A argu) {}\n\n   //\n   // User-generated visitor methods below\n   //\n\n   /**\n    * f0 -> ( TypeDeclaration() )*\n    * f1 -> <EOF>\n    */\n   public void visit(CompilationUnit n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n   }\n\n   /**\n    * f0 -> ClassDeclaration()\n    *       | \";\"\n    */\n   public void visit(TypeDeclaration n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> ( \"abstract\" | \"final\" | \"public\" )*\n    * f1 -> \"class\"\n    * f2 -> <IDENTIFIER>\n    * f3 -> [ \"extends\" Name() ]\n    * f4 -> [ \"implements\" NameList() ]\n    * f5 -> \"{\"\n    * f6 -> ( ClassBodyDeclaration() )*\n    * f7 -> \"}\"\n    */\n   public void visit(ClassDeclaration n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n      n.f3.accept(this, argu);\n      n.f4.accept(this, argu);\n      n.f5.accept(this, argu);\n      n.f6.accept(this, argu);\n      n.f7.accept(this, argu);\n   }\n\n   /**\n    * f0 -> FieldDeclaration()\n    */\n   public void visit(ClassBodyDeclaration n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> ( field_modifier() )*\n    * f1 -> Type()\n    * f2 -> <IDENTIFIER>\n    * f3 -> field_body()\n    */\n   public void visit(FieldDeclaration n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n      n.f3.accept(this, argu);\n   }\n\n   /**\n    * f0 -> \"new\"\n    *       | \"public\"\n    *       | \"protected\"\n    *       | \"private\"\n    *       | \"static\"\n    *       | \"abstract\"\n    */\n   public void visit(field_modifier n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> ( \"=\" Expression() ( \"{\" accessor_declarations() \"}\" | \";\" ) | \"{\" accessor_declarations() \"}\" | \";\" )\n    */\n   public void visit(field_body n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> ( accessor_get_declaration() ( accessor_set_declaration() )? | accessor_set_declaration() ( accessor_get_declaration() )? )\n    */\n   public void visit(accessor_declarations n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <GET>\n    * f2 -> \";\"\n    */\n   public void visit(accessor_get_declaration n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n   }\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <SET>\n    * f2 -> \";\"\n    */\n   public void visit(accessor_set_declaration n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n   }\n\n   /**\n    * f0 -> VariableDeclaratorId()\n    * f1 -> [ \"=\" VariableInitializer() ]\n    */\n   public void visit(VariableDeclarator n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n   }\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(VariableDeclaratorId n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n   }\n\n   /**\n    * f0 -> \"{\" [ VariableInitializer() ( \",\" VariableInitializer() )* ] [ \",\" ] \"}\"\n    *       | Expression()\n    */\n   public void visit(VariableInitializer n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> ( PrimitiveType() | Name() )\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(Type n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n   }\n\n   /**\n    * f0 -> \"boolean\"\n    *       | \"char\"\n    *       | \"byte\"\n    *       | \"short\"\n    *       | \"int\"\n    *       | \"long\"\n    *       | \"float\"\n    *       | \"double\"\n    */\n   public void visit(PrimitiveType n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \".\" <IDENTIFIER> )*\n    */\n   public void visit(Name n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n   }\n\n   /**\n    * f0 -> Name()\n    * f1 -> ( \",\" Name() )*\n    */\n   public void visit(NameList n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n   }\n\n   /**\nAssignment()\n    */\n   public void visit(Expression n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> PrimaryExpression()\n    * f1 -> AssignmentOperator()\n    * f2 -> Expression()\n    */\n   public void visit(Assignment n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n   }\n\n   /**\n    * f0 -> \"=\"\n    *       | \"*=\"\n    *       | \"/=\"\n    *       | \"%=\"\n    *       | \"+=\"\n    *       | \"-=\"\n    *       | \"<<=\"\n    *       | \">>=\"\n    *       | \">>>=\"\n    *       | \"&=\"\n    *       | \"^=\"\n    *       | \"|=\"\n    */\n   public void visit(AssignmentOperator n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> PrimaryPrefix()\n    * f1 -> ( PrimarySuffix() )*\n    */\n   public void visit(PrimaryExpression n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n   }\n\n   /**\n    * f0 -> Literal()\n    *       | Name()\n    *       | \"this\"\n    *       | \"super\" \".\" <IDENTIFIER>\n    *       | \"(\" Expression() \")\"\n    *       | AllocationExpression()\n    */\n   public void visit(PrimaryPrefix n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> \"[\" Expression() \"]\"\n    *       | \".\" <IDENTIFIER>\n    *       | Arguments()\n    */\n   public void visit(PrimarySuffix n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> <INTEGER_LITERAL>\n    *       | <FLOATING_POINT_LITERAL>\n    *       | <CHARACTER_LITERAL>\n    *       | <STRING_LITERAL>\n    *       | BooleanLiteral()\n    *       | NullLiteral()\n    */\n   public void visit(Literal n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> \"true\"\n    *       | \"false\"\n    */\n   public void visit(BooleanLiteral n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> \"null\"\n    */\n   public void visit(NullLiteral n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> \"(\"\n    * f1 -> [ ArgumentList() ]\n    * f2 -> \")\"\n    */\n   public void visit(Arguments n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n      n.f2.accept(this, argu);\n   }\n\n   /**\n    * f0 -> Expression()\n    * f1 -> ( \",\" Expression() )*\n    */\n   public void visit(ArgumentList n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n   }\n\n   /**\n    * f0 -> \"new\" PrimitiveType() ArrayDimensions()\n    *       | \"new\" Name() ( Arguments() | ArrayDimensions() )\n    */\n   public void visit(AllocationExpression n, A argu) {\n      n.f0.accept(this, argu);\n   }\n\n   /**\n    * f0 -> ( \"[\" Expression() \"]\" )+\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(ArrayDimensions n, A argu) {\n      n.f0.accept(this, argu);\n      n.f1.accept(this, argu);\n   }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/visitor/GJVoidDepthFirst.java b/visitor/GJVoidDepthFirst.java
--- a/visitor/GJVoidDepthFirst.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/visitor/GJVoidDepthFirst.java	(date 1683052205972)
@@ -75,7 +75,7 @@
     * f3 -> [ "extends" Name() ]
     * f4 -> [ "implements" NameList() ]
     * f5 -> "{"
-    * f6 -> ( ClassBodyDeclaration() )*
+    * f6 -> ClassBodyDeclaration()
     * f7 -> "}"
     */
    public void visit(ClassDeclaration n, A argu) {
@@ -90,7 +90,7 @@
    }
 
    /**
-    * f0 -> FieldDeclaration()
+    * f0 -> ( FieldDeclaration() )*
     */
    public void visit(ClassBodyDeclaration n, A argu) {
       n.f0.accept(this, argu);
Index: visitor/DepthFirstVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\npackage visitor;\nimport syntaxtree.*;\nimport java.util.*;\n\n/**\n * Provides default methods which visit each node in the tree in depth-first\n * order.  Your visitors may extend this class.\n */\npublic class DepthFirstVisitor implements Visitor {\n   //\n   // Auto class visitors--probably don't need to be overridden.\n   //\n   public void visit(NodeList n) {\n      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )\n         e.nextElement().accept(this);\n   }\n\n   public void visit(NodeListOptional n) {\n      if ( n.present() )\n         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )\n            e.nextElement().accept(this);\n   }\n\n   public void visit(NodeOptional n) {\n      if ( n.present() )\n         n.node.accept(this);\n   }\n\n   public void visit(NodeSequence n) {\n      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )\n         e.nextElement().accept(this);\n   }\n\n   public void visit(NodeToken n) { }\n\n   //\n   // User-generated visitor methods below\n   //\n\n   /**\n    * f0 -> ( TypeDeclaration() )*\n    * f1 -> <EOF>\n    */\n   public void visit(CompilationUnit n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n   }\n\n   /**\n    * f0 -> ClassDeclaration()\n    *       | \";\"\n    */\n   public void visit(TypeDeclaration n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> ( \"abstract\" | \"final\" | \"public\" )*\n    * f1 -> \"class\"\n    * f2 -> <IDENTIFIER>\n    * f3 -> [ \"extends\" Name() ]\n    * f4 -> [ \"implements\" NameList() ]\n    * f5 -> \"{\"\n    * f6 -> ( ClassBodyDeclaration() )*\n    * f7 -> \"}\"\n    */\n   public void visit(ClassDeclaration n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      n.f3.accept(this);\n      n.f4.accept(this);\n      n.f5.accept(this);\n      n.f6.accept(this);\n      n.f7.accept(this);\n   }\n\n   /**\n    * f0 -> FieldDeclaration()\n    */\n   public void visit(ClassBodyDeclaration n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> ( field_modifier() )*\n    * f1 -> Type()\n    * f2 -> <IDENTIFIER>\n    * f3 -> field_body()\n    */\n   public void visit(FieldDeclaration n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      n.f3.accept(this);\n   }\n\n   /**\n    * f0 -> \"new\"\n    *       | \"public\"\n    *       | \"protected\"\n    *       | \"private\"\n    *       | \"static\"\n    *       | \"abstract\"\n    */\n   public void visit(field_modifier n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> ( \"=\" Expression() ( \"{\" accessor_declarations() \"}\" | \";\" ) | \"{\" accessor_declarations() \"}\" | \";\" )\n    */\n   public void visit(field_body n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> ( accessor_get_declaration() ( accessor_set_declaration() )? | accessor_set_declaration() ( accessor_get_declaration() )? )\n    */\n   public void visit(accessor_declarations n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <GET>\n    * f2 -> \";\"\n    */\n   public void visit(accessor_get_declaration n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n   }\n\n   /**\n    * f0 -> ( \"private\" | \"public\" )?\n    * f1 -> <SET>\n    * f2 -> \";\"\n    */\n   public void visit(accessor_set_declaration n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n   }\n\n   /**\n    * f0 -> VariableDeclaratorId()\n    * f1 -> [ \"=\" VariableInitializer() ]\n    */\n   public void visit(VariableDeclarator n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n   }\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(VariableDeclaratorId n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n   }\n\n   /**\n    * f0 -> \"{\" [ VariableInitializer() ( \",\" VariableInitializer() )* ] [ \",\" ] \"}\"\n    *       | Expression()\n    */\n   public void visit(VariableInitializer n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> ( PrimitiveType() | Name() )\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(Type n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n   }\n\n   /**\n    * f0 -> \"boolean\"\n    *       | \"char\"\n    *       | \"byte\"\n    *       | \"short\"\n    *       | \"int\"\n    *       | \"long\"\n    *       | \"float\"\n    *       | \"double\"\n    */\n   public void visit(PrimitiveType n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> <IDENTIFIER>\n    * f1 -> ( \".\" <IDENTIFIER> )*\n    */\n   public void visit(Name n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n   }\n\n   /**\n    * f0 -> Name()\n    * f1 -> ( \",\" Name() )*\n    */\n   public void visit(NameList n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n   }\n\n   /**\nAssignment()\n    */\n   public void visit(Expression n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> PrimaryExpression()\n    * f1 -> AssignmentOperator()\n    * f2 -> Expression()\n    */\n   public void visit(Assignment n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n   }\n\n   /**\n    * f0 -> \"=\"\n    *       | \"*=\"\n    *       | \"/=\"\n    *       | \"%=\"\n    *       | \"+=\"\n    *       | \"-=\"\n    *       | \"<<=\"\n    *       | \">>=\"\n    *       | \">>>=\"\n    *       | \"&=\"\n    *       | \"^=\"\n    *       | \"|=\"\n    */\n   public void visit(AssignmentOperator n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> PrimaryPrefix()\n    * f1 -> ( PrimarySuffix() )*\n    */\n   public void visit(PrimaryExpression n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n   }\n\n   /**\n    * f0 -> Literal()\n    *       | Name()\n    *       | \"this\"\n    *       | \"super\" \".\" <IDENTIFIER>\n    *       | \"(\" Expression() \")\"\n    *       | AllocationExpression()\n    */\n   public void visit(PrimaryPrefix n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> \"[\" Expression() \"]\"\n    *       | \".\" <IDENTIFIER>\n    *       | Arguments()\n    */\n   public void visit(PrimarySuffix n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> <INTEGER_LITERAL>\n    *       | <FLOATING_POINT_LITERAL>\n    *       | <CHARACTER_LITERAL>\n    *       | <STRING_LITERAL>\n    *       | BooleanLiteral()\n    *       | NullLiteral()\n    */\n   public void visit(Literal n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> \"true\"\n    *       | \"false\"\n    */\n   public void visit(BooleanLiteral n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> \"null\"\n    */\n   public void visit(NullLiteral n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> \"(\"\n    * f1 -> [ ArgumentList() ]\n    * f2 -> \")\"\n    */\n   public void visit(Arguments n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n   }\n\n   /**\n    * f0 -> Expression()\n    * f1 -> ( \",\" Expression() )*\n    */\n   public void visit(ArgumentList n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n   }\n\n   /**\n    * f0 -> \"new\" PrimitiveType() ArrayDimensions()\n    *       | \"new\" Name() ( Arguments() | ArrayDimensions() )\n    */\n   public void visit(AllocationExpression n) {\n      n.f0.accept(this);\n   }\n\n   /**\n    * f0 -> ( \"[\" Expression() \"]\" )+\n    * f1 -> ( \"[\" \"]\" )*\n    */\n   public void visit(ArrayDimensions n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n   }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/visitor/DepthFirstVisitor.java b/visitor/DepthFirstVisitor.java
--- a/visitor/DepthFirstVisitor.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/visitor/DepthFirstVisitor.java	(date 1683052205966)
@@ -65,7 +65,7 @@
     * f3 -> [ "extends" Name() ]
     * f4 -> [ "implements" NameList() ]
     * f5 -> "{"
-    * f6 -> ( ClassBodyDeclaration() )*
+    * f6 -> ClassBodyDeclaration()
     * f7 -> "}"
     */
    public void visit(ClassDeclaration n) {
@@ -80,7 +80,7 @@
    }
 
    /**
-    * f0 -> FieldDeclaration()
+    * f0 -> ( FieldDeclaration() )*
     */
    public void visit(ClassBodyDeclaration n) {
       n.f0.accept(this);
Index: JavaParser.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* JavaParser.java */\n/* Generated By:JavaCC: Do not edit this line. JavaParser.java */\nimport java.io.IOException;\nimport syntaxtree.*;\nimport java.util.Vector;\n\n\npublic class JavaParser implements JavaParserConstants {\n   static void printDebugInfo(String productionName)\n   {\n   }\n   public static void main(String args[])\n   {\n      JavaParser parser;\n      if ( args.length == 0 )\n      {\n         System.out.println(\"==========================================================================================================\");\n         System.out.println(\"==========================================================================================================\");\n         System.out.println(\"Java Parser Version 1.0.2:  Reading from standard input . . .\");\n         parser = new JavaParser(System.in);\n      }\n      else\n         if ( args.length == 1 )\n         {\n            System.out.println(\"==========================================================================================================\");\n            System.out.println(\"==========================================================================================================\");\n            System.out.println(\"Java Parser Version 1.0.2:  Reading from file \" + args[0]+ \" . . .\");\n            try\n            {\n               parser = new JavaParser(new java.io.FileInputStream(args[0]));\n            }\n            catch (java.io.FileNotFoundException e)\n            {\n               System.out.println(\"Java Parser Version 1.0.2:  File \" + args[0]+ \" not found.\");\n               return;\n            }\n         }\n         else\n         {\n            System.out.println(\"Java Parser Version 1.0.2:  Usage is one of:\");\n            System.out.println(\"         java JavaParser < inputfile\");\n            System.out.println(\"OR\");\n            System.out.println(\"         java JavaParser inputfile\");\n            return;\n         }\n      try\n      {\n         Node root = parser.CompilationUnit();\n         MyVisitor v = new MyVisitor();\n         root.accept(v);\n         v.writeOutputToFile();\n         System.out.println(\"Java Parser Version 1.0.2:  Java program parsed successfully.\");\n      }\n      catch (ParseException e)\n      {\n         System.out.println(\"Java Parser Version 1.0.2:  Encountered errors during parse.\");\n         System.out.println(e.toString());\n      }\n      catch (IOException e)\n      {\n         throw new RuntimeException(e);\n      }\n   }\n\n  static final public CompilationUnit CompilationUnit() throws ParseException {NodeListOptional n0 = new NodeListOptional();\n   TypeDeclaration n1;\n   NodeToken n2;\n   Token n3;\n\n   printDebugInfo(\"CompilationUnit\");\n    label_1:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ABSTRACT:\n      case CLASS:\n      case FINAL:\n      case PUBLIC:\n      case SEMICOLON:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[0] = jj_gen;\n        break label_1;\n      }\n      n1 = TypeDeclaration();\nn0.addNode(n1);\n    }\nn0.nodes.trimToSize();\n    n3 = jj_consume_token(0);\nn3.beginColumn++; n3.endColumn++;\n      n2 = JTBToolkit.makeNodeToken(n3);\n{if (\"\" != null) return new CompilationUnit(n0,n2);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public TypeDeclaration TypeDeclaration() throws ParseException {NodeChoice n0;\n   ClassDeclaration n1;\n   NodeToken n2;\n   Token n3;\n\n   printDebugInfo(\"TypeDeclaration\");\n    if (jj_2_1(2147483647)) {\n      n1 = ClassDeclaration();\nn0 = new NodeChoice(n1, 0);\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case SEMICOLON:{\n        n3 = jj_consume_token(SEMICOLON);\nn2 = JTBToolkit.makeNodeToken(n3);\nn0 = new NodeChoice(n2, 1);\n        break;\n        }\n      default:\n        jj_la1[1] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n{if (\"\" != null) return new TypeDeclaration(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public ClassDeclaration ClassDeclaration() throws ParseException {NodeListOptional n0 = new NodeListOptional();\n   NodeChoice n1;\n   NodeToken n2;\n   Token n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n   NodeToken n8;\n   Token n9;\n   NodeToken n10;\n   Token n11;\n   NodeOptional n12 = new NodeOptional();\n   NodeSequence n13;\n   NodeToken n14;\n   Token n15;\n   Name n16;\n   NodeOptional n17 = new NodeOptional();\n   NodeSequence n18;\n   NodeToken n19;\n   Token n20;\n   NameList n21;\n   NodeToken n22;\n   Token n23;\n   NodeListOptional n24 = new NodeListOptional();\n   ClassBodyDeclaration n25;\n   NodeToken n26;\n   Token n27;\n\n   printDebugInfo(\"ClassDeclaration\");\n    label_2:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ABSTRACT:\n      case FINAL:\n      case PUBLIC:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[2] = jj_gen;\n        break label_2;\n      }\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ABSTRACT:{\n        n3 = jj_consume_token(ABSTRACT);\nn2 = JTBToolkit.makeNodeToken(n3);\nn1 = new NodeChoice(n2, 0);\n        break;\n        }\n      case FINAL:{\n        n5 = jj_consume_token(FINAL);\nn4 = JTBToolkit.makeNodeToken(n5);\nn1 = new NodeChoice(n4, 1);\n        break;\n        }\n      case PUBLIC:{\n        n7 = jj_consume_token(PUBLIC);\nn6 = JTBToolkit.makeNodeToken(n7);\nn1 = new NodeChoice(n6, 2);\n        break;\n        }\n      default:\n        jj_la1[3] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\nn0.addNode(n1);\n    }\nn0.nodes.trimToSize();\n    n9 = jj_consume_token(CLASS);\nn8 = JTBToolkit.makeNodeToken(n9);\n    n11 = jj_consume_token(IDENTIFIER);\nn10 = JTBToolkit.makeNodeToken(n11);\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case EXTENDS:{\nn13 = new NodeSequence(2);\n      n15 = jj_consume_token(EXTENDS);\nn14 = JTBToolkit.makeNodeToken(n15);\nn13.addNode(n14);\n      n16 = Name();\nn13.addNode(n16);\nn12.addNode(n13);\n      break;\n      }\n    default:\n      jj_la1[4] = jj_gen;\n      ;\n    }\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IMPLEMENTS:{\nn18 = new NodeSequence(2);\n      n20 = jj_consume_token(IMPLEMENTS);\nn19 = JTBToolkit.makeNodeToken(n20);\nn18.addNode(n19);\n      n21 = NameList();\nn18.addNode(n21);\nn17.addNode(n18);\n      break;\n      }\n    default:\n      jj_la1[5] = jj_gen;\n      ;\n    }\n    n23 = jj_consume_token(LBRACE);\nn22 = JTBToolkit.makeNodeToken(n23);\n    label_3:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ABSTRACT:\n      case BOOLEAN:\n      case BYTE:\n      case CHAR:\n      case DOUBLE:\n      case FLOAT:\n      case INT:\n      case LONG:\n      case NEW:\n      case PRIVATE:\n      case PROTECTED:\n      case PUBLIC:\n      case SHORT:\n      case STATIC:\n      case IDENTIFIER:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[6] = jj_gen;\n        break label_3;\n      }\n      n25 = ClassBodyDeclaration();\nn24.addNode(n25);\n    }\nn24.nodes.trimToSize();\n    n27 = jj_consume_token(RBRACE);\nn26 = JTBToolkit.makeNodeToken(n27);\n{if (\"\" != null) return new ClassDeclaration(n0,n8,n10,n12,n17,n22,n24,n26);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public ClassBodyDeclaration ClassBodyDeclaration() throws ParseException {FieldDeclaration n0;\n\n   printDebugInfo(\"ClassBodyDeclaration\");\n    n0 = FieldDeclaration();\n{if (\"\" != null) return new ClassBodyDeclaration(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public FieldDeclaration FieldDeclaration() throws ParseException {NodeListOptional n0 = new NodeListOptional();\n   field_modifier n1;\n   Type n2;\n   NodeToken n3;\n   Token n4;\n   field_body n5;\n\n   printDebugInfo(\"FieldDeclaration\");\n    label_4:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ABSTRACT:\n      case NEW:\n      case PRIVATE:\n      case PROTECTED:\n      case PUBLIC:\n      case STATIC:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[7] = jj_gen;\n        break label_4;\n      }\n      n1 = field_modifier();\nn0.addNode(n1);\n    }\nn0.nodes.trimToSize();\n    n2 = Type();\n    n4 = jj_consume_token(IDENTIFIER);\nn3 = JTBToolkit.makeNodeToken(n4);\n    n5 = field_body();\n{if (\"\" != null) return new FieldDeclaration(n0,n2,n3,n5);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public field_modifier field_modifier() throws ParseException {NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n   NodeToken n9;\n   Token n10;\n   NodeToken n11;\n   Token n12;\n\n   printDebugInfo(\"field_modifier\");\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case NEW:{\n      n2 = jj_consume_token(NEW);\nn1 = JTBToolkit.makeNodeToken(n2);\nn0 = new NodeChoice(n1, 0);\n      break;\n      }\n    case PUBLIC:{\n      n4 = jj_consume_token(PUBLIC);\nn3 = JTBToolkit.makeNodeToken(n4);\nn0 = new NodeChoice(n3, 1);\n      break;\n      }\n    case PROTECTED:{\n      n6 = jj_consume_token(PROTECTED);\nn5 = JTBToolkit.makeNodeToken(n6);\nn0 = new NodeChoice(n5, 2);\n      break;\n      }\n    case PRIVATE:{\n      n8 = jj_consume_token(PRIVATE);\nn7 = JTBToolkit.makeNodeToken(n8);\nn0 = new NodeChoice(n7, 3);\n      break;\n      }\n    case STATIC:{\n      n10 = jj_consume_token(STATIC);\nn9 = JTBToolkit.makeNodeToken(n10);\nn0 = new NodeChoice(n9, 4);\n      break;\n      }\n    case ABSTRACT:{\n      n12 = jj_consume_token(ABSTRACT);\nn11 = JTBToolkit.makeNodeToken(n12);\nn0 = new NodeChoice(n11, 5);\n      break;\n      }\n    default:\n      jj_la1[8] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n{if (\"\" != null) return new field_modifier(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public field_body field_body() throws ParseException {NodeChoice n0;\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   Expression n4;\n   NodeChoice n5;\n   NodeSequence n6;\n   NodeToken n7;\n   Token n8;\n   accessor_declarations n9;\n   NodeToken n10;\n   Token n11;\n   NodeToken n12;\n   Token n13;\n   NodeSequence n14;\n   NodeToken n15;\n   Token n16;\n   accessor_declarations n17;\n   NodeToken n18;\n   Token n19;\n   NodeToken n20;\n   Token n21;\n\n   printDebugInfo(\"field_body\");\n    if (jj_2_2(3)) {\nn1 = new NodeSequence(4);\n      n3 = jj_consume_token(ASSIGN);\nn2 = JTBToolkit.makeNodeToken(n3);\nn1.addNode(n2);\n      n4 = Expression();\nn1.addNode(n4);\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case LBRACE:{\nn6 = new NodeSequence(3);\n        n8 = jj_consume_token(LBRACE);\nn7 = JTBToolkit.makeNodeToken(n8);\nn6.addNode(n7);\n        n9 = accessor_declarations();\nn6.addNode(n9);\n        n11 = jj_consume_token(RBRACE);\nn10 = JTBToolkit.makeNodeToken(n11);\nn6.addNode(n10);\nn5 = new NodeChoice(n6, 0);\n        break;\n        }\n      case SEMICOLON:{\n        n13 = jj_consume_token(SEMICOLON);\nn12 = JTBToolkit.makeNodeToken(n13);\nn5 = new NodeChoice(n12, 1);\n        break;\n        }\n      default:\n        jj_la1[9] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\nn1.addNode(n5);\nn0 = new NodeChoice(n1, 0);\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case LBRACE:{\nn14 = new NodeSequence(3);\n        n16 = jj_consume_token(LBRACE);\nn15 = JTBToolkit.makeNodeToken(n16);\nn14.addNode(n15);\n        n17 = accessor_declarations();\nn14.addNode(n17);\n        n19 = jj_consume_token(RBRACE);\nn18 = JTBToolkit.makeNodeToken(n19);\nn14.addNode(n18);\nn0 = new NodeChoice(n14, 1);\n        break;\n        }\n      case SEMICOLON:{\n        n21 = jj_consume_token(SEMICOLON);\nn20 = JTBToolkit.makeNodeToken(n21);\nn0 = new NodeChoice(n20, 2);\n        break;\n        }\n      default:\n        jj_la1[10] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n{if (\"\" != null) return new field_body(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public accessor_declarations accessor_declarations() throws ParseException {NodeChoice n0;\n   NodeSequence n1;\n   accessor_get_declaration n2;\n   NodeOptional n3 = new NodeOptional();\n   accessor_set_declaration n4;\n   NodeSequence n5;\n   accessor_set_declaration n6;\n   NodeOptional n7 = new NodeOptional();\n   accessor_get_declaration n8;\n\n   printDebugInfo(\"accessor_declarations\");\n    if (jj_2_5(2)) {\nn1 = new NodeSequence(3);\n      n2 = accessor_get_declaration();\nn1.addNode(n2);\n      if (jj_2_3(2)) {\n        n4 = accessor_set_declaration();\nn3.addNode(n4);\n      } else {\n        ;\n      }\nn1.addNode(n3);\nn0 = new NodeChoice(n1, 0);\n    } else if (jj_2_6(2)) {\nn5 = new NodeSequence(3);\n      n6 = accessor_set_declaration();\nn5.addNode(n6);\n      if (jj_2_4(2)) {\n        n8 = accessor_get_declaration();\nn7.addNode(n8);\n      } else {\n        ;\n      }\nn5.addNode(n7);\nn0 = new NodeChoice(n5, 1);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n{if (\"\" != null) return new accessor_declarations(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public accessor_get_declaration accessor_get_declaration() throws ParseException {NodeOptional n0 = new NodeOptional();\n   NodeChoice n1;\n   NodeToken n2;\n   Token n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n   NodeToken n8;\n   Token n9;\n\n   printDebugInfo(\"accessor_get_declaration\");\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case PRIVATE:\n    case PUBLIC:{\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case PRIVATE:{\n        n3 = jj_consume_token(PRIVATE);\nn2 = JTBToolkit.makeNodeToken(n3);\nn1 = new NodeChoice(n2, 0);\n        break;\n        }\n      case PUBLIC:{\n        n5 = jj_consume_token(PUBLIC);\nn4 = JTBToolkit.makeNodeToken(n5);\nn1 = new NodeChoice(n4, 1);\n        break;\n        }\n      default:\n        jj_la1[11] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\nn0.addNode(n1);\n      break;\n      }\n    default:\n      jj_la1[12] = jj_gen;\n      ;\n    }\n    n7 = jj_consume_token(GET);\nn6 = JTBToolkit.makeNodeToken(n7);\n    n9 = jj_consume_token(SEMICOLON);\nn8 = JTBToolkit.makeNodeToken(n9);\n{if (\"\" != null) return new accessor_get_declaration(n0,n6,n8);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public accessor_set_declaration accessor_set_declaration() throws ParseException {NodeOptional n0 = new NodeOptional();\n   NodeChoice n1;\n   NodeToken n2;\n   Token n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n   NodeToken n8;\n   Token n9;\n\n   printDebugInfo(\"accessor_set_declaration\");\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case PRIVATE:\n    case PUBLIC:{\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case PRIVATE:{\n        n3 = jj_consume_token(PRIVATE);\nn2 = JTBToolkit.makeNodeToken(n3);\nn1 = new NodeChoice(n2, 0);\n        break;\n        }\n      case PUBLIC:{\n        n5 = jj_consume_token(PUBLIC);\nn4 = JTBToolkit.makeNodeToken(n5);\nn1 = new NodeChoice(n4, 1);\n        break;\n        }\n      default:\n        jj_la1[13] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\nn0.addNode(n1);\n      break;\n      }\n    default:\n      jj_la1[14] = jj_gen;\n      ;\n    }\n    n7 = jj_consume_token(SET);\nn6 = JTBToolkit.makeNodeToken(n7);\n    n9 = jj_consume_token(SEMICOLON);\nn8 = JTBToolkit.makeNodeToken(n9);\n{if (\"\" != null) return new accessor_set_declaration(n0,n6,n8);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public VariableDeclarator VariableDeclarator() throws ParseException {VariableDeclaratorId n0;\n   NodeOptional n1 = new NodeOptional();\n   NodeSequence n2;\n   NodeToken n3;\n   Token n4;\n   VariableInitializer n5;\n\n   printDebugInfo(\"VariableDeclarator\");\n    n0 = VariableDeclaratorId();\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case ASSIGN:{\nn2 = new NodeSequence(2);\n      n4 = jj_consume_token(ASSIGN);\nn3 = JTBToolkit.makeNodeToken(n4);\nn2.addNode(n3);\n      n5 = VariableInitializer();\nn2.addNode(n5);\nn1.addNode(n2);\n      break;\n      }\n    default:\n      jj_la1[15] = jj_gen;\n      ;\n    }\n{if (\"\" != null) return new VariableDeclarator(n0,n1);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public VariableDeclaratorId VariableDeclaratorId() throws ParseException {NodeToken n0;\n   Token n1;\n   NodeListOptional n2 = new NodeListOptional();\n   NodeSequence n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n\n   printDebugInfo(\"VariableDeclaratorId\");\n    n1 = jj_consume_token(IDENTIFIER);\nn0 = JTBToolkit.makeNodeToken(n1);\n    label_5:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case LBRACKET:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[16] = jj_gen;\n        break label_5;\n      }\nn3 = new NodeSequence(2);\n      n5 = jj_consume_token(LBRACKET);\nn4 = JTBToolkit.makeNodeToken(n5);\nn3.addNode(n4);\n      n7 = jj_consume_token(RBRACKET);\nn6 = JTBToolkit.makeNodeToken(n7);\nn3.addNode(n6);\nn2.addNode(n3);\n    }\nn2.nodes.trimToSize();\n{if (\"\" != null) return new VariableDeclaratorId(n0,n2);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public VariableInitializer VariableInitializer() throws ParseException {NodeChoice n0;\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   NodeOptional n4 = new NodeOptional();\n   NodeSequence n5;\n   VariableInitializer n6;\n   NodeListOptional n7;\n   NodeSequence n8;\n   NodeToken n9;\n   Token n10;\n   VariableInitializer n11;\n   NodeOptional n12 = new NodeOptional();\n   NodeToken n13;\n   Token n14;\n   NodeToken n15;\n   Token n16;\n   Expression n17;\n\n   printDebugInfo(\"VariableInit\");\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case LBRACE:{\nn1 = new NodeSequence(4);\n      n3 = jj_consume_token(LBRACE);\nn2 = JTBToolkit.makeNodeToken(n3);\nn1.addNode(n2);\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case FALSE:\n      case NEW:\n      case NULL:\n      case SUPER:\n      case THIS:\n      case TRUE:\n      case INTEGER_LITERAL:\n      case FLOATING_POINT_LITERAL:\n      case CHARACTER_LITERAL:\n      case STRING_LITERAL:\n      case IDENTIFIER:\n      case LPAREN:\n      case LBRACE:{\nn7 = new NodeListOptional();\nn5 = new NodeSequence(2);\n        n6 = VariableInitializer();\nn5.addNode(n6);\n        label_6:\n        while (true) {\n          if (jj_2_7(2)) {\n            ;\n          } else {\n            break label_6;\n          }\nn8 = new NodeSequence(2);\n          n10 = jj_consume_token(COMMA);\nn9 = JTBToolkit.makeNodeToken(n10);\nn8.addNode(n9);\n          n11 = VariableInitializer();\nn8.addNode(n11);\nn7.addNode(n8);\n        }\nn7.nodes.trimToSize();\nn5.addNode(n7);\nn4.addNode(n5);\n        break;\n        }\n      default:\n        jj_la1[17] = jj_gen;\n        ;\n      }\nn1.addNode(n4);\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMMA:{\n        n14 = jj_consume_token(COMMA);\nn13 = JTBToolkit.makeNodeToken(n14);\nn12.addNode(n13);\n        break;\n        }\n      default:\n        jj_la1[18] = jj_gen;\n        ;\n      }\nn1.addNode(n12);\n      n16 = jj_consume_token(RBRACE);\nn15 = JTBToolkit.makeNodeToken(n16);\nn1.addNode(n15);\nn0 = new NodeChoice(n1, 0);\n      break;\n      }\n    case FALSE:\n    case NEW:\n    case NULL:\n    case SUPER:\n    case THIS:\n    case TRUE:\n    case INTEGER_LITERAL:\n    case FLOATING_POINT_LITERAL:\n    case CHARACTER_LITERAL:\n    case STRING_LITERAL:\n    case IDENTIFIER:\n    case LPAREN:{\n      n17 = Expression();\nn0 = new NodeChoice(n17, 1);\n      break;\n      }\n    default:\n      jj_la1[19] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n{if (\"\" != null) return new VariableInitializer(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public Type Type() throws ParseException {NodeChoice n0;\n   PrimitiveType n1;\n   Name n2;\n   NodeListOptional n3 = new NodeListOptional();\n   NodeSequence n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case BOOLEAN:\n    case BYTE:\n    case CHAR:\n    case DOUBLE:\n    case FLOAT:\n    case INT:\n    case LONG:\n    case SHORT:{\n      n1 = PrimitiveType();\nn0 = new NodeChoice(n1, 0);\n      break;\n      }\n    case IDENTIFIER:{\n      n2 = Name();\nn0 = new NodeChoice(n2, 1);\n      break;\n      }\n    default:\n      jj_la1[20] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    label_7:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case LBRACKET:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[21] = jj_gen;\n        break label_7;\n      }\nn4 = new NodeSequence(2);\n      n6 = jj_consume_token(LBRACKET);\nn5 = JTBToolkit.makeNodeToken(n6);\nn4.addNode(n5);\n      n8 = jj_consume_token(RBRACKET);\nn7 = JTBToolkit.makeNodeToken(n8);\nn4.addNode(n7);\nn3.addNode(n4);\n    }\nn3.nodes.trimToSize();\n{if (\"\" != null) return new Type(n0,n3);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public PrimitiveType PrimitiveType() throws ParseException {NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n   NodeToken n9;\n   Token n10;\n   NodeToken n11;\n   Token n12;\n   NodeToken n13;\n   Token n14;\n   NodeToken n15;\n   Token n16;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case BOOLEAN:{\n      n2 = jj_consume_token(BOOLEAN);\nn1 = JTBToolkit.makeNodeToken(n2);\nn0 = new NodeChoice(n1, 0);\n      break;\n      }\n    case CHAR:{\n      n4 = jj_consume_token(CHAR);\nn3 = JTBToolkit.makeNodeToken(n4);\nn0 = new NodeChoice(n3, 1);\n      break;\n      }\n    case BYTE:{\n      n6 = jj_consume_token(BYTE);\nn5 = JTBToolkit.makeNodeToken(n6);\nn0 = new NodeChoice(n5, 2);\n      break;\n      }\n    case SHORT:{\n      n8 = jj_consume_token(SHORT);\nn7 = JTBToolkit.makeNodeToken(n8);\nn0 = new NodeChoice(n7, 3);\n      break;\n      }\n    case INT:{\n      n10 = jj_consume_token(INT);\nn9 = JTBToolkit.makeNodeToken(n10);\nn0 = new NodeChoice(n9, 4);\n      break;\n      }\n    case LONG:{\n      n12 = jj_consume_token(LONG);\nn11 = JTBToolkit.makeNodeToken(n12);\nn0 = new NodeChoice(n11, 5);\n      break;\n      }\n    case FLOAT:{\n      n14 = jj_consume_token(FLOAT);\nn13 = JTBToolkit.makeNodeToken(n14);\nn0 = new NodeChoice(n13, 6);\n      break;\n      }\n    case DOUBLE:{\n      n16 = jj_consume_token(DOUBLE);\nn15 = JTBToolkit.makeNodeToken(n16);\nn0 = new NodeChoice(n15, 7);\n      break;\n      }\n    default:\n      jj_la1[22] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n{if (\"\" != null) return new PrimitiveType(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public Name Name() throws ParseException {NodeToken n0;\n   Token n1;\n   NodeListOptional n2 = new NodeListOptional();\n   NodeSequence n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n    n1 = jj_consume_token(IDENTIFIER);\nn0 = JTBToolkit.makeNodeToken(n1);\n    label_8:\n    while (true) {\n      if (jj_2_8(2)) {\n        ;\n      } else {\n        break label_8;\n      }\nn3 = new NodeSequence(2);\n      n5 = jj_consume_token(DOT);\nn4 = JTBToolkit.makeNodeToken(n5);\nn3.addNode(n4);\n      n7 = jj_consume_token(IDENTIFIER);\nn6 = JTBToolkit.makeNodeToken(n7);\nn3.addNode(n6);\nn2.addNode(n3);\n    }\nn2.nodes.trimToSize();\n{if (\"\" != null) return new Name(n0,n2);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public NameList NameList() throws ParseException {Name n0;\n   NodeListOptional n1 = new NodeListOptional();\n   NodeSequence n2;\n   NodeToken n3;\n   Token n4;\n   Name n5;\n    n0 = Name();\n    label_9:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMMA:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[23] = jj_gen;\n        break label_9;\n      }\nn2 = new NodeSequence(2);\n      n4 = jj_consume_token(COMMA);\nn3 = JTBToolkit.makeNodeToken(n4);\nn2.addNode(n3);\n      n5 = Name();\nn2.addNode(n5);\nn1.addNode(n2);\n    }\nn1.nodes.trimToSize();\n{if (\"\" != null) return new NameList(n0,n1);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public Expression Expression() throws ParseException {Assignment n0;\n\n   printDebugInfo(\"Expression\");\n    if (jj_2_9(2147483647)) {\n\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    n0 = Assignment();\n{if (\"\" != null) return new Expression(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public Assignment Assignment() throws ParseException {PrimaryExpression n0;\n   AssignmentOperator n1;\n   Expression n2;\n\n   printDebugInfo(\"Assignment\");\n    n0 = PrimaryExpression();\n    n1 = AssignmentOperator();\n    n2 = Expression();\n{if (\"\" != null) return new Assignment(n0,n1,n2);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public AssignmentOperator AssignmentOperator() throws ParseException {NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n   NodeToken n9;\n   Token n10;\n   NodeToken n11;\n   Token n12;\n   NodeToken n13;\n   Token n14;\n   NodeToken n15;\n   Token n16;\n   NodeToken n17;\n   Token n18;\n   NodeToken n19;\n   Token n20;\n   NodeToken n21;\n   Token n22;\n   NodeToken n23;\n   Token n24;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case ASSIGN:{\n      n2 = jj_consume_token(ASSIGN);\nn1 = JTBToolkit.makeNodeToken(n2);\nn0 = new NodeChoice(n1, 0);\n      break;\n      }\n    case STARASSIGN:{\n      n4 = jj_consume_token(STARASSIGN);\nn3 = JTBToolkit.makeNodeToken(n4);\nn0 = new NodeChoice(n3, 1);\n      break;\n      }\n    case SLASHASSIGN:{\n      n6 = jj_consume_token(SLASHASSIGN);\nn5 = JTBToolkit.makeNodeToken(n6);\nn0 = new NodeChoice(n5, 2);\n      break;\n      }\n    case REMASSIGN:{\n      n8 = jj_consume_token(REMASSIGN);\nn7 = JTBToolkit.makeNodeToken(n8);\nn0 = new NodeChoice(n7, 3);\n      break;\n      }\n    case PLUSASSIGN:{\n      n10 = jj_consume_token(PLUSASSIGN);\nn9 = JTBToolkit.makeNodeToken(n10);\nn0 = new NodeChoice(n9, 4);\n      break;\n      }\n    case MINUSASSIGN:{\n      n12 = jj_consume_token(MINUSASSIGN);\nn11 = JTBToolkit.makeNodeToken(n12);\nn0 = new NodeChoice(n11, 5);\n      break;\n      }\n    case LSHIFTASSIGN:{\n      n14 = jj_consume_token(LSHIFTASSIGN);\nn13 = JTBToolkit.makeNodeToken(n14);\nn0 = new NodeChoice(n13, 6);\n      break;\n      }\n    case RSIGNEDSHIFTASSIGN:{\n      n16 = jj_consume_token(RSIGNEDSHIFTASSIGN);\nn15 = JTBToolkit.makeNodeToken(n16);\nn0 = new NodeChoice(n15, 7);\n      break;\n      }\n    case RUNSIGNEDSHIFTASSIGN:{\n      n18 = jj_consume_token(RUNSIGNEDSHIFTASSIGN);\nn17 = JTBToolkit.makeNodeToken(n18);\nn0 = new NodeChoice(n17, 8);\n      break;\n      }\n    case ANDASSIGN:{\n      n20 = jj_consume_token(ANDASSIGN);\nn19 = JTBToolkit.makeNodeToken(n20);\nn0 = new NodeChoice(n19, 9);\n      break;\n      }\n    case XORASSIGN:{\n      n22 = jj_consume_token(XORASSIGN);\nn21 = JTBToolkit.makeNodeToken(n22);\nn0 = new NodeChoice(n21, 10);\n      break;\n      }\n    case ORASSIGN:{\n      n24 = jj_consume_token(ORASSIGN);\nn23 = JTBToolkit.makeNodeToken(n24);\nn0 = new NodeChoice(n23, 11);\n      break;\n      }\n    default:\n      jj_la1[24] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n{if (\"\" != null) return new AssignmentOperator(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public PrimaryExpression PrimaryExpression() throws ParseException {PrimaryPrefix n0;\n   NodeListOptional n1 = new NodeListOptional();\n   PrimarySuffix n2;\n    n0 = PrimaryPrefix();\n    label_10:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case LPAREN:\n      case LBRACKET:\n      case DOT:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[25] = jj_gen;\n        break label_10;\n      }\n      n2 = PrimarySuffix();\nn1.addNode(n2);\n    }\nn1.nodes.trimToSize();\n{if (\"\" != null) return new PrimaryExpression(n0,n1);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public PrimaryPrefix PrimaryPrefix() throws ParseException {NodeChoice n0;\n   Literal n1;\n   Name n2;\n   NodeToken n3;\n   Token n4;\n   NodeSequence n5;\n   NodeToken n6;\n   Token n7;\n   NodeToken n8;\n   Token n9;\n   NodeToken n10;\n   Token n11;\n   NodeSequence n12;\n   NodeToken n13;\n   Token n14;\n   Expression n15;\n   NodeToken n16;\n   Token n17;\n   AllocationExpression n18;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case FALSE:\n    case NULL:\n    case TRUE:\n    case INTEGER_LITERAL:\n    case FLOATING_POINT_LITERAL:\n    case CHARACTER_LITERAL:\n    case STRING_LITERAL:{\n      n1 = Literal();\nn0 = new NodeChoice(n1, 0);\n      break;\n      }\n    case IDENTIFIER:{\n      n2 = Name();\nn0 = new NodeChoice(n2, 1);\n      break;\n      }\n    case THIS:{\n      n4 = jj_consume_token(THIS);\nn3 = JTBToolkit.makeNodeToken(n4);\nn0 = new NodeChoice(n3, 2);\n      break;\n      }\n    case SUPER:{\nn5 = new NodeSequence(3);\n      n7 = jj_consume_token(SUPER);\nn6 = JTBToolkit.makeNodeToken(n7);\nn5.addNode(n6);\n      n9 = jj_consume_token(DOT);\nn8 = JTBToolkit.makeNodeToken(n9);\nn5.addNode(n8);\n      n11 = jj_consume_token(IDENTIFIER);\nn10 = JTBToolkit.makeNodeToken(n11);\nn5.addNode(n10);\nn0 = new NodeChoice(n5, 3);\n      break;\n      }\n    case LPAREN:{\nn12 = new NodeSequence(3);\n      n14 = jj_consume_token(LPAREN);\nn13 = JTBToolkit.makeNodeToken(n14);\nn12.addNode(n13);\n      n15 = Expression();\nn12.addNode(n15);\n      n17 = jj_consume_token(RPAREN);\nn16 = JTBToolkit.makeNodeToken(n17);\nn12.addNode(n16);\nn0 = new NodeChoice(n12, 4);\n      break;\n      }\n    case NEW:{\n      n18 = AllocationExpression();\nn0 = new NodeChoice(n18, 5);\n      break;\n      }\n    default:\n      jj_la1[26] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n{if (\"\" != null) return new PrimaryPrefix(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public PrimarySuffix PrimarySuffix() throws ParseException {NodeChoice n0;\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   Expression n4;\n   NodeToken n5;\n   Token n6;\n   NodeSequence n7;\n   NodeToken n8;\n   Token n9;\n   NodeToken n10;\n   Token n11;\n   Arguments n12;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case LBRACKET:{\nn1 = new NodeSequence(3);\n      n3 = jj_consume_token(LBRACKET);\nn2 = JTBToolkit.makeNodeToken(n3);\nn1.addNode(n2);\n      n4 = Expression();\nn1.addNode(n4);\n      n6 = jj_consume_token(RBRACKET);\nn5 = JTBToolkit.makeNodeToken(n6);\nn1.addNode(n5);\nn0 = new NodeChoice(n1, 0);\n      break;\n      }\n    case DOT:{\nn7 = new NodeSequence(2);\n      n9 = jj_consume_token(DOT);\nn8 = JTBToolkit.makeNodeToken(n9);\nn7.addNode(n8);\n      n11 = jj_consume_token(IDENTIFIER);\nn10 = JTBToolkit.makeNodeToken(n11);\nn7.addNode(n10);\nn0 = new NodeChoice(n7, 1);\n      break;\n      }\n    case LPAREN:{\n      n12 = Arguments();\nn0 = new NodeChoice(n12, 2);\n      break;\n      }\n    default:\n      jj_la1[27] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n{if (\"\" != null) return new PrimarySuffix(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public Literal Literal() throws ParseException {NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n   BooleanLiteral n9;\n   NullLiteral n10;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case INTEGER_LITERAL:{\n      n2 = jj_consume_token(INTEGER_LITERAL);\nn1 = JTBToolkit.makeNodeToken(n2);\nn0 = new NodeChoice(n1, 0);\n      break;\n      }\n    case FLOATING_POINT_LITERAL:{\n      n4 = jj_consume_token(FLOATING_POINT_LITERAL);\nn3 = JTBToolkit.makeNodeToken(n4);\nn0 = new NodeChoice(n3, 1);\n      break;\n      }\n    case CHARACTER_LITERAL:{\n      n6 = jj_consume_token(CHARACTER_LITERAL);\nn5 = JTBToolkit.makeNodeToken(n6);\nn0 = new NodeChoice(n5, 2);\n      break;\n      }\n    case STRING_LITERAL:{\n      n8 = jj_consume_token(STRING_LITERAL);\nn7 = JTBToolkit.makeNodeToken(n8);\nn0 = new NodeChoice(n7, 3);\n      break;\n      }\n    case FALSE:\n    case TRUE:{\n      n9 = BooleanLiteral();\nn0 = new NodeChoice(n9, 4);\n      break;\n      }\n    case NULL:{\n      n10 = NullLiteral();\nn0 = new NodeChoice(n10, 5);\n      break;\n      }\n    default:\n      jj_la1[28] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n{if (\"\" != null) return new Literal(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public BooleanLiteral BooleanLiteral() throws ParseException {NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case TRUE:{\n      n2 = jj_consume_token(TRUE);\nn1 = JTBToolkit.makeNodeToken(n2);\nn0 = new NodeChoice(n1, 0);\n      break;\n      }\n    case FALSE:{\n      n4 = jj_consume_token(FALSE);\nn3 = JTBToolkit.makeNodeToken(n4);\nn0 = new NodeChoice(n3, 1);\n      break;\n      }\n    default:\n      jj_la1[29] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n{if (\"\" != null) return new BooleanLiteral(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public NullLiteral NullLiteral() throws ParseException {NodeToken n0;\n   Token n1;\n    n1 = jj_consume_token(NULL);\nn0 = JTBToolkit.makeNodeToken(n1);\n{if (\"\" != null) return new NullLiteral(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public Arguments Arguments() throws ParseException {NodeToken n0;\n   Token n1;\n   NodeOptional n2 = new NodeOptional();\n   ArgumentList n3;\n   NodeToken n4;\n   Token n5;\n    n1 = jj_consume_token(LPAREN);\nn0 = JTBToolkit.makeNodeToken(n1);\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case FALSE:\n    case NEW:\n    case NULL:\n    case SUPER:\n    case THIS:\n    case TRUE:\n    case INTEGER_LITERAL:\n    case FLOATING_POINT_LITERAL:\n    case CHARACTER_LITERAL:\n    case STRING_LITERAL:\n    case IDENTIFIER:\n    case LPAREN:{\n      n3 = ArgumentList();\nn2.addNode(n3);\n      break;\n      }\n    default:\n      jj_la1[30] = jj_gen;\n      ;\n    }\n    n5 = jj_consume_token(RPAREN);\nn4 = JTBToolkit.makeNodeToken(n5);\n{if (\"\" != null) return new Arguments(n0,n2,n4);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public ArgumentList ArgumentList() throws ParseException {Expression n0;\n   NodeListOptional n1 = new NodeListOptional();\n   NodeSequence n2;\n   NodeToken n3;\n   Token n4;\n   Expression n5;\n    n0 = Expression();\n    label_11:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMMA:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[31] = jj_gen;\n        break label_11;\n      }\nn2 = new NodeSequence(2);\n      n4 = jj_consume_token(COMMA);\nn3 = JTBToolkit.makeNodeToken(n4);\nn2.addNode(n3);\n      n5 = Expression();\nn2.addNode(n5);\nn1.addNode(n2);\n    }\nn1.nodes.trimToSize();\n{if (\"\" != null) return new ArgumentList(n0,n1);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public AllocationExpression AllocationExpression() throws ParseException {NodeChoice n0;\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   PrimitiveType n4;\n   ArrayDimensions n5;\n   NodeSequence n6;\n   NodeToken n7;\n   Token n8;\n   Name n9;\n   NodeChoice n10;\n   Arguments n11;\n   ArrayDimensions n12;\n    if (jj_2_10(2)) {\nn1 = new NodeSequence(4);\n      n3 = jj_consume_token(NEW);\nn2 = JTBToolkit.makeNodeToken(n3);\nn1.addNode(n2);\n      n4 = PrimitiveType();\nn1.addNode(n4);\n      n5 = ArrayDimensions();\nn1.addNode(n5);\nn0 = new NodeChoice(n1, 0);\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case NEW:{\nn6 = new NodeSequence(3);\n        n8 = jj_consume_token(NEW);\nn7 = JTBToolkit.makeNodeToken(n8);\nn6.addNode(n7);\n        n9 = Name();\nn6.addNode(n9);\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case LPAREN:{\n          n11 = Arguments();\nn10 = new NodeChoice(n11, 0);\n          break;\n          }\n        case LBRACKET:{\n          n12 = ArrayDimensions();\nn10 = new NodeChoice(n12, 1);\n          break;\n          }\n        default:\n          jj_la1[32] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\nn6.addNode(n10);\nn0 = new NodeChoice(n6, 1);\n        break;\n        }\n      default:\n        jj_la1[33] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n{if (\"\" != null) return new AllocationExpression(n0);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static final public ArrayDimensions ArrayDimensions() throws ParseException {NodeList n0 = new NodeList();\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   Expression n4;\n   NodeToken n5;\n   Token n6;\n   NodeListOptional n7 = new NodeListOptional();\n   NodeSequence n8;\n   NodeToken n9;\n   Token n10;\n   NodeToken n11;\n   Token n12;\n    label_12:\n    while (true) {\nn1 = new NodeSequence(3);\n      n3 = jj_consume_token(LBRACKET);\nn2 = JTBToolkit.makeNodeToken(n3);\nn1.addNode(n2);\n      n4 = Expression();\nn1.addNode(n4);\n      n6 = jj_consume_token(RBRACKET);\nn5 = JTBToolkit.makeNodeToken(n6);\nn1.addNode(n5);\nn0.addNode(n1);\n      if (jj_2_11(2)) {\n        ;\n      } else {\n        break label_12;\n      }\n    }\nn0.nodes.trimToSize();\n    label_13:\n    while (true) {\n      if (jj_2_12(2)) {\n        ;\n      } else {\n        break label_13;\n      }\nn8 = new NodeSequence(2);\n      n10 = jj_consume_token(LBRACKET);\nn9 = JTBToolkit.makeNodeToken(n10);\nn8.addNode(n9);\n      n12 = jj_consume_token(RBRACKET);\nn11 = JTBToolkit.makeNodeToken(n12);\nn8.addNode(n11);\nn7.addNode(n8);\n    }\nn7.nodes.trimToSize();\n{if (\"\" != null) return new ArrayDimensions(n0,n7);}\n    throw new Error(\"Missing return statement in function\");\n}\n\n  static private boolean jj_2_1(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_1()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(0, xla); }\n  }\n\n  static private boolean jj_2_2(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_2()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(1, xla); }\n  }\n\n  static private boolean jj_2_3(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_3()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(2, xla); }\n  }\n\n  static private boolean jj_2_4(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_4()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(3, xla); }\n  }\n\n  static private boolean jj_2_5(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_5()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(4, xla); }\n  }\n\n  static private boolean jj_2_6(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_6()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(5, xla); }\n  }\n\n  static private boolean jj_2_7(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_7()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(6, xla); }\n  }\n\n  static private boolean jj_2_8(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_8()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(7, xla); }\n  }\n\n  static private boolean jj_2_9(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_9()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(8, xla); }\n  }\n\n  static private boolean jj_2_10(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_10()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(9, xla); }\n  }\n\n  static private boolean jj_2_11(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_11()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(10, xla); }\n  }\n\n  static private boolean jj_2_12(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_12()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(11, xla); }\n  }\n\n  static private boolean jj_3R_accessor_get_declaration_565_7_23()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_accessor_get_declaration_566_10_38()) {\n    jj_scanpos = xsp;\n    if (jj_3R_accessor_get_declaration_569_10_39()) return true;\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_946_7_46()\n {\n    if (jj_scan_token(PLUSASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_943_7_45()\n {\n    if (jj_scan_token(REMASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_accessor_get_declaration_564_4_17()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_accessor_get_declaration_565_7_23()) jj_scanpos = xsp;\n    if (jj_scan_token(GET)) return true;\n    if (jj_scan_token(SEMICOLON)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_940_7_44()\n {\n    if (jj_scan_token(SLASHASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Literal_1129_7_72()\n {\n    if (jj_3R_NullLiteral_1166_4_76()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_937_7_43()\n {\n    if (jj_scan_token(STARASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Literal_1126_7_71()\n {\n    if (jj_3R_BooleanLiteral_1147_4_75()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_934_7_42()\n {\n    if (jj_scan_token(ASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Literal_1123_7_70()\n {\n    if (jj_scan_token(STRING_LITERAL)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_933_4_35()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_AssignmentOperator_934_7_42()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_937_7_43()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_940_7_44()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_943_7_45()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_946_7_46()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_949_7_47()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_952_7_48()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_955_7_49()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_958_7_50()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_961_7_51()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_964_7_52()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AssignmentOperator_967_7_53()) return true;\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_Literal_1120_7_69()\n {\n    if (jj_scan_token(CHARACTER_LITERAL)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Literal_1117_7_68()\n {\n    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;\n    return false;\n  }\n\n  static private boolean jj_3_4()\n {\n    if (jj_3R_accessor_get_declaration_564_4_17()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Literal_1114_7_67()\n {\n    if (jj_scan_token(INTEGER_LITERAL)) return true;\n    return false;\n  }\n\n  static private boolean jj_3_12()\n {\n    if (jj_scan_token(LBRACKET)) return true;\n    if (jj_scan_token(RBRACKET)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Literal_1113_4_61()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_Literal_1114_7_67()) {\n    jj_scanpos = xsp;\n    if (jj_3R_Literal_1117_7_68()) {\n    jj_scanpos = xsp;\n    if (jj_3R_Literal_1120_7_69()) {\n    jj_scanpos = xsp;\n    if (jj_3R_Literal_1123_7_70()) {\n    jj_scanpos = xsp;\n    if (jj_3R_Literal_1126_7_71()) {\n    jj_scanpos = xsp;\n    if (jj_3R_Literal_1129_7_72()) return true;\n    }\n    }\n    }\n    }\n    }\n    return false;\n  }\n\n  static private boolean jj_3_6()\n {\n    if (jj_3R_accessor_set_declaration_596_4_16()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_VariableInitializer_721_7_25()\n {\n    if (jj_3R_Expression_880_4_15()) return true;\n    return false;\n  }\n\n  static private boolean jj_3_3()\n {\n    if (jj_3R_accessor_set_declaration_596_4_16()) return true;\n    return false;\n  }\n\n  static private boolean jj_3_11()\n {\n    if (jj_scan_token(LBRACKET)) return true;\n    if (jj_3R_Expression_880_4_15()) return true;\n    return false;\n  }\n\n  static private boolean jj_3_5()\n {\n    if (jj_3R_accessor_get_declaration_564_4_17()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimarySuffix_1089_7_66()\n {\n    if (jj_3R_Arguments_1183_4_74()) return true;\n    return false;\n  }\n\n  static private boolean jj_3_7()\n {\n    if (jj_scan_token(COMMA)) return true;\n    if (jj_3R_VariableInitializer_689_4_18()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Assignment_895_4_21()\n {\n    if (jj_3R_PrimaryExpression_983_4_34()) return true;\n    if (jj_3R_AssignmentOperator_933_4_35()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimarySuffix_1082_7_65()\n {\n    if (jj_scan_token(DOT)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Expression_880_14_20()\n {\n    return false;\n  }\n\n  static private boolean jj_3R_PrimarySuffix_1073_7_64()\n {\n    if (jj_scan_token(LBRACKET)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_VariableInitializer_690_7_24()\n {\n    if (jj_scan_token(LBRACE)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimarySuffix_1072_4_60()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_PrimarySuffix_1073_7_64()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimarySuffix_1082_7_65()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimarySuffix_1089_7_66()) return true;\n    }\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_VariableInitializer_689_4_18()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_VariableInitializer_690_7_24()) {\n    jj_scanpos = xsp;\n    if (jj_3R_VariableInitializer_721_7_25()) return true;\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_Expression_880_4_15()\n {\n    if (jj_3R_Expression_880_14_20()) return true;\n    if (jj_3R_Assignment_895_4_21()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AllocationExpression_1249_7_73()\n {\n    if (jj_scan_token(NEW)) return true;\n    if (jj_3R_Name_832_4_62()) return true;\n    return false;\n  }\n\n  static private boolean jj_3_10()\n {\n    if (jj_scan_token(NEW)) return true;\n    if (jj_3R_PrimitiveType_789_4_19()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimaryPrefix_1046_7_59()\n {\n    if (jj_3R_AllocationExpression_1238_4_63()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AllocationExpression_1238_4_63()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3_10()) {\n    jj_scanpos = xsp;\n    if (jj_3R_AllocationExpression_1249_7_73()) return true;\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_null_262_19_14()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(9)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(25)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(43)) return true;\n    }\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_PrimaryPrefix_1037_7_58()\n {\n    if (jj_scan_token(LPAREN)) return true;\n    if (jj_3R_Expression_880_4_15()) return true;\n    return false;\n  }\n\n  static private boolean jj_3_1()\n {\n    Token xsp;\n    while (true) {\n      xsp = jj_scanpos;\n      if (jj_3R_null_262_19_14()) { jj_scanpos = xsp; break; }\n    }\n    if (jj_scan_token(CLASS)) return true;\n    return false;\n  }\n\n  static private boolean jj_3_2()\n {\n    if (jj_scan_token(ASSIGN)) return true;\n    if (jj_3R_Expression_880_4_15()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimaryPrefix_1028_7_57()\n {\n    if (jj_scan_token(SUPER)) return true;\n    if (jj_scan_token(DOT)) return true;\n    return false;\n  }\n\n  static private boolean jj_3_8()\n {\n    if (jj_scan_token(DOT)) return true;\n    if (jj_scan_token(IDENTIFIER)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimaryPrefix_1025_7_56()\n {\n    if (jj_scan_token(THIS)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimaryPrefix_1022_7_55()\n {\n    if (jj_3R_Name_832_4_62()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Name_832_4_62()\n {\n    if (jj_scan_token(IDENTIFIER)) return true;\n    Token xsp;\n    while (true) {\n      xsp = jj_scanpos;\n      if (jj_3_8()) { jj_scanpos = xsp; break; }\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_PrimaryPrefix_1019_7_54()\n {\n    if (jj_3R_Literal_1113_4_61()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimaryPrefix_1018_4_40()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_PrimaryPrefix_1019_7_54()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimaryPrefix_1022_7_55()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimaryPrefix_1025_7_56()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimaryPrefix_1028_7_57()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimaryPrefix_1037_7_58()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimaryPrefix_1046_7_59()) return true;\n    }\n    }\n    }\n    }\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_PrimitiveType_811_7_33()\n {\n    if (jj_scan_token(DOUBLE)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimitiveType_808_7_32()\n {\n    if (jj_scan_token(FLOAT)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimitiveType_805_7_31()\n {\n    if (jj_scan_token(LONG)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimitiveType_802_7_30()\n {\n    if (jj_scan_token(INT)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimitiveType_799_7_29()\n {\n    if (jj_scan_token(SHORT)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_Arguments_1183_4_74()\n {\n    if (jj_scan_token(LPAREN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimitiveType_796_7_28()\n {\n    if (jj_scan_token(BYTE)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_accessor_set_declaration_601_10_37()\n {\n    if (jj_scan_token(PUBLIC)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimaryExpression_985_7_41()\n {\n    if (jj_3R_PrimarySuffix_1072_4_60()) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimitiveType_793_7_27()\n {\n    if (jj_scan_token(CHAR)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_accessor_set_declaration_598_10_36()\n {\n    if (jj_scan_token(PRIVATE)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimitiveType_790_7_26()\n {\n    if (jj_scan_token(BOOLEAN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_PrimaryExpression_983_4_34()\n {\n    if (jj_3R_PrimaryPrefix_1018_4_40()) return true;\n    Token xsp;\n    while (true) {\n      xsp = jj_scanpos;\n      if (jj_3R_PrimaryExpression_985_7_41()) { jj_scanpos = xsp; break; }\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_accessor_set_declaration_597_7_22()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_accessor_set_declaration_598_10_36()) {\n    jj_scanpos = xsp;\n    if (jj_3R_accessor_set_declaration_601_10_37()) return true;\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_PrimitiveType_789_4_19()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_PrimitiveType_790_7_26()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimitiveType_793_7_27()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimitiveType_796_7_28()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimitiveType_799_7_29()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimitiveType_802_7_30()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimitiveType_805_7_31()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimitiveType_808_7_32()) {\n    jj_scanpos = xsp;\n    if (jj_3R_PrimitiveType_811_7_33()) return true;\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_accessor_set_declaration_596_4_16()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_accessor_set_declaration_597_7_22()) jj_scanpos = xsp;\n    if (jj_scan_token(SET)) return true;\n    if (jj_scan_token(SEMICOLON)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_NullLiteral_1166_4_76()\n {\n    if (jj_scan_token(NULL)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_967_7_53()\n {\n    if (jj_scan_token(ORASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_964_7_52()\n {\n    if (jj_scan_token(XORASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_961_7_51()\n {\n    if (jj_scan_token(ANDASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_BooleanLiteral_1151_7_78()\n {\n    if (jj_scan_token(FALSE)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_958_7_50()\n {\n    if (jj_scan_token(RUNSIGNEDSHIFTASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_BooleanLiteral_1148_7_77()\n {\n    if (jj_scan_token(TRUE)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_955_7_49()\n {\n    if (jj_scan_token(RSIGNEDSHIFTASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_accessor_get_declaration_569_10_39()\n {\n    if (jj_scan_token(PUBLIC)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_BooleanLiteral_1147_4_75()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_BooleanLiteral_1148_7_77()) {\n    jj_scanpos = xsp;\n    if (jj_3R_BooleanLiteral_1151_7_78()) return true;\n    }\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_952_7_48()\n {\n    if (jj_scan_token(LSHIFTASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_accessor_get_declaration_566_10_38()\n {\n    if (jj_scan_token(PRIVATE)) return true;\n    return false;\n  }\n\n  static private boolean jj_3R_AssignmentOperator_949_7_47()\n {\n    if (jj_scan_token(MINUSASSIGN)) return true;\n    return false;\n  }\n\n  static private boolean jj_3_9()\n {\n    if (jj_scan_token(0)) return true;\n    return false;\n  }\n\n  static private boolean jj_initialized_once = false;\n  /** Generated Token Manager. */\n  static public JavaParserTokenManager token_source;\n  static JavaCharStream jj_input_stream;\n  /** Current token. */\n  static public Token token;\n  /** Next token. */\n  static public Token jj_nt;\n  static private int jj_ntk;\n  static private Token jj_scanpos, jj_lastpos;\n  static private int jj_la;\n  static private int jj_gen;\n  static final private int[] jj_la1 = new int[34];\n  static private int[] jj_la1_0;\n  static private int[] jj_la1_1;\n  static private int[] jj_la1_2;\n  static private int[] jj_la1_3;\n  static {\n\t   jj_la1_init_0();\n\t   jj_la1_init_1();\n\t   jj_la1_init_2();\n\t   jj_la1_init_3();\n\t}\n\tprivate static void jj_la1_init_0() {\n\t   jj_la1_0 = new int[] {0x2010200,0x0,0x2000200,0x2000200,0x800000,0x80000000,0x8209600,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x1000000,0x8209400,0x0,0x8209400,0x0,0x0,0x0,0x1000000,0x0,0x1000000,0x1000000,0x1000000,0x0,0x0,0x0,};\n\t}\n\tprivate static void jj_la1_init_1() {\n\t   jj_la1_1 = new int[] {0x800,0x0,0x800,0x800,0x0,0x0,0x6e54,0x4e40,0x4e40,0x0,0x0,0xa00,0xa00,0xa00,0xa00,0x0,0x0,0x204480c0,0x0,0x204480c0,0x2014,0x0,0x2014,0x0,0x0,0x0,0x204480c0,0x0,0x20400080,0x400000,0x204480c0,0x0,0x0,0x40,};\n\t}\n\tprivate static void jj_la1_init_2() {\n\t   jj_la1_2 = new int[] {0x4000,0x4000,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x4400,0x4400,0x0,0x0,0x0,0x0,0x20000,0x1000,0x53a,0x8000,0x53a,0x20,0x1000,0x0,0x8000,0x20000,0x11100,0x13a,0x11100,0x1a,0x0,0x13a,0x8000,0x1100,0x0,};\n\t}\n\tprivate static void jj_la1_init_3() {\n\t   jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ff800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};\n\t}\n  static final private JJCalls[] jj_2_rtns = new JJCalls[12];\n  static private boolean jj_rescan = false;\n  static private int jj_gc = 0;\n\n  /** Constructor with InputStream. */\n  public JavaParser(java.io.InputStream stream) {\n\t  this(stream, null);\n  }\n  /** Constructor with InputStream and supplied encoding */\n  public JavaParser(java.io.InputStream stream, String encoding) {\n\t if (jj_initialized_once) {\n\t   System.out.println(\"ERROR: Second call to constructor of static parser.  \");\n\t   System.out.println(\"\t   You must either use ReInit() or set the JavaCC option STATIC to false\");\n\t   System.out.println(\"\t   during parser generation.\");\n\t   throw new Error();\n\t }\n\t jj_initialized_once = true;\n\t try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n\t token_source = new JavaParserTokenManager(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 34; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Reinitialise. */\n  static public void ReInit(java.io.InputStream stream) {\n\t  ReInit(stream, null);\n  }\n  /** Reinitialise. */\n  static public void ReInit(java.io.InputStream stream, String encoding) {\n\t try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n\t token_source.ReInit(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 34; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Constructor. */\n  public JavaParser(java.io.Reader stream) {\n\t if (jj_initialized_once) {\n\t   System.out.println(\"ERROR: Second call to constructor of static parser. \");\n\t   System.out.println(\"\t   You must either use ReInit() or set the JavaCC option STATIC to false\");\n\t   System.out.println(\"\t   during parser generation.\");\n\t   throw new Error();\n\t }\n\t jj_initialized_once = true;\n\t jj_input_stream = new JavaCharStream(stream, 1, 1);\n\t token_source = new JavaParserTokenManager(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 34; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Reinitialise. */\n  static public void ReInit(java.io.Reader stream) {\n\tif (jj_input_stream == null) {\n\t   jj_input_stream = new JavaCharStream(stream, 1, 1);\n\t} else {\n\t   jj_input_stream.ReInit(stream, 1, 1);\n\t}\n\tif (token_source == null) {\n token_source = new JavaParserTokenManager(jj_input_stream);\n\t}\n\n\t token_source.ReInit(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 34; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Constructor with generated Token Manager. */\n  public JavaParser(JavaParserTokenManager tm) {\n\t if (jj_initialized_once) {\n\t   System.out.println(\"ERROR: Second call to constructor of static parser. \");\n\t   System.out.println(\"\t   You must either use ReInit() or set the JavaCC option STATIC to false\");\n\t   System.out.println(\"\t   during parser generation.\");\n\t   throw new Error();\n\t }\n\t jj_initialized_once = true;\n\t token_source = tm;\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 34; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  /** Reinitialise. */\n  public void ReInit(JavaParserTokenManager tm) {\n\t token_source = tm;\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 34; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }\n\n  static private Token jj_consume_token(int kind) throws ParseException {\n\t Token oldToken;\n\t if ((oldToken = token).next != null) token = token.next;\n\t else token = token.next = token_source.getNextToken();\n\t jj_ntk = -1;\n\t if (token.kind == kind) {\n\t   jj_gen++;\n\t   if (++jj_gc > 100) {\n\t\t jj_gc = 0;\n\t\t for (int i = 0; i < jj_2_rtns.length; i++) {\n\t\t   JJCalls c = jj_2_rtns[i];\n\t\t   while (c != null) {\n\t\t\t if (c.gen < jj_gen) c.first = null;\n\t\t\t c = c.next;\n\t\t   }\n\t\t }\n\t   }\n\t   return token;\n\t }\n\t token = oldToken;\n\t jj_kind = kind;\n\t throw generateParseException();\n  }\n\n  @SuppressWarnings(\"serial\")\n  static private final class LookaheadSuccess extends java.lang.Error {\n    @Override\n    public Throwable fillInStackTrace() {\n      return this;\n    }\n  }\n  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();\n  static private boolean jj_scan_token(int kind) {\n\t if (jj_scanpos == jj_lastpos) {\n\t   jj_la--;\n\t   if (jj_scanpos.next == null) {\n\t\t jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\n\t   } else {\n\t\t jj_lastpos = jj_scanpos = jj_scanpos.next;\n\t   }\n\t } else {\n\t   jj_scanpos = jj_scanpos.next;\n\t }\n\t if (jj_rescan) {\n\t   int i = 0; Token tok = token;\n\t   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }\n\t   if (tok != null) jj_add_error_token(kind, i);\n\t }\n\t if (jj_scanpos.kind != kind) return true;\n\t if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;\n\t return false;\n  }\n\n\n/** Get the next Token. */\n  static final public Token getNextToken() {\n\t if (token.next != null) token = token.next;\n\t else token = token.next = token_source.getNextToken();\n\t jj_ntk = -1;\n\t jj_gen++;\n\t return token;\n  }\n\n/** Get the specific Token. */\n  static final public Token getToken(int index) {\n\t Token t = token;\n\t for (int i = 0; i < index; i++) {\n\t   if (t.next != null) t = t.next;\n\t   else t = t.next = token_source.getNextToken();\n\t }\n\t return t;\n  }\n\n  static private int jj_ntk_f() {\n\t if ((jj_nt=token.next) == null)\n\t   return (jj_ntk = (token.next=token_source.getNextToken()).kind);\n\t else\n\t   return (jj_ntk = jj_nt.kind);\n  }\n\n  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();\n  static private int[] jj_expentry;\n  static private int jj_kind = -1;\n  static private int[] jj_lasttokens = new int[100];\n  static private int jj_endpos;\n\n  static private void jj_add_error_token(int kind, int pos) {\n\t if (pos >= 100) {\n\t\treturn;\n\t }\n\n\t if (pos == jj_endpos + 1) {\n\t   jj_lasttokens[jj_endpos++] = kind;\n\t } else if (jj_endpos != 0) {\n\t   jj_expentry = new int[jj_endpos];\n\n\t   for (int i = 0; i < jj_endpos; i++) {\n\t\t jj_expentry[i] = jj_lasttokens[i];\n\t   }\n\n\t   for (int[] oldentry : jj_expentries) {\n\t\t if (oldentry.length == jj_expentry.length) {\n\t\t   boolean isMatched = true;\n\n\t\t   for (int i = 0; i < jj_expentry.length; i++) {\n\t\t\t if (oldentry[i] != jj_expentry[i]) {\n\t\t\t   isMatched = false;\n\t\t\t   break;\n\t\t\t }\n\n\t\t   }\n\t\t   if (isMatched) {\n\t\t\t jj_expentries.add(jj_expentry);\n\t\t\t break;\n\t\t   }\n\t\t }\n\t   }\n\n\t   if (pos != 0) {\n\t\t jj_lasttokens[(jj_endpos = pos) - 1] = kind;\n\t   }\n\t }\n  }\n\n  /** Generate ParseException. */\n  static public ParseException generateParseException() {\n\t jj_expentries.clear();\n\t boolean[] la1tokens = new boolean[118];\n\t if (jj_kind >= 0) {\n\t   la1tokens[jj_kind] = true;\n\t   jj_kind = -1;\n\t }\n\t for (int i = 0; i < 34; i++) {\n\t   if (jj_la1[i] == jj_gen) {\n\t\t for (int j = 0; j < 32; j++) {\n\t\t   if ((jj_la1_0[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[j] = true;\n\t\t   }\n\t\t   if ((jj_la1_1[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[32+j] = true;\n\t\t   }\n\t\t   if ((jj_la1_2[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[64+j] = true;\n\t\t   }\n\t\t   if ((jj_la1_3[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[96+j] = true;\n\t\t   }\n\t\t }\n\t   }\n\t }\n\t for (int i = 0; i < 118; i++) {\n\t   if (la1tokens[i]) {\n\t\t jj_expentry = new int[1];\n\t\t jj_expentry[0] = i;\n\t\t jj_expentries.add(jj_expentry);\n\t   }\n\t }\n\t jj_endpos = 0;\n\t jj_rescan_token();\n\t jj_add_error_token(0, 0);\n\t int[][] exptokseq = new int[jj_expentries.size()][];\n\t for (int i = 0; i < jj_expentries.size(); i++) {\n\t   exptokseq[i] = jj_expentries.get(i);\n\t }\n\t return new ParseException(token, exptokseq, tokenImage);\n  }\n\n  static private boolean trace_enabled;\n\n/** Trace enabled. */\n  static final public boolean trace_enabled() {\n\t return trace_enabled;\n  }\n\n  /** Enable tracing. */\n  static final public void enable_tracing() {\n  }\n\n  /** Disable tracing. */\n  static final public void disable_tracing() {\n  }\n\n  static private void jj_rescan_token() {\n\t jj_rescan = true;\n\t for (int i = 0; i < 12; i++) {\n\t   try {\n\t\t JJCalls p = jj_2_rtns[i];\n\n\t\t do {\n\t\t   if (p.gen > jj_gen) {\n\t\t\t jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;\n\t\t\t switch (i) {\n\t\t\t   case 0: jj_3_1(); break;\n\t\t\t   case 1: jj_3_2(); break;\n\t\t\t   case 2: jj_3_3(); break;\n\t\t\t   case 3: jj_3_4(); break;\n\t\t\t   case 4: jj_3_5(); break;\n\t\t\t   case 5: jj_3_6(); break;\n\t\t\t   case 6: jj_3_7(); break;\n\t\t\t   case 7: jj_3_8(); break;\n\t\t\t   case 8: jj_3_9(); break;\n\t\t\t   case 9: jj_3_10(); break;\n\t\t\t   case 10: jj_3_11(); break;\n\t\t\t   case 11: jj_3_12(); break;\n\t\t\t }\n\t\t   }\n\t\t   p = p.next;\n\t\t } while (p != null);\n\n\t\t } catch(LookaheadSuccess ls) { }\n\t }\n\t jj_rescan = false;\n  }\n\n  static private void jj_save(int index, int xla) {\n\t JJCalls p = jj_2_rtns[index];\n\t while (p.gen > jj_gen) {\n\t   if (p.next == null) { p = p.next = new JJCalls(); break; }\n\t   p = p.next;\n\t }\n\n\t p.gen = jj_gen + xla - jj_la; \n\t p.first = token;\n\t p.arg = xla;\n  }\n\n  static final class JJCalls {\n\t int gen;\n\t Token first;\n\t int arg;\n\t JJCalls next;\n  }\n\n}\n\nclass JTBToolkit {\n   static NodeToken makeNodeToken(Token t) {\n      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);\n   }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/JavaParser.java b/JavaParser.java
--- a/JavaParser.java	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/JavaParser.java	(date 1683052206252)
@@ -145,10 +145,9 @@
    NameList n21;
    NodeToken n22;
    Token n23;
-   NodeListOptional n24 = new NodeListOptional();
-   ClassBodyDeclaration n25;
-   NodeToken n26;
-   Token n27;
+   ClassBodyDeclaration n24;
+   NodeToken n25;
+   Token n26;
 
    printDebugInfo("ClassDeclaration");
     label_2:
@@ -227,6 +226,17 @@
     }
     n23 = jj_consume_token(LBRACE);
 n22 = JTBToolkit.makeNodeToken(n23);
+    n24 = ClassBodyDeclaration();
+    n26 = jj_consume_token(RBRACE);
+n25 = JTBToolkit.makeNodeToken(n26);
+{if ("" != null) return new ClassDeclaration(n0,n8,n10,n12,n17,n22,n24,n25);}
+    throw new Error("Missing return statement in function");
+}
+
+  static final public ClassBodyDeclaration ClassBodyDeclaration() throws ParseException {NodeListOptional n0 = new NodeListOptional();
+   FieldDeclaration n1;
+
+   printDebugInfo("ClassBodyDeclaration");
     label_3:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
@@ -252,20 +262,10 @@
         jj_la1[6] = jj_gen;
         break label_3;
       }
-      n25 = ClassBodyDeclaration();
-n24.addNode(n25);
+      n1 = FieldDeclaration();
+n0.addNode(n1);
     }
-n24.nodes.trimToSize();
-    n27 = jj_consume_token(RBRACE);
-n26 = JTBToolkit.makeNodeToken(n27);
-{if ("" != null) return new ClassDeclaration(n0,n8,n10,n12,n17,n22,n24,n26);}
-    throw new Error("Missing return statement in function");
-}
-
-  static final public ClassBodyDeclaration ClassBodyDeclaration() throws ParseException {FieldDeclaration n0;
-
-   printDebugInfo("ClassBodyDeclaration");
-    n0 = FieldDeclaration();
+n0.nodes.trimToSize();
 {if ("" != null) return new ClassBodyDeclaration(n0);}
     throw new Error("Missing return statement in function");
 }
Index: jtb.out.jj
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Generated by JTB 1.3.2\n//\n\noptions {\n   JAVA_UNICODE_ESCAPE = true;\n}\n\nPARSER_BEGIN(JavaParser)\nimport java.io.IOException;\nimport syntaxtree.*;\nimport java.util.Vector;\n\n\npublic class JavaParser \n{\n   static void printDebugInfo(String productionName)\n   {\n   }\n   public static void main(String args[])\n   {\n      JavaParser parser;\n      if ( args.length == 0 )\n      {\n         System.out.println(\"==========================================================================================================\");\n         System.out.println(\"==========================================================================================================\");\n         System.out.println(\"Java Parser Version 1.0.2:  Reading from standard input . . .\");\n         parser = new JavaParser(System.in);\n      }\n      else\n         if ( args.length == 1 )\n         {\n            System.out.println(\"==========================================================================================================\");\n            System.out.println(\"==========================================================================================================\");\n            System.out.println(\"Java Parser Version 1.0.2:  Reading from file \" + args[0]+ \" . . .\");\n            try\n            {\n               parser = new JavaParser(new java.io.FileInputStream(args[0]));\n            }\n            catch (java.io.FileNotFoundException e)\n            {\n               System.out.println(\"Java Parser Version 1.0.2:  File \" + args[0]+ \" not found.\");\n               return;\n            }\n         }\n         else\n         {\n            System.out.println(\"Java Parser Version 1.0.2:  Usage is one of:\");\n            System.out.println(\"         java JavaParser < inputfile\");\n            System.out.println(\"OR\");\n            System.out.println(\"         java JavaParser inputfile\");\n            return;\n         }\n      try\n      {\n         Node root = parser.CompilationUnit();\n         MyVisitor v = new MyVisitor();\n         root.accept(v);\n         v.writeOutputToFile();\n         System.out.println(\"Java Parser Version 1.0.2:  Java program parsed successfully.\");\n      }\n      catch (ParseException e)\n      {\n         System.out.println(\"Java Parser Version 1.0.2:  Encountered errors during parse.\");\n         System.out.println(e.toString());\n      }\n      catch (IOException e)\n      {\n         throw new RuntimeException(e);\n      }\n   }\n}\n\nclass JTBToolkit {\n   static NodeToken makeNodeToken(Token t) {\n      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);\n   }\n}\n\n\nPARSER_END(JavaParser)\n\nSKIP :\n{\n   \" \"\n   | \"\\t\"\n   | \"\\n\"\n   | \"\\r\"\n   | \"\\f\"\n}\n\nSPECIAL_TOKEN :\n{\n   <SINGLE_LINE_COMMENT: \"//\" (~[\"\\n\", \"\\r\"])* (\"\\n\" | \"\\r\" | \"\\r\\n\")>\n   | <FORMAL_COMMENT: \"/**\" (~[\"*\"])* \"*\" (\"*\" | (~[\"*\", \"/\"] (~[\"*\"])* \"*\"))* \"/\">\n   | <MULTI_LINE_COMMENT: \"/*\" (~[\"*\"])* \"*\" (\"*\" | (~[\"*\", \"/\"] (~[\"*\"])* \"*\"))* \"/\">\n}\n\nTOKEN :\n{\n   <ABSTRACT: \"abstract\">\n   | <BOOLEAN: \"boolean\">\n   | <BREAK: \"break\">\n   | <BYTE: \"byte\">\n   | <CASE: \"case\">\n   | <CATCH: \"catch\">\n   | <CHAR: \"char\">\n   | <CLASS: \"class\">\n   | <CONST: \"const\">\n   | <CONTINUE: \"continue\">\n   | <_DEFAULT: \"default\">\n   | <DO: \"do\">\n   | <DOUBLE: \"double\">\n   | <ELSE: \"else\">\n   | <EXTENDS: \"extends\">\n   | <FALSE: \"false\">\n   | <FINAL: \"final\">\n   | <FINALLY: \"finally\">\n   | <FLOAT: \"float\">\n   | <FOR: \"for\">\n   | <GOTO: \"goto\">\n   | <IF: \"if\">\n   | <IMPLEMENTS: \"implements\">\n   | <IMPORT: \"import\">\n   | <INSTANCEOF: \"instanceof\">\n   | <INT: \"int\">\n   | <INTERFACE: \"interface\">\n   | <LONG: \"long\">\n   | <NATIVE: \"native\">\n   | <NEW: \"new\">\n   | <NULL: \"null\">\n   | <PACKAGE: \"package\">\n   | <PRIVATE: \"private\">\n   | <PROTECTED: \"protected\">\n   | <PUBLIC: \"public\">\n   | <RETURN: \"return\">\n   | <SHORT: \"short\">\n   | <STATIC: \"static\">\n   | <SUPER: \"super\">\n   | <SWITCH: \"switch\">\n   | <SYNCHRONIZED: \"synchronized\">\n   | <THIS: \"this\">\n   | <THROW: \"throw\">\n   | <THROWS: \"throws\">\n   | <TRANSIENT: \"transient\">\n   | <TRUE: \"true\">\n   | <TRY: \"try\">\n   | <VOID: \"void\">\n   | <VOLATILE: \"volatile\">\n   | <WHILE: \"while\">\n   | <GET: \"get\">\n   | <SET: \"set\">\n}\n\nTOKEN :\n{\n   <INTEGER_LITERAL: <DECIMAL_LITERAL> ([\"l\", \"L\"])? | <HEX_LITERAL> ([\"l\", \"L\"])? | <OCTAL_LITERAL> ([\"l\", \"L\"])?>\n   | <#DECIMAL_LITERAL: [\"1\"-\"9\"] ([\"0\"-\"9\"])*>\n   | <#HEX_LITERAL: \"0\" [\"x\", \"X\"] ([\"0\"-\"9\", \"a\"-\"f\", \"A\"-\"F\"])+>\n   | <#OCTAL_LITERAL: \"0\" ([\"0\"-\"7\"])*>\n   | <FLOATING_POINT_LITERAL: ([\"0\"-\"9\"])+ \".\" ([\"0\"-\"9\"])* (<EXPONENT>)? ([\"f\", \"F\", \"d\", \"D\"])? | \".\" ([\"0\"-\"9\"])+ (<EXPONENT>)? ([\"f\", \"F\", \"d\", \"D\"])? | ([\"0\"-\"9\"])+ <EXPONENT> ([\"f\", \"F\", \"d\", \"D\"])? | ([\"0\"-\"9\"])+ (<EXPONENT>)? [\"f\", \"F\", \"d\", \"D\"]>\n   | <#EXPONENT: [\"e\", \"E\"] ([\"+\", \"-\"])? ([\"0\"-\"9\"])+>\n   | <CHARACTER_LITERAL: \"'\" ((~[\"'\", \"\\\\\", \"\\n\", \"\\r\"]) | (\"\\\\\" ([\"n\", \"t\", \"b\", \"r\", \"f\", \"\\\\\", \"'\", \"\\\"\"] | [\"0\"-\"7\"] ([\"0\"-\"7\"])? | [\"0\"-\"3\"] [\"0\"-\"7\"] [\"0\"-\"7\"]))) \"'\">\n   | <STRING_LITERAL: \"\\\"\" ((~[\"\\\"\", \"\\\\\", \"\\n\", \"\\r\"]) | (\"\\\\\" ([\"n\", \"t\", \"b\", \"r\", \"f\", \"\\\\\", \"'\", \"\\\"\"] | [\"0\"-\"7\"] ([\"0\"-\"7\"])? | [\"0\"-\"3\"] [\"0\"-\"7\"] [\"0\"-\"7\"])))* \"\\\"\">\n}\n\nTOKEN :\n{\n   <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>\n   | <#LETTER: [\"$\", \"A\"-\"Z\", \"_\", \"a\"-\"z\", \"\\u00c0\"-\"\\u00d6\", \"\\u00d8\"-\"\\u00f6\", \"\\u00f8\"-\"\\u00ff\", \"\\u0100\"-\"\\u1fff\", \"\\u3040\"-\"\\u318f\", \"\\u3300\"-\"\\u337f\", \"\\u3400\"-\"\\u3d2d\", \"\\u4e00\"-\"\\u9fff\", \"\\uf900\"-\"\\ufaff\"]>\n   | <#DIGIT: [\"0\"-\"9\", \"\\u0660\"-\"\\u0669\", \"\\u06f0\"-\"\\u06f9\", \"\\u0966\"-\"\\u096f\", \"\\u09e6\"-\"\\u09ef\", \"\\u0a66\"-\"\\u0a6f\", \"\\u0ae6\"-\"\\u0aef\", \"\\u0b66\"-\"\\u0b6f\", \"\\u0be7\"-\"\\u0bef\", \"\\u0c66\"-\"\\u0c6f\", \"\\u0ce6\"-\"\\u0cef\", \"\\u0d66\"-\"\\u0d6f\", \"\\u0e50\"-\"\\u0e59\", \"\\u0ed0\"-\"\\u0ed9\", \"\\u1040\"-\"\\u1049\"]>\n}\n\nTOKEN :\n{\n   <LPAREN: \"(\">\n   | <RPAREN: \")\">\n   | <LBRACE: \"{\">\n   | <RBRACE: \"}\">\n   | <LBRACKET: \"[\">\n   | <RBRACKET: \"]\">\n   | <SEMICOLON: \";\">\n   | <COMMA: \",\">\n   | <DOT: \".\">\n}\n\nTOKEN :\n{\n   <ASSIGN: \"=\">\n   | <GT: \">\">\n   | <LT: \"<\">\n   | <BANG: \"!\">\n   | <TILDE: \"~\">\n   | <HOOK: \"?\">\n   | <COLON: \":\">\n   | <EQ: \"==\">\n   | <LE: \"<=\">\n   | <GE: \">=\">\n   | <NE: \"!=\">\n   | <SC_OR: \"||\">\n   | <SC_AND: \"&&\">\n   | <INCR: \"++\">\n   | <DECR: \"--\">\n   | <PLUS: \"+\">\n   | <MINUS: \"-\">\n   | <STAR: \"*\">\n   | <SLASH: \"/\">\n   | <BIT_AND: \"&\">\n   | <BIT_OR: \"|\">\n   | <XOR: \"^\">\n   | <REM: \"%\">\n   | <LSHIFT: \"<<\">\n   | <RSIGNEDSHIFT: \">>\">\n   | <RUNSIGNEDSHIFT: \">>>\">\n   | <PLUSASSIGN: \"+=\">\n   | <MINUSASSIGN: \"-=\">\n   | <STARASSIGN: \"*=\">\n   | <SLASHASSIGN: \"/=\">\n   | <ANDASSIGN: \"&=\">\n   | <ORASSIGN: \"|=\">\n   | <XORASSIGN: \"^=\">\n   | <REMASSIGN: \"%=\">\n   | <LSHIFTASSIGN: \"<<=\">\n   | <RSIGNEDSHIFTASSIGN: \">>=\">\n   | <RUNSIGNEDSHIFTASSIGN: \">>>=\">\n}\n\nCompilationUnit CompilationUnit() :\n{\n   NodeListOptional n0 = new NodeListOptional();\n   TypeDeclaration n1;\n   NodeToken n2;\n   Token n3;\n\n   printDebugInfo(\"CompilationUnit\");\n}\n{\n   (\n      n1=TypeDeclaration()\n      { n0.addNode(n1); }\n   )*\n   { n0.nodes.trimToSize(); }\n   n3=<EOF> { \n      n3.beginColumn++; n3.endColumn++;\n      n2 = JTBToolkit.makeNodeToken(n3);\n   }\n   \n   { return new CompilationUnit(n0,n2); }\n}\n\nTypeDeclaration TypeDeclaration() :\n{\n   NodeChoice n0;\n   ClassDeclaration n1;\n   NodeToken n2;\n   Token n3;\n\n   printDebugInfo(\"TypeDeclaration\");\n}\n{\n   (\n      LOOKAHEAD(( \"abstract\" | \"final\" | \"public\" )* \"class\")\n      n1=ClassDeclaration()\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      n3=\";\" { n2 = JTBToolkit.makeNodeToken(n3); }\n      { n0 = new NodeChoice(n2, 1); }\n   )\n   \n   { return new TypeDeclaration(n0); }\n}\n\nClassDeclaration ClassDeclaration() :\n{\n   NodeListOptional n0 = new NodeListOptional();\n   NodeChoice n1;\n   NodeToken n2;\n   Token n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n   NodeToken n8;\n   Token n9;\n   NodeToken n10;\n   Token n11;\n   NodeOptional n12 = new NodeOptional();\n   NodeSequence n13;\n   NodeToken n14;\n   Token n15;\n   Name n16;\n   NodeOptional n17 = new NodeOptional();\n   NodeSequence n18;\n   NodeToken n19;\n   Token n20;\n   NameList n21;\n   NodeToken n22;\n   Token n23;\n   NodeListOptional n24 = new NodeListOptional();\n   ClassBodyDeclaration n25;\n   NodeToken n26;\n   Token n27;\n\n   printDebugInfo(\"ClassDeclaration\");\n}\n{\n   (\n      (\n         n3=\"abstract\" { n2 = JTBToolkit.makeNodeToken(n3); }\n         { n1 = new NodeChoice(n2, 0); }\n      |\n         n5=\"final\" { n4 = JTBToolkit.makeNodeToken(n5); }\n         { n1 = new NodeChoice(n4, 1); }\n      |\n         n7=\"public\" { n6 = JTBToolkit.makeNodeToken(n7); }\n         { n1 = new NodeChoice(n6, 2); }\n      )\n      { n0.addNode(n1); }\n   )*\n   { n0.nodes.trimToSize(); }\n   n9=\"class\" { n8 = JTBToolkit.makeNodeToken(n9); }\n   n11=<IDENTIFIER> { n10 = JTBToolkit.makeNodeToken(n11); }\n   (\n      { n13 = new NodeSequence(2); }\n      n15=\"extends\" { n14 = JTBToolkit.makeNodeToken(n15); }\n      { n13.addNode(n14); }\n      n16=Name()\n      { n13.addNode(n16); }\n      { n12.addNode(n13); }\n   )?\n   (\n      { n18 = new NodeSequence(2); }\n      n20=\"implements\" { n19 = JTBToolkit.makeNodeToken(n20); }\n      { n18.addNode(n19); }\n      n21=NameList()\n      { n18.addNode(n21); }\n      { n17.addNode(n18); }\n   )?\n   n23=\"{\" { n22 = JTBToolkit.makeNodeToken(n23); }\n   (\n      n25=ClassBodyDeclaration()\n      { n24.addNode(n25); }\n   )*\n   { n24.nodes.trimToSize(); }\n   n27=\"}\" { n26 = JTBToolkit.makeNodeToken(n27); }\n   \n   { return new ClassDeclaration(n0,n8,n10,n12,n17,n22,n24,n26); }\n}\n\nClassBodyDeclaration ClassBodyDeclaration() :\n{\n   FieldDeclaration n0;\n\n   printDebugInfo(\"ClassBodyDeclaration\");\n}\n{\n   n0=FieldDeclaration()\n   \n   { return new ClassBodyDeclaration(n0); }\n}\n\nFieldDeclaration FieldDeclaration() :\n{\n   NodeListOptional n0 = new NodeListOptional();\n   field_modifier n1;\n   Type n2;\n   NodeToken n3;\n   Token n4;\n   field_body n5;\n\n   printDebugInfo(\"FieldDeclaration\");\n}\n{\n   (\n      n1=field_modifier()\n      { n0.addNode(n1); }\n   )*\n   { n0.nodes.trimToSize(); }\n   n2=Type()\n   n4=<IDENTIFIER> { n3 = JTBToolkit.makeNodeToken(n4); }\n   n5=field_body()\n   \n   { return new FieldDeclaration(n0,n2,n3,n5); }\n}\n\nfield_modifier field_modifier() :\n{\n   NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n   NodeToken n9;\n   Token n10;\n   NodeToken n11;\n   Token n12;\n\n   printDebugInfo(\"field_modifier\");\n}\n{\n   (\n      n2=\"new\" { n1 = JTBToolkit.makeNodeToken(n2); }\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      n4=\"public\" { n3 = JTBToolkit.makeNodeToken(n4); }\n      { n0 = new NodeChoice(n3, 1); }\n   |\n      n6=\"protected\" { n5 = JTBToolkit.makeNodeToken(n6); }\n      { n0 = new NodeChoice(n5, 2); }\n   |\n      n8=\"private\" { n7 = JTBToolkit.makeNodeToken(n8); }\n      { n0 = new NodeChoice(n7, 3); }\n   |\n      n10=\"static\" { n9 = JTBToolkit.makeNodeToken(n10); }\n      { n0 = new NodeChoice(n9, 4); }\n   |\n      n12=\"abstract\" { n11 = JTBToolkit.makeNodeToken(n12); }\n      { n0 = new NodeChoice(n11, 5); }\n   )\n   \n   { return new field_modifier(n0); }\n}\n\nfield_body field_body() :\n{\n   NodeChoice n0;\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   Expression n4;\n   NodeChoice n5;\n   NodeSequence n6;\n   NodeToken n7;\n   Token n8;\n   accessor_declarations n9;\n   NodeToken n10;\n   Token n11;\n   NodeToken n12;\n   Token n13;\n   NodeSequence n14;\n   NodeToken n15;\n   Token n16;\n   accessor_declarations n17;\n   NodeToken n18;\n   Token n19;\n   NodeToken n20;\n   Token n21;\n\n   printDebugInfo(\"field_body\");\n}\n{\n   (\n      (\n         LOOKAHEAD(3)\n         { n1 = new NodeSequence(4); }\n         n3=\"=\" { n2 = JTBToolkit.makeNodeToken(n3); }\n         { n1.addNode(n2); }\n         n4=Expression()\n         { n1.addNode(n4); }\n         (\n            (\n               { n6 = new NodeSequence(3); }\n               n8=\"{\" { n7 = JTBToolkit.makeNodeToken(n8); }\n               { n6.addNode(n7); }\n               n9=accessor_declarations()\n               { n6.addNode(n9); }\n               n11=\"}\" { n10 = JTBToolkit.makeNodeToken(n11); }\n               { n6.addNode(n10); }\n               { n5 = new NodeChoice(n6, 0); }\n            |\n               n13=\";\" { n12 = JTBToolkit.makeNodeToken(n13); }\n               { n5 = new NodeChoice(n12, 1); }\n            )\n            \n         )\n         { n1.addNode(n5); }\n         { n0 = new NodeChoice(n1, 0); }\n      |\n         { n14 = new NodeSequence(3); }\n         n16=\"{\" { n15 = JTBToolkit.makeNodeToken(n16); }\n         { n14.addNode(n15); }\n         n17=accessor_declarations()\n         { n14.addNode(n17); }\n         n19=\"}\" { n18 = JTBToolkit.makeNodeToken(n19); }\n         { n14.addNode(n18); }\n         { n0 = new NodeChoice(n14, 1); }\n      |\n         n21=\";\" { n20 = JTBToolkit.makeNodeToken(n21); }\n         { n0 = new NodeChoice(n20, 2); }\n      )\n      \n   )\n   \n   { return new field_body(n0); }\n}\n\naccessor_declarations accessor_declarations() :\n{\n   NodeChoice n0;\n   NodeSequence n1;\n   accessor_get_declaration n2;\n   NodeOptional n3 = new NodeOptional();\n   accessor_set_declaration n4;\n   NodeSequence n5;\n   accessor_set_declaration n6;\n   NodeOptional n7 = new NodeOptional();\n   accessor_get_declaration n8;\n\n   printDebugInfo(\"accessor_declarations\");\n}\n{\n   (\n      (\n         LOOKAHEAD(2)\n         { n1 = new NodeSequence(3); }\n         n2=accessor_get_declaration()\n         { n1.addNode(n2); }\n         (\n            LOOKAHEAD(2)\n            n4=accessor_set_declaration()\n            { n3.addNode(n4); }\n         )?\n         { n1.addNode(n3); }\n         { n0 = new NodeChoice(n1, 0); }\n      |\n         LOOKAHEAD(2)\n         { n5 = new NodeSequence(3); }\n         n6=accessor_set_declaration()\n         { n5.addNode(n6); }\n         (\n            LOOKAHEAD(2)\n            n8=accessor_get_declaration()\n            { n7.addNode(n8); }\n         )?\n         { n5.addNode(n7); }\n         { n0 = new NodeChoice(n5, 1); }\n      )\n      \n   )\n   \n   { return new accessor_declarations(n0); }\n}\n\naccessor_get_declaration accessor_get_declaration() :\n{\n   NodeOptional n0 = new NodeOptional();\n   NodeChoice n1;\n   NodeToken n2;\n   Token n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n   NodeToken n8;\n   Token n9;\n\n   printDebugInfo(\"accessor_get_declaration\");\n}\n{\n   (\n      (\n         n3=\"private\" { n2 = JTBToolkit.makeNodeToken(n3); }\n         { n1 = new NodeChoice(n2, 0); }\n      |\n         n5=\"public\" { n4 = JTBToolkit.makeNodeToken(n5); }\n         { n1 = new NodeChoice(n4, 1); }\n      )\n      { n0.addNode(n1); }\n   )?\n   n7=<GET> { n6 = JTBToolkit.makeNodeToken(n7); }\n   n9=\";\" { n8 = JTBToolkit.makeNodeToken(n9); }\n   \n   { return new accessor_get_declaration(n0,n6,n8); }\n}\n\naccessor_set_declaration accessor_set_declaration() :\n{\n   NodeOptional n0 = new NodeOptional();\n   NodeChoice n1;\n   NodeToken n2;\n   Token n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n   NodeToken n8;\n   Token n9;\n\n   printDebugInfo(\"accessor_set_declaration\");\n}\n{\n   (\n      (\n         n3=\"private\" { n2 = JTBToolkit.makeNodeToken(n3); }\n         { n1 = new NodeChoice(n2, 0); }\n      |\n         n5=\"public\" { n4 = JTBToolkit.makeNodeToken(n5); }\n         { n1 = new NodeChoice(n4, 1); }\n      )\n      { n0.addNode(n1); }\n   )?\n   n7=<SET> { n6 = JTBToolkit.makeNodeToken(n7); }\n   n9=\";\" { n8 = JTBToolkit.makeNodeToken(n9); }\n   \n   { return new accessor_set_declaration(n0,n6,n8); }\n}\n\nVariableDeclarator VariableDeclarator() :\n{\n   VariableDeclaratorId n0;\n   NodeOptional n1 = new NodeOptional();\n   NodeSequence n2;\n   NodeToken n3;\n   Token n4;\n   VariableInitializer n5;\n\n   printDebugInfo(\"VariableDeclarator\");\n}\n{\n   n0=VariableDeclaratorId()\n   (\n      { n2 = new NodeSequence(2); }\n      n4=\"=\" { n3 = JTBToolkit.makeNodeToken(n4); }\n      { n2.addNode(n3); }\n      n5=VariableInitializer()\n      { n2.addNode(n5); }\n      { n1.addNode(n2); }\n   )?\n   \n   { return new VariableDeclarator(n0,n1); }\n}\n\nVariableDeclaratorId VariableDeclaratorId() :\n{\n   NodeToken n0;\n   Token n1;\n   NodeListOptional n2 = new NodeListOptional();\n   NodeSequence n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n\n   printDebugInfo(\"VariableDeclaratorId\");\n}\n{\n   n1=<IDENTIFIER> { n0 = JTBToolkit.makeNodeToken(n1); }\n   (\n      { n3 = new NodeSequence(2); }\n      n5=\"[\" { n4 = JTBToolkit.makeNodeToken(n5); }\n      { n3.addNode(n4); }\n      n7=\"]\" { n6 = JTBToolkit.makeNodeToken(n7); }\n      { n3.addNode(n6); }\n      { n2.addNode(n3); }\n   )*\n   { n2.nodes.trimToSize(); }\n   \n   { return new VariableDeclaratorId(n0,n2); }\n}\n\nVariableInitializer VariableInitializer() :\n{\n   NodeChoice n0;\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   NodeOptional n4 = new NodeOptional();\n   NodeSequence n5;\n   VariableInitializer n6;\n   NodeListOptional n7;\n   NodeSequence n8;\n   NodeToken n9;\n   Token n10;\n   VariableInitializer n11;\n   NodeOptional n12 = new NodeOptional();\n   NodeToken n13;\n   Token n14;\n   NodeToken n15;\n   Token n16;\n   Expression n17;\n\n   printDebugInfo(\"VariableInit\");\n}\n{\n   (\n      { n1 = new NodeSequence(4); }\n      n3=\"{\" { n2 = JTBToolkit.makeNodeToken(n3); }\n      { n1.addNode(n2); }\n      (\n         { n7 = new NodeListOptional(); }\n         { n5 = new NodeSequence(2); }\n         n6=VariableInitializer()\n         { n5.addNode(n6); }\n         (\n            LOOKAHEAD(2)\n            { n8 = new NodeSequence(2); }\n            n10=\",\" { n9 = JTBToolkit.makeNodeToken(n10); }\n            { n8.addNode(n9); }\n            n11=VariableInitializer()\n            { n8.addNode(n11); }\n            { n7.addNode(n8); }\n         )*\n         { n7.nodes.trimToSize(); }\n         { n5.addNode(n7); }\n         { n4.addNode(n5); }\n      )?\n      { n1.addNode(n4); }\n      (\n         n14=\",\" { n13 = JTBToolkit.makeNodeToken(n14); }\n         { n12.addNode(n13); }\n      )?\n      { n1.addNode(n12); }\n      n16=\"}\" { n15 = JTBToolkit.makeNodeToken(n16); }\n      { n1.addNode(n15); }\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      n17=Expression()\n      { n0 = new NodeChoice(n17, 1); }\n   )\n   \n   { return new VariableInitializer(n0); }\n}\n\nType Type() :\n{\n   NodeChoice n0;\n   PrimitiveType n1;\n   Name n2;\n   NodeListOptional n3 = new NodeListOptional();\n   NodeSequence n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n\n   \n}\n{\n   (\n      (\n         n1=PrimitiveType()\n         { n0 = new NodeChoice(n1, 0); }\n      |\n         n2=Name()\n         { n0 = new NodeChoice(n2, 1); }\n      )\n      \n   )\n   (\n      { n4 = new NodeSequence(2); }\n      n6=\"[\" { n5 = JTBToolkit.makeNodeToken(n6); }\n      { n4.addNode(n5); }\n      n8=\"]\" { n7 = JTBToolkit.makeNodeToken(n8); }\n      { n4.addNode(n7); }\n      { n3.addNode(n4); }\n   )*\n   { n3.nodes.trimToSize(); }\n   \n   { return new Type(n0,n3); }\n}\n\nPrimitiveType PrimitiveType() :\n{\n   NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n   NodeToken n9;\n   Token n10;\n   NodeToken n11;\n   Token n12;\n   NodeToken n13;\n   Token n14;\n   NodeToken n15;\n   Token n16;\n\n   \n}\n{\n   (\n      n2=\"boolean\" { n1 = JTBToolkit.makeNodeToken(n2); }\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      n4=\"char\" { n3 = JTBToolkit.makeNodeToken(n4); }\n      { n0 = new NodeChoice(n3, 1); }\n   |\n      n6=\"byte\" { n5 = JTBToolkit.makeNodeToken(n6); }\n      { n0 = new NodeChoice(n5, 2); }\n   |\n      n8=\"short\" { n7 = JTBToolkit.makeNodeToken(n8); }\n      { n0 = new NodeChoice(n7, 3); }\n   |\n      n10=\"int\" { n9 = JTBToolkit.makeNodeToken(n10); }\n      { n0 = new NodeChoice(n9, 4); }\n   |\n      n12=\"long\" { n11 = JTBToolkit.makeNodeToken(n12); }\n      { n0 = new NodeChoice(n11, 5); }\n   |\n      n14=\"float\" { n13 = JTBToolkit.makeNodeToken(n14); }\n      { n0 = new NodeChoice(n13, 6); }\n   |\n      n16=\"double\" { n15 = JTBToolkit.makeNodeToken(n16); }\n      { n0 = new NodeChoice(n15, 7); }\n   )\n   \n   { return new PrimitiveType(n0); }\n}\n\nName Name() :\n{\n   NodeToken n0;\n   Token n1;\n   NodeListOptional n2 = new NodeListOptional();\n   NodeSequence n3;\n   NodeToken n4;\n   Token n5;\n   NodeToken n6;\n   Token n7;\n\n   \n}\n{\n   n1=<IDENTIFIER> { n0 = JTBToolkit.makeNodeToken(n1); }\n   (\n      LOOKAHEAD(2)\n      { n3 = new NodeSequence(2); }\n      n5=\".\" { n4 = JTBToolkit.makeNodeToken(n5); }\n      { n3.addNode(n4); }\n      n7=<IDENTIFIER> { n6 = JTBToolkit.makeNodeToken(n7); }\n      { n3.addNode(n6); }\n      { n2.addNode(n3); }\n   )*\n   { n2.nodes.trimToSize(); }\n   \n   { return new Name(n0,n2); }\n}\n\nNameList NameList() :\n{\n   Name n0;\n   NodeListOptional n1 = new NodeListOptional();\n   NodeSequence n2;\n   NodeToken n3;\n   Token n4;\n   Name n5;\n\n   \n}\n{\n   n0=Name()\n   (\n      { n2 = new NodeSequence(2); }\n      n4=\",\" { n3 = JTBToolkit.makeNodeToken(n4); }\n      { n2.addNode(n3); }\n      n5=Name()\n      { n2.addNode(n5); }\n      { n1.addNode(n2); }\n   )*\n   { n1.nodes.trimToSize(); }\n   \n   { return new NameList(n0,n1); }\n}\n\nExpression Expression() :\n{\n   Assignment n0;\n\n   printDebugInfo(\"Expression\");\n}\n{\n   LOOKAHEAD(PrimaryExpression() AssignmentOperator())\n   n0=Assignment()\n   \n   { return new Expression(n0); }\n}\n\nAssignment Assignment() :\n{\n   PrimaryExpression n0;\n   AssignmentOperator n1;\n   Expression n2;\n\n   printDebugInfo(\"Assignment\");\n}\n{\n   n0=PrimaryExpression()\n   n1=AssignmentOperator()\n   n2=Expression()\n   \n   { return new Assignment(n0,n1,n2); }\n}\n\nAssignmentOperator AssignmentOperator() :\n{\n   NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n   NodeToken n9;\n   Token n10;\n   NodeToken n11;\n   Token n12;\n   NodeToken n13;\n   Token n14;\n   NodeToken n15;\n   Token n16;\n   NodeToken n17;\n   Token n18;\n   NodeToken n19;\n   Token n20;\n   NodeToken n21;\n   Token n22;\n   NodeToken n23;\n   Token n24;\n\n   \n}\n{\n   (\n      n2=\"=\" { n1 = JTBToolkit.makeNodeToken(n2); }\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      n4=\"*=\" { n3 = JTBToolkit.makeNodeToken(n4); }\n      { n0 = new NodeChoice(n3, 1); }\n   |\n      n6=\"/=\" { n5 = JTBToolkit.makeNodeToken(n6); }\n      { n0 = new NodeChoice(n5, 2); }\n   |\n      n8=\"%=\" { n7 = JTBToolkit.makeNodeToken(n8); }\n      { n0 = new NodeChoice(n7, 3); }\n   |\n      n10=\"+=\" { n9 = JTBToolkit.makeNodeToken(n10); }\n      { n0 = new NodeChoice(n9, 4); }\n   |\n      n12=\"-=\" { n11 = JTBToolkit.makeNodeToken(n12); }\n      { n0 = new NodeChoice(n11, 5); }\n   |\n      n14=\"<<=\" { n13 = JTBToolkit.makeNodeToken(n14); }\n      { n0 = new NodeChoice(n13, 6); }\n   |\n      n16=\">>=\" { n15 = JTBToolkit.makeNodeToken(n16); }\n      { n0 = new NodeChoice(n15, 7); }\n   |\n      n18=\">>>=\" { n17 = JTBToolkit.makeNodeToken(n18); }\n      { n0 = new NodeChoice(n17, 8); }\n   |\n      n20=\"&=\" { n19 = JTBToolkit.makeNodeToken(n20); }\n      { n0 = new NodeChoice(n19, 9); }\n   |\n      n22=\"^=\" { n21 = JTBToolkit.makeNodeToken(n22); }\n      { n0 = new NodeChoice(n21, 10); }\n   |\n      n24=\"|=\" { n23 = JTBToolkit.makeNodeToken(n24); }\n      { n0 = new NodeChoice(n23, 11); }\n   )\n   \n   { return new AssignmentOperator(n0); }\n}\n\nPrimaryExpression PrimaryExpression() :\n{\n   PrimaryPrefix n0;\n   NodeListOptional n1 = new NodeListOptional();\n   PrimarySuffix n2;\n\n   \n}\n{\n   n0=PrimaryPrefix()\n   (\n      n2=PrimarySuffix()\n      { n1.addNode(n2); }\n   )*\n   { n1.nodes.trimToSize(); }\n   \n   { return new PrimaryExpression(n0,n1); }\n}\n\nPrimaryPrefix PrimaryPrefix() :\n{\n   NodeChoice n0;\n   Literal n1;\n   Name n2;\n   NodeToken n3;\n   Token n4;\n   NodeSequence n5;\n   NodeToken n6;\n   Token n7;\n   NodeToken n8;\n   Token n9;\n   NodeToken n10;\n   Token n11;\n   NodeSequence n12;\n   NodeToken n13;\n   Token n14;\n   Expression n15;\n   NodeToken n16;\n   Token n17;\n   AllocationExpression n18;\n\n   \n}\n{\n   (\n      n1=Literal()\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      n2=Name()\n      { n0 = new NodeChoice(n2, 1); }\n   |\n      n4=\"this\" { n3 = JTBToolkit.makeNodeToken(n4); }\n      { n0 = new NodeChoice(n3, 2); }\n   |\n      { n5 = new NodeSequence(3); }\n      n7=\"super\" { n6 = JTBToolkit.makeNodeToken(n7); }\n      { n5.addNode(n6); }\n      n9=\".\" { n8 = JTBToolkit.makeNodeToken(n9); }\n      { n5.addNode(n8); }\n      n11=<IDENTIFIER> { n10 = JTBToolkit.makeNodeToken(n11); }\n      { n5.addNode(n10); }\n      { n0 = new NodeChoice(n5, 3); }\n   |\n      { n12 = new NodeSequence(3); }\n      n14=\"(\" { n13 = JTBToolkit.makeNodeToken(n14); }\n      { n12.addNode(n13); }\n      n15=Expression()\n      { n12.addNode(n15); }\n      n17=\")\" { n16 = JTBToolkit.makeNodeToken(n17); }\n      { n12.addNode(n16); }\n      { n0 = new NodeChoice(n12, 4); }\n   |\n      n18=AllocationExpression()\n      { n0 = new NodeChoice(n18, 5); }\n   )\n   \n   { return new PrimaryPrefix(n0); }\n}\n\nPrimarySuffix PrimarySuffix() :\n{\n   NodeChoice n0;\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   Expression n4;\n   NodeToken n5;\n   Token n6;\n   NodeSequence n7;\n   NodeToken n8;\n   Token n9;\n   NodeToken n10;\n   Token n11;\n   Arguments n12;\n\n   \n}\n{\n   (\n      { n1 = new NodeSequence(3); }\n      n3=\"[\" { n2 = JTBToolkit.makeNodeToken(n3); }\n      { n1.addNode(n2); }\n      n4=Expression()\n      { n1.addNode(n4); }\n      n6=\"]\" { n5 = JTBToolkit.makeNodeToken(n6); }\n      { n1.addNode(n5); }\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      { n7 = new NodeSequence(2); }\n      n9=\".\" { n8 = JTBToolkit.makeNodeToken(n9); }\n      { n7.addNode(n8); }\n      n11=<IDENTIFIER> { n10 = JTBToolkit.makeNodeToken(n11); }\n      { n7.addNode(n10); }\n      { n0 = new NodeChoice(n7, 1); }\n   |\n      n12=Arguments()\n      { n0 = new NodeChoice(n12, 2); }\n   )\n   \n   { return new PrimarySuffix(n0); }\n}\n\nLiteral Literal() :\n{\n   NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n   NodeToken n5;\n   Token n6;\n   NodeToken n7;\n   Token n8;\n   BooleanLiteral n9;\n   NullLiteral n10;\n\n   \n}\n{\n   (\n      n2=<INTEGER_LITERAL> { n1 = JTBToolkit.makeNodeToken(n2); }\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      n4=<FLOATING_POINT_LITERAL> { n3 = JTBToolkit.makeNodeToken(n4); }\n      { n0 = new NodeChoice(n3, 1); }\n   |\n      n6=<CHARACTER_LITERAL> { n5 = JTBToolkit.makeNodeToken(n6); }\n      { n0 = new NodeChoice(n5, 2); }\n   |\n      n8=<STRING_LITERAL> { n7 = JTBToolkit.makeNodeToken(n8); }\n      { n0 = new NodeChoice(n7, 3); }\n   |\n      n9=BooleanLiteral()\n      { n0 = new NodeChoice(n9, 4); }\n   |\n      n10=NullLiteral()\n      { n0 = new NodeChoice(n10, 5); }\n   )\n   \n   { return new Literal(n0); }\n}\n\nBooleanLiteral BooleanLiteral() :\n{\n   NodeChoice n0;\n   NodeToken n1;\n   Token n2;\n   NodeToken n3;\n   Token n4;\n\n   \n}\n{\n   (\n      n2=\"true\" { n1 = JTBToolkit.makeNodeToken(n2); }\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      n4=\"false\" { n3 = JTBToolkit.makeNodeToken(n4); }\n      { n0 = new NodeChoice(n3, 1); }\n   )\n   \n   { return new BooleanLiteral(n0); }\n}\n\nNullLiteral NullLiteral() :\n{\n   NodeToken n0;\n   Token n1;\n\n   \n}\n{\n   n1=\"null\" { n0 = JTBToolkit.makeNodeToken(n1); }\n   \n   { return new NullLiteral(n0); }\n}\n\nArguments Arguments() :\n{\n   NodeToken n0;\n   Token n1;\n   NodeOptional n2 = new NodeOptional();\n   ArgumentList n3;\n   NodeToken n4;\n   Token n5;\n\n   \n}\n{\n   n1=\"(\" { n0 = JTBToolkit.makeNodeToken(n1); }\n   (\n      n3=ArgumentList()\n      { n2.addNode(n3); }\n   )?\n   n5=\")\" { n4 = JTBToolkit.makeNodeToken(n5); }\n   \n   { return new Arguments(n0,n2,n4); }\n}\n\nArgumentList ArgumentList() :\n{\n   Expression n0;\n   NodeListOptional n1 = new NodeListOptional();\n   NodeSequence n2;\n   NodeToken n3;\n   Token n4;\n   Expression n5;\n\n   \n}\n{\n   n0=Expression()\n   (\n      { n2 = new NodeSequence(2); }\n      n4=\",\" { n3 = JTBToolkit.makeNodeToken(n4); }\n      { n2.addNode(n3); }\n      n5=Expression()\n      { n2.addNode(n5); }\n      { n1.addNode(n2); }\n   )*\n   { n1.nodes.trimToSize(); }\n   \n   { return new ArgumentList(n0,n1); }\n}\n\nAllocationExpression AllocationExpression() :\n{\n   NodeChoice n0;\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   PrimitiveType n4;\n   ArrayDimensions n5;\n   NodeSequence n6;\n   NodeToken n7;\n   Token n8;\n   Name n9;\n   NodeChoice n10;\n   Arguments n11;\n   ArrayDimensions n12;\n\n   \n}\n{\n   (\n      LOOKAHEAD(2)\n      { n1 = new NodeSequence(4); }\n      n3=\"new\" { n2 = JTBToolkit.makeNodeToken(n3); }\n      { n1.addNode(n2); }\n      n4=PrimitiveType()\n      { n1.addNode(n4); }\n      n5=ArrayDimensions()\n      { n1.addNode(n5); }\n      { n0 = new NodeChoice(n1, 0); }\n   |\n      { n6 = new NodeSequence(3); }\n      n8=\"new\" { n7 = JTBToolkit.makeNodeToken(n8); }\n      { n6.addNode(n7); }\n      n9=Name()\n      { n6.addNode(n9); }\n      (\n         (\n            n11=Arguments()\n            { n10 = new NodeChoice(n11, 0); }\n         |\n            n12=ArrayDimensions()\n            { n10 = new NodeChoice(n12, 1); }\n         )\n         \n      )\n      { n6.addNode(n10); }\n      { n0 = new NodeChoice(n6, 1); }\n   )\n   \n   { return new AllocationExpression(n0); }\n}\n\nArrayDimensions ArrayDimensions() :\n{\n   NodeList n0 = new NodeList();\n   NodeSequence n1;\n   NodeToken n2;\n   Token n3;\n   Expression n4;\n   NodeToken n5;\n   Token n6;\n   NodeListOptional n7 = new NodeListOptional();\n   NodeSequence n8;\n   NodeToken n9;\n   Token n10;\n   NodeToken n11;\n   Token n12;\n\n   \n}\n{\n   (\n      LOOKAHEAD(2)\n      { n1 = new NodeSequence(3); }\n      n3=\"[\" { n2 = JTBToolkit.makeNodeToken(n3); }\n      { n1.addNode(n2); }\n      n4=Expression()\n      { n1.addNode(n4); }\n      n6=\"]\" { n5 = JTBToolkit.makeNodeToken(n6); }\n      { n1.addNode(n5); }\n      { n0.addNode(n1); }\n   )+\n   { n0.nodes.trimToSize(); }\n   (\n      LOOKAHEAD(2)\n      { n8 = new NodeSequence(2); }\n      n10=\"[\" { n9 = JTBToolkit.makeNodeToken(n10); }\n      { n8.addNode(n9); }\n      n12=\"]\" { n11 = JTBToolkit.makeNodeToken(n12); }\n      { n8.addNode(n11); }\n      { n7.addNode(n8); }\n   )*\n   { n7.nodes.trimToSize(); }\n   \n   { return new ArrayDimensions(n0,n7); }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/jtb.out.jj b/jtb.out.jj
--- a/jtb.out.jj	(revision c51677d6d89c37f22eefc6cfc61c824ecc42a657)
+++ b/jtb.out.jj	(date 1683052205929)
@@ -296,10 +296,9 @@
    NameList n21;
    NodeToken n22;
    Token n23;
-   NodeListOptional n24 = new NodeListOptional();
-   ClassBodyDeclaration n25;
-   NodeToken n26;
-   Token n27;
+   ClassBodyDeclaration n24;
+   NodeToken n25;
+   Token n26;
 
    printDebugInfo("ClassDeclaration");
 }
@@ -337,24 +336,25 @@
       { n17.addNode(n18); }
    )?
    n23="{" { n22 = JTBToolkit.makeNodeToken(n23); }
-   (
-      n25=ClassBodyDeclaration()
-      { n24.addNode(n25); }
-   )*
-   { n24.nodes.trimToSize(); }
-   n27="}" { n26 = JTBToolkit.makeNodeToken(n27); }
+   n24=ClassBodyDeclaration()
+   n26="}" { n25 = JTBToolkit.makeNodeToken(n26); }
    
-   { return new ClassDeclaration(n0,n8,n10,n12,n17,n22,n24,n26); }
+   { return new ClassDeclaration(n0,n8,n10,n12,n17,n22,n24,n25); }
 }
 
 ClassBodyDeclaration ClassBodyDeclaration() :
 {
-   FieldDeclaration n0;
+   NodeListOptional n0 = new NodeListOptional();
+   FieldDeclaration n1;
 
    printDebugInfo("ClassBodyDeclaration");
 }
 {
-   n0=FieldDeclaration()
+   (
+      n1=FieldDeclaration()
+      { n0.addNode(n1); }
+   )*
+   { n0.nodes.trimToSize(); }
    
    { return new ClassBodyDeclaration(n0); }
 }
